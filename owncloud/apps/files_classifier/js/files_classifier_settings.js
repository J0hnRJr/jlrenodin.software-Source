(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/json/stringify"), __esModule: true };
},{"core-js/library/fn/json/stringify":2}],2:[function(require,module,exports){
var core = require('../../modules/_core');
var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};

},{"../../modules/_core":3}],3:[function(require,module,exports){
var core = module.exports = { version: '2.6.11' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],4:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],5:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":4,"timers":5}],6:[function(require,module,exports){
var Vue // late bind
var version
var map = Object.create(null)
if (typeof window !== 'undefined') {
  window.__VUE_HOT_MAP__ = map
}
var installed = false
var isBrowserify = false
var initHookName = 'beforeCreate'

exports.install = function (vue, browserify) {
  if (installed) { return }
  installed = true

  Vue = vue.__esModule ? vue.default : vue
  version = Vue.version.split('.').map(Number)
  isBrowserify = browserify

  // compat with < 2.0.0-alpha.7
  if (Vue.config._lifecycleHooks.indexOf('init') > -1) {
    initHookName = 'init'
  }

  exports.compatible = version[0] >= 2
  if (!exports.compatible) {
    console.warn(
      '[HMR] You are using a version of vue-hot-reload-api that is ' +
        'only compatible with Vue.js core ^2.0.0.'
    )
    return
  }
}

/**
 * Create a record for a hot module, which keeps track of its constructor
 * and instances
 *
 * @param {String} id
 * @param {Object} options
 */

exports.createRecord = function (id, options) {
  if(map[id]) { return }

  var Ctor = null
  if (typeof options === 'function') {
    Ctor = options
    options = Ctor.options
  }
  makeOptionsHot(id, options)
  map[id] = {
    Ctor: Ctor,
    options: options,
    instances: []
  }
}

/**
 * Check if module is recorded
 *
 * @param {String} id
 */

exports.isRecorded = function (id) {
  return typeof map[id] !== 'undefined'
}

/**
 * Make a Component options object hot.
 *
 * @param {String} id
 * @param {Object} options
 */

function makeOptionsHot(id, options) {
  if (options.functional) {
    var render = options.render
    options.render = function (h, ctx) {
      var instances = map[id].instances
      if (ctx && instances.indexOf(ctx.parent) < 0) {
        instances.push(ctx.parent)
      }
      return render(h, ctx)
    }
  } else {
    injectHook(options, initHookName, function() {
      var record = map[id]
      if (!record.Ctor) {
        record.Ctor = this.constructor
      }
      record.instances.push(this)
    })
    injectHook(options, 'beforeDestroy', function() {
      var instances = map[id].instances
      instances.splice(instances.indexOf(this), 1)
    })
  }
}

/**
 * Inject a hook to a hot reloadable component so that
 * we can keep track of it.
 *
 * @param {Object} options
 * @param {String} name
 * @param {Function} hook
 */

function injectHook(options, name, hook) {
  var existing = options[name]
  options[name] = existing
    ? Array.isArray(existing) ? existing.concat(hook) : [existing, hook]
    : [hook]
}

function tryWrap(fn) {
  return function (id, arg) {
    try {
      fn(id, arg)
    } catch (e) {
      console.error(e)
      console.warn(
        'Something went wrong during Vue component hot-reload. Full reload required.'
      )
    }
  }
}

function updateOptions (oldOptions, newOptions) {
  for (var key in oldOptions) {
    if (!(key in newOptions)) {
      delete oldOptions[key]
    }
  }
  for (var key$1 in newOptions) {
    oldOptions[key$1] = newOptions[key$1]
  }
}

exports.rerender = tryWrap(function (id, options) {
  var record = map[id]
  if (!options) {
    record.instances.slice().forEach(function (instance) {
      instance.$forceUpdate()
    })
    return
  }
  if (typeof options === 'function') {
    options = options.options
  }
  if (record.Ctor) {
    record.Ctor.options.render = options.render
    record.Ctor.options.staticRenderFns = options.staticRenderFns
    record.instances.slice().forEach(function (instance) {
      instance.$options.render = options.render
      instance.$options.staticRenderFns = options.staticRenderFns
      // reset static trees
      // pre 2.5, all static trees are cached together on the instance
      if (instance._staticTrees) {
        instance._staticTrees = []
      }
      // 2.5.0
      if (Array.isArray(record.Ctor.options.cached)) {
        record.Ctor.options.cached = []
      }
      // 2.5.3
      if (Array.isArray(instance.$options.cached)) {
        instance.$options.cached = []
      }

      // post 2.5.4: v-once trees are cached on instance._staticTrees.
      // Pure static trees are cached on the staticRenderFns array
      // (both already reset above)

      // 2.6: temporarily mark rendered scoped slots as unstable so that
      // child components can be forced to update
      var restore = patchScopedSlots(instance)
      instance.$forceUpdate()
      instance.$nextTick(restore)
    })
  } else {
    // functional or no instance created yet
    record.options.render = options.render
    record.options.staticRenderFns = options.staticRenderFns

    // handle functional component re-render
    if (record.options.functional) {
      // rerender with full options
      if (Object.keys(options).length > 2) {
        updateOptions(record.options, options)
      } else {
        // template-only rerender.
        // need to inject the style injection code for CSS modules
        // to work properly.
        var injectStyles = record.options._injectStyles
        if (injectStyles) {
          var render = options.render
          record.options.render = function (h, ctx) {
            injectStyles.call(ctx)
            return render(h, ctx)
          }
        }
      }
      record.options._Ctor = null
      // 2.5.3
      if (Array.isArray(record.options.cached)) {
        record.options.cached = []
      }
      record.instances.slice().forEach(function (instance) {
        instance.$forceUpdate()
      })
    }
  }
})

exports.reload = tryWrap(function (id, options) {
  var record = map[id]
  if (options) {
    if (typeof options === 'function') {
      options = options.options
    }
    makeOptionsHot(id, options)
    if (record.Ctor) {
      if (version[1] < 2) {
        // preserve pre 2.2 behavior for global mixin handling
        record.Ctor.extendOptions = options
      }
      var newCtor = record.Ctor.super.extend(options)
      // prevent record.options._Ctor from being overwritten accidentally
      newCtor.options._Ctor = record.options._Ctor
      record.Ctor.options = newCtor.options
      record.Ctor.cid = newCtor.cid
      record.Ctor.prototype = newCtor.prototype
      if (newCtor.release) {
        // temporary global mixin strategy used in < 2.0.0-alpha.6
        newCtor.release()
      }
    } else {
      updateOptions(record.options, options)
    }
  }
  record.instances.slice().forEach(function (instance) {
    if (instance.$vnode && instance.$vnode.context) {
      instance.$vnode.context.$forceUpdate()
    } else {
      console.warn(
        'Root or manually mounted instance modified. Full reload required.'
      )
    }
  })
})

// 2.6 optimizes template-compiled scoped slots and skips updates if child
// only uses scoped slots. We need to patch the scoped slots resolving helper
// to temporarily mark all scoped slots as unstable in order to force child
// updates.
function patchScopedSlots (instance) {
  if (!instance._u) { return }
  // https://github.com/vuejs/vue/blob/dev/src/core/instance/render-helpers/resolve-scoped-slots.js
  var original = instance._u
  instance._u = function (slots) {
    try {
      // 2.6.4 ~ 2.6.6
      return original(slots, true)
    } catch (e) {
      // 2.5 / >= 2.6.7
      return original(slots, null, true)
    }
  }
  return function () {
    instance._u = original
  }
}

},{}],7:[function(require,module,exports){
(function (global,setImmediate){
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).Vue=e()}(this,(function(){"use strict";var t=Object.freeze({}),e=Array.isArray;function n(t){return null==t}function r(t){return null!=t}function o(t){return!0===t}function i(t){return"string"==typeof t||"number"==typeof t||"symbol"==typeof t||"boolean"==typeof t}function a(t){return"function"==typeof t}function s(t){return null!==t&&"object"==typeof t}var c=Object.prototype.toString;function u(t){return"[object Object]"===c.call(t)}function l(t){var e=parseFloat(String(t));return e>=0&&Math.floor(e)===e&&isFinite(t)}function f(t){return r(t)&&"function"==typeof t.then&&"function"==typeof t.catch}function d(t){return null==t?"":Array.isArray(t)||u(t)&&t.toString===c?JSON.stringify(t,null,2):String(t)}function p(t){var e=parseFloat(t);return isNaN(e)?t:e}function v(t,e){for(var n=Object.create(null),r=t.split(","),o=0;o<r.length;o++)n[r[o]]=!0;return e?function(t){return n[t.toLowerCase()]}:function(t){return n[t]}}var h=v("slot,component",!0),m=v("key,ref,slot,slot-scope,is");function g(t,e){var n=t.length;if(n){if(e===t[n-1])return void(t.length=n-1);var r=t.indexOf(e);if(r>-1)return t.splice(r,1)}}var y=Object.prototype.hasOwnProperty;function _(t,e){return y.call(t,e)}function b(t){var e=Object.create(null);return function(n){return e[n]||(e[n]=t(n))}}var $=/-(\w)/g,w=b((function(t){return t.replace($,(function(t,e){return e?e.toUpperCase():""}))})),x=b((function(t){return t.charAt(0).toUpperCase()+t.slice(1)})),C=/\B([A-Z])/g,k=b((function(t){return t.replace(C,"-$1").toLowerCase()}));var S=Function.prototype.bind?function(t,e){return t.bind(e)}:function(t,e){function n(n){var r=arguments.length;return r?r>1?t.apply(e,arguments):t.call(e,n):t.call(e)}return n._length=t.length,n};function O(t,e){e=e||0;for(var n=t.length-e,r=new Array(n);n--;)r[n]=t[n+e];return r}function T(t,e){for(var n in e)t[n]=e[n];return t}function A(t){for(var e={},n=0;n<t.length;n++)t[n]&&T(e,t[n]);return e}function j(t,e,n){}var E=function(t,e,n){return!1},N=function(t){return t};function P(t,e){if(t===e)return!0;var n=s(t),r=s(e);if(!n||!r)return!n&&!r&&String(t)===String(e);try{var o=Array.isArray(t),i=Array.isArray(e);if(o&&i)return t.length===e.length&&t.every((function(t,n){return P(t,e[n])}));if(t instanceof Date&&e instanceof Date)return t.getTime()===e.getTime();if(o||i)return!1;var a=Object.keys(t),c=Object.keys(e);return a.length===c.length&&a.every((function(n){return P(t[n],e[n])}))}catch(t){return!1}}function D(t,e){for(var n=0;n<t.length;n++)if(P(t[n],e))return n;return-1}function M(t){var e=!1;return function(){e||(e=!0,t.apply(this,arguments))}}function I(t,e){return t===e?0===t&&1/t!=1/e:t==t||e==e}var L="data-server-rendered",R=["component","directive","filter"],F=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],H={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:E,isReservedAttr:E,isUnknownElement:E,getTagNamespace:j,parsePlatformTagName:N,mustUseProp:E,async:!0,_lifecycleHooks:F},B=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function U(t){var e=(t+"").charCodeAt(0);return 36===e||95===e}function z(t,e,n,r){Object.defineProperty(t,e,{value:n,enumerable:!!r,writable:!0,configurable:!0})}var V=new RegExp("[^".concat(B.source,".$_\\d]"));var K="__proto__"in{},J="undefined"!=typeof window,q=J&&window.navigator.userAgent.toLowerCase(),W=q&&/msie|trident/.test(q),Z=q&&q.indexOf("msie 9.0")>0,G=q&&q.indexOf("edge/")>0;q&&q.indexOf("android");var X=q&&/iphone|ipad|ipod|ios/.test(q);q&&/chrome\/\d+/.test(q),q&&/phantomjs/.test(q);var Y,Q=q&&q.match(/firefox\/(\d+)/),tt={}.watch,et=!1;if(J)try{var nt={};Object.defineProperty(nt,"passive",{get:function(){et=!0}}),window.addEventListener("test-passive",null,nt)}catch(t){}var rt=function(){return void 0===Y&&(Y=!J&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),Y},ot=J&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function it(t){return"function"==typeof t&&/native code/.test(t.toString())}var at,st="undefined"!=typeof Symbol&&it(Symbol)&&"undefined"!=typeof Reflect&&it(Reflect.ownKeys);at="undefined"!=typeof Set&&it(Set)?Set:function(){function t(){this.set=Object.create(null)}return t.prototype.has=function(t){return!0===this.set[t]},t.prototype.add=function(t){this.set[t]=!0},t.prototype.clear=function(){this.set=Object.create(null)},t}();var ct=null;function ut(t){void 0===t&&(t=null),t||ct&&ct._scope.off(),ct=t,t&&t._scope.on()}var lt=function(){function t(t,e,n,r,o,i,a,s){this.tag=t,this.data=e,this.children=n,this.text=r,this.elm=o,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=a,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(t.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),t}(),ft=function(t){void 0===t&&(t="");var e=new lt;return e.text=t,e.isComment=!0,e};function dt(t){return new lt(void 0,void 0,void 0,String(t))}function pt(t){var e=new lt(t.tag,t.data,t.children&&t.children.slice(),t.text,t.elm,t.context,t.componentOptions,t.asyncFactory);return e.ns=t.ns,e.isStatic=t.isStatic,e.key=t.key,e.isComment=t.isComment,e.fnContext=t.fnContext,e.fnOptions=t.fnOptions,e.fnScopeId=t.fnScopeId,e.asyncMeta=t.asyncMeta,e.isCloned=!0,e}var vt=0,ht=[],mt=function(){function t(){this._pending=!1,this.id=vt++,this.subs=[]}return t.prototype.addSub=function(t){this.subs.push(t)},t.prototype.removeSub=function(t){this.subs[this.subs.indexOf(t)]=null,this._pending||(this._pending=!0,ht.push(this))},t.prototype.depend=function(e){t.target&&t.target.addDep(this)},t.prototype.notify=function(t){for(var e=this.subs.filter((function(t){return t})),n=0,r=e.length;n<r;n++){e[n].update()}},t}();mt.target=null;var gt=[];function yt(t){gt.push(t),mt.target=t}function _t(){gt.pop(),mt.target=gt[gt.length-1]}var bt=Array.prototype,$t=Object.create(bt);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(t){var e=bt[t];z($t,t,(function(){for(var n=[],r=0;r<arguments.length;r++)n[r]=arguments[r];var o,i=e.apply(this,n),a=this.__ob__;switch(t){case"push":case"unshift":o=n;break;case"splice":o=n.slice(2)}return o&&a.observeArray(o),a.dep.notify(),i}))}));var wt=Object.getOwnPropertyNames($t),xt={},Ct=!0;function kt(t){Ct=t}var St={notify:j,depend:j,addSub:j,removeSub:j},Ot=function(){function t(t,n,r){if(void 0===n&&(n=!1),void 0===r&&(r=!1),this.value=t,this.shallow=n,this.mock=r,this.dep=r?St:new mt,this.vmCount=0,z(t,"__ob__",this),e(t)){if(!r)if(K)t.__proto__=$t;else for(var o=0,i=wt.length;o<i;o++){z(t,s=wt[o],$t[s])}n||this.observeArray(t)}else{var a=Object.keys(t);for(o=0;o<a.length;o++){var s;At(t,s=a[o],xt,void 0,n,r)}}}return t.prototype.observeArray=function(t){for(var e=0,n=t.length;e<n;e++)Tt(t[e],!1,this.mock)},t}();function Tt(t,n,r){return t&&_(t,"__ob__")&&t.__ob__ instanceof Ot?t.__ob__:!Ct||!r&&rt()||!e(t)&&!u(t)||!Object.isExtensible(t)||t.__v_skip||Ft(t)||t instanceof lt?void 0:new Ot(t,n,r)}function At(t,n,r,o,i,a){var s=new mt,c=Object.getOwnPropertyDescriptor(t,n);if(!c||!1!==c.configurable){var u=c&&c.get,l=c&&c.set;u&&!l||r!==xt&&2!==arguments.length||(r=t[n]);var f=!i&&Tt(r,!1,a);return Object.defineProperty(t,n,{enumerable:!0,configurable:!0,get:function(){var n=u?u.call(t):r;return mt.target&&(s.depend(),f&&(f.dep.depend(),e(n)&&Nt(n))),Ft(n)&&!i?n.value:n},set:function(e){var n=u?u.call(t):r;if(I(n,e)){if(l)l.call(t,e);else{if(u)return;if(!i&&Ft(n)&&!Ft(e))return void(n.value=e);r=e}f=!i&&Tt(e,!1,a),s.notify()}}}),s}}function jt(t,n,r){if(!Lt(t)){var o=t.__ob__;return e(t)&&l(n)?(t.length=Math.max(t.length,n),t.splice(n,1,r),o&&!o.shallow&&o.mock&&Tt(r,!1,!0),r):n in t&&!(n in Object.prototype)?(t[n]=r,r):t._isVue||o&&o.vmCount?r:o?(At(o.value,n,r,void 0,o.shallow,o.mock),o.dep.notify(),r):(t[n]=r,r)}}function Et(t,n){if(e(t)&&l(n))t.splice(n,1);else{var r=t.__ob__;t._isVue||r&&r.vmCount||Lt(t)||_(t,n)&&(delete t[n],r&&r.dep.notify())}}function Nt(t){for(var n=void 0,r=0,o=t.length;r<o;r++)(n=t[r])&&n.__ob__&&n.__ob__.dep.depend(),e(n)&&Nt(n)}function Pt(t){return Dt(t,!0),z(t,"__v_isShallow",!0),t}function Dt(t,e){Lt(t)||Tt(t,e,rt())}function Mt(t){return Lt(t)?Mt(t.__v_raw):!(!t||!t.__ob__)}function It(t){return!(!t||!t.__v_isShallow)}function Lt(t){return!(!t||!t.__v_isReadonly)}var Rt="__v_isRef";function Ft(t){return!(!t||!0!==t.__v_isRef)}function Ht(t,e){if(Ft(t))return t;var n={};return z(n,Rt,!0),z(n,"__v_isShallow",e),z(n,"dep",At(n,"value",t,null,e,rt())),n}function Bt(t,e,n){Object.defineProperty(t,n,{enumerable:!0,configurable:!0,get:function(){var t=e[n];if(Ft(t))return t.value;var r=t&&t.__ob__;return r&&r.dep.depend(),t},set:function(t){var r=e[n];Ft(r)&&!Ft(t)?r.value=t:e[n]=t}})}function Ut(t,e,n){var r=t[e];if(Ft(r))return r;var o={get value(){var r=t[e];return void 0===r?n:r},set value(n){t[e]=n}};return z(o,Rt,!0),o}function zt(t){return Vt(t,!1)}function Vt(t,e){if(!u(t))return t;if(Lt(t))return t;var n=e?"__v_rawToShallowReadonly":"__v_rawToReadonly",r=t[n];if(r)return r;var o=Object.create(Object.getPrototypeOf(t));z(t,n,o),z(o,"__v_isReadonly",!0),z(o,"__v_raw",t),Ft(t)&&z(o,Rt,!0),(e||It(t))&&z(o,"__v_isShallow",!0);for(var i=Object.keys(t),a=0;a<i.length;a++)Kt(o,t,i[a],e);return o}function Kt(t,e,n,r){Object.defineProperty(t,n,{enumerable:!0,configurable:!0,get:function(){var t=e[n];return r||!u(t)?t:zt(t)},set:function(){}})}var Jt=b((function(t){var e="&"===t.charAt(0),n="~"===(t=e?t.slice(1):t).charAt(0),r="!"===(t=n?t.slice(1):t).charAt(0);return{name:t=r?t.slice(1):t,once:n,capture:r,passive:e}}));function qt(t,n){function r(){var t=r.fns;if(!e(t))return dn(t,null,arguments,n,"v-on handler");for(var o=t.slice(),i=0;i<o.length;i++)dn(o[i],null,arguments,n,"v-on handler")}return r.fns=t,r}function Wt(t,e,r,i,a,s){var c,u,l,f;for(c in t)u=t[c],l=e[c],f=Jt(c),n(u)||(n(l)?(n(u.fns)&&(u=t[c]=qt(u,s)),o(f.once)&&(u=t[c]=a(f.name,u,f.capture)),r(f.name,u,f.capture,f.passive,f.params)):u!==l&&(l.fns=u,t[c]=l));for(c in e)n(t[c])&&i((f=Jt(c)).name,e[c],f.capture)}function Zt(t,e,i){var a;t instanceof lt&&(t=t.data.hook||(t.data.hook={}));var s=t[e];function c(){i.apply(this,arguments),g(a.fns,c)}n(s)?a=qt([c]):r(s.fns)&&o(s.merged)?(a=s).fns.push(c):a=qt([s,c]),a.merged=!0,t[e]=a}function Gt(t,e,n,o,i){if(r(e)){if(_(e,n))return t[n]=e[n],i||delete e[n],!0;if(_(e,o))return t[n]=e[o],i||delete e[o],!0}return!1}function Xt(t){return i(t)?[dt(t)]:e(t)?Qt(t):void 0}function Yt(t){return r(t)&&r(t.text)&&!1===t.isComment}function Qt(t,a){var s,c,u,l,f=[];for(s=0;s<t.length;s++)n(c=t[s])||"boolean"==typeof c||(l=f[u=f.length-1],e(c)?c.length>0&&(Yt((c=Qt(c,"".concat(a||"","_").concat(s)))[0])&&Yt(l)&&(f[u]=dt(l.text+c[0].text),c.shift()),f.push.apply(f,c)):i(c)?Yt(l)?f[u]=dt(l.text+c):""!==c&&f.push(dt(c)):Yt(c)&&Yt(l)?f[u]=dt(l.text+c.text):(o(t._isVList)&&r(c.tag)&&n(c.key)&&r(a)&&(c.key="__vlist".concat(a,"_").concat(s,"__")),f.push(c)));return f}function te(t,n,c,u,l,f){return(e(c)||i(c))&&(l=u,u=c,c=void 0),o(f)&&(l=2),function(t,n,o,i,c){if(r(o)&&r(o.__ob__))return ft();r(o)&&r(o.is)&&(n=o.is);if(!n)return ft();e(i)&&a(i[0])&&((o=o||{}).scopedSlots={default:i[0]},i.length=0);2===c?i=Xt(i):1===c&&(i=function(t){for(var n=0;n<t.length;n++)if(e(t[n]))return Array.prototype.concat.apply([],t);return t}(i));var u,l;if("string"==typeof n){var f=void 0;l=t.$vnode&&t.$vnode.ns||H.getTagNamespace(n),u=H.isReservedTag(n)?new lt(H.parsePlatformTagName(n),o,i,void 0,void 0,t):o&&o.pre||!r(f=yr(t.$options,"components",n))?new lt(n,o,i,void 0,void 0,t):cr(f,o,t,i,n)}else u=cr(n,o,t,i);return e(u)?u:r(u)?(r(l)&&ee(u,l),r(o)&&function(t){s(t.style)&&Bn(t.style);s(t.class)&&Bn(t.class)}(o),u):ft()}(t,n,c,u,l)}function ee(t,e,i){if(t.ns=e,"foreignObject"===t.tag&&(e=void 0,i=!0),r(t.children))for(var a=0,s=t.children.length;a<s;a++){var c=t.children[a];r(c.tag)&&(n(c.ns)||o(i)&&"svg"!==c.tag)&&ee(c,e,i)}}function ne(t,n){var o,i,a,c,u=null;if(e(t)||"string"==typeof t)for(u=new Array(t.length),o=0,i=t.length;o<i;o++)u[o]=n(t[o],o);else if("number"==typeof t)for(u=new Array(t),o=0;o<t;o++)u[o]=n(o+1,o);else if(s(t))if(st&&t[Symbol.iterator]){u=[];for(var l=t[Symbol.iterator](),f=l.next();!f.done;)u.push(n(f.value,u.length)),f=l.next()}else for(a=Object.keys(t),u=new Array(a.length),o=0,i=a.length;o<i;o++)c=a[o],u[o]=n(t[c],c,o);return r(u)||(u=[]),u._isVList=!0,u}function re(t,e,n,r){var o,i=this.$scopedSlots[t];i?(n=n||{},r&&(n=T(T({},r),n)),o=i(n)||(a(e)?e():e)):o=this.$slots[t]||(a(e)?e():e);var s=n&&n.slot;return s?this.$createElement("template",{slot:s},o):o}function oe(t){return yr(this.$options,"filters",t)||N}function ie(t,n){return e(t)?-1===t.indexOf(n):t!==n}function ae(t,e,n,r,o){var i=H.keyCodes[e]||n;return o&&r&&!H.keyCodes[e]?ie(o,r):i?ie(i,t):r?k(r)!==e:void 0===t}function se(t,n,r,o,i){if(r)if(s(r)){e(r)&&(r=A(r));var a=void 0,c=function(e){if("class"===e||"style"===e||m(e))a=t;else{var s=t.attrs&&t.attrs.type;a=o||H.mustUseProp(n,s,e)?t.domProps||(t.domProps={}):t.attrs||(t.attrs={})}var c=w(e),u=k(e);c in a||u in a||(a[e]=r[e],i&&((t.on||(t.on={}))["update:".concat(e)]=function(t){r[e]=t}))};for(var u in r)c(u)}else;return t}function ce(t,e){var n=this._staticTrees||(this._staticTrees=[]),r=n[t];return r&&!e||le(r=n[t]=this.$options.staticRenderFns[t].call(this._renderProxy,this._c,this),"__static__".concat(t),!1),r}function ue(t,e,n){return le(t,"__once__".concat(e).concat(n?"_".concat(n):""),!0),t}function le(t,n,r){if(e(t))for(var o=0;o<t.length;o++)t[o]&&"string"!=typeof t[o]&&fe(t[o],"".concat(n,"_").concat(o),r);else fe(t,n,r)}function fe(t,e,n){t.isStatic=!0,t.key=e,t.isOnce=n}function de(t,e){if(e)if(u(e)){var n=t.on=t.on?T({},t.on):{};for(var r in e){var o=n[r],i=e[r];n[r]=o?[].concat(o,i):i}}else;return t}function pe(t,n,r,o){n=n||{$stable:!r};for(var i=0;i<t.length;i++){var a=t[i];e(a)?pe(a,n,r):a&&(a.proxy&&(a.fn.proxy=!0),n[a.key]=a.fn)}return o&&(n.$key=o),n}function ve(t,e){for(var n=0;n<e.length;n+=2){var r=e[n];"string"==typeof r&&r&&(t[e[n]]=e[n+1])}return t}function he(t,e){return"string"==typeof t?e+t:t}function me(t){t._o=ue,t._n=p,t._s=d,t._l=ne,t._t=re,t._q=P,t._i=D,t._m=ce,t._f=oe,t._k=ae,t._b=se,t._v=dt,t._e=ft,t._u=pe,t._g=de,t._d=ve,t._p=he}function ge(t,e){if(!t||!t.length)return{};for(var n={},r=0,o=t.length;r<o;r++){var i=t[r],a=i.data;if(a&&a.attrs&&a.attrs.slot&&delete a.attrs.slot,i.context!==e&&i.fnContext!==e||!a||null==a.slot)(n.default||(n.default=[])).push(i);else{var s=a.slot,c=n[s]||(n[s]=[]);"template"===i.tag?c.push.apply(c,i.children||[]):c.push(i)}}for(var u in n)n[u].every(ye)&&delete n[u];return n}function ye(t){return t.isComment&&!t.asyncFactory||" "===t.text}function _e(t){return t.isComment&&t.asyncFactory}function be(e,n,r,o){var i,a=Object.keys(r).length>0,s=n?!!n.$stable:!a,c=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(s&&o&&o!==t&&c===o.$key&&!a&&!o.$hasNormal)return o;for(var u in i={},n)n[u]&&"$"!==u[0]&&(i[u]=$e(e,r,u,n[u]))}else i={};for(var l in r)l in i||(i[l]=we(r,l));return n&&Object.isExtensible(n)&&(n._normalized=i),z(i,"$stable",s),z(i,"$key",c),z(i,"$hasNormal",a),i}function $e(t,n,r,o){var i=function(){var n=ct;ut(t);var r=arguments.length?o.apply(null,arguments):o({}),i=(r=r&&"object"==typeof r&&!e(r)?[r]:Xt(r))&&r[0];return ut(n),r&&(!i||1===r.length&&i.isComment&&!_e(i))?void 0:r};return o.proxy&&Object.defineProperty(n,r,{get:i,enumerable:!0,configurable:!0}),i}function we(t,e){return function(){return t[e]}}function xe(e){return{get attrs(){if(!e._attrsProxy){var n=e._attrsProxy={};z(n,"_v_attr_proxy",!0),Ce(n,e.$attrs,t,e,"$attrs")}return e._attrsProxy},get listeners(){e._listenersProxy||Ce(e._listenersProxy={},e.$listeners,t,e,"$listeners");return e._listenersProxy},get slots(){return function(t){t._slotsProxy||Se(t._slotsProxy={},t.$scopedSlots);return t._slotsProxy}(e)},emit:S(e.$emit,e),expose:function(t){t&&Object.keys(t).forEach((function(n){return Bt(e,t,n)}))}}}function Ce(t,e,n,r,o){var i=!1;for(var a in e)a in t?e[a]!==n[a]&&(i=!0):(i=!0,ke(t,a,r,o));for(var a in t)a in e||(i=!0,delete t[a]);return i}function ke(t,e,n,r){Object.defineProperty(t,e,{enumerable:!0,configurable:!0,get:function(){return n[r][e]}})}function Se(t,e){for(var n in e)t[n]=e[n];for(var n in t)n in e||delete t[n]}function Oe(){var t=ct;return t._setupContext||(t._setupContext=xe(t))}var Te,Ae=null;function je(t,e){return(t.__esModule||st&&"Module"===t[Symbol.toStringTag])&&(t=t.default),s(t)?e.extend(t):t}function Ee(t){if(e(t))for(var n=0;n<t.length;n++){var o=t[n];if(r(o)&&(r(o.componentOptions)||_e(o)))return o}}function Ne(t,e){Te.$on(t,e)}function Pe(t,e){Te.$off(t,e)}function De(t,e){var n=Te;return function r(){var o=e.apply(null,arguments);null!==o&&n.$off(t,r)}}function Me(t,e,n){Te=t,Wt(e,n||{},Ne,Pe,De,t),Te=void 0}var Ie=null;function Le(t){var e=Ie;return Ie=t,function(){Ie=e}}function Re(t){for(;t&&(t=t.$parent);)if(t._inactive)return!0;return!1}function Fe(t,e){if(e){if(t._directInactive=!1,Re(t))return}else if(t._directInactive)return;if(t._inactive||null===t._inactive){t._inactive=!1;for(var n=0;n<t.$children.length;n++)Fe(t.$children[n]);Be(t,"activated")}}function He(t,e){if(!(e&&(t._directInactive=!0,Re(t))||t._inactive)){t._inactive=!0;for(var n=0;n<t.$children.length;n++)He(t.$children[n]);Be(t,"deactivated")}}function Be(t,e,n,r){void 0===r&&(r=!0),yt();var o=ct;r&&ut(t);var i=t.$options[e],a="".concat(e," hook");if(i)for(var s=0,c=i.length;s<c;s++)dn(i[s],t,n||null,t,a);t._hasHookEvent&&t.$emit("hook:"+e),r&&ut(o),_t()}var Ue=[],ze=[],Ve={},Ke=!1,Je=!1,qe=0;var We=0,Ze=Date.now;if(J&&!W){var Ge=window.performance;Ge&&"function"==typeof Ge.now&&Ze()>document.createEvent("Event").timeStamp&&(Ze=function(){return Ge.now()})}var Xe=function(t,e){if(t.post){if(!e.post)return 1}else if(e.post)return-1;return t.id-e.id};function Ye(){var t,e;for(We=Ze(),Je=!0,Ue.sort(Xe),qe=0;qe<Ue.length;qe++)(t=Ue[qe]).before&&t.before(),e=t.id,Ve[e]=null,t.run();var n=ze.slice(),r=Ue.slice();qe=Ue.length=ze.length=0,Ve={},Ke=Je=!1,function(t){for(var e=0;e<t.length;e++)t[e]._inactive=!0,Fe(t[e],!0)}(n),function(t){var e=t.length;for(;e--;){var n=t[e],r=n.vm;r&&r._watcher===n&&r._isMounted&&!r._isDestroyed&&Be(r,"updated")}}(r),function(){for(var t=0;t<ht.length;t++){var e=ht[t];e.subs=e.subs.filter((function(t){return t})),e._pending=!1}ht.length=0}(),ot&&H.devtools&&ot.emit("flush")}function Qe(t){var e=t.id;if(null==Ve[e]&&(t!==mt.target||!t.noRecurse)){if(Ve[e]=!0,Je){for(var n=Ue.length-1;n>qe&&Ue[n].id>t.id;)n--;Ue.splice(n+1,0,t)}else Ue.push(t);Ke||(Ke=!0,Cn(Ye))}}var tn="watcher",en="".concat(tn," callback"),nn="".concat(tn," getter"),rn="".concat(tn," cleanup");function on(t,e){return cn(t,null,{flush:"post"})}var an,sn={};function cn(n,r,o){var i=void 0===o?t:o,s=i.immediate,c=i.deep,u=i.flush,l=void 0===u?"pre":u;i.onTrack,i.onTrigger;var f,d,p=ct,v=function(t,e,n){return void 0===n&&(n=null),dn(t,null,n,p,e)},h=!1,m=!1;if(Ft(n)?(f=function(){return n.value},h=It(n)):Mt(n)?(f=function(){return n.__ob__.dep.depend(),n},c=!0):e(n)?(m=!0,h=n.some((function(t){return Mt(t)||It(t)})),f=function(){return n.map((function(t){return Ft(t)?t.value:Mt(t)?Bn(t):a(t)?v(t,nn):void 0}))}):f=a(n)?r?function(){return v(n,nn)}:function(){if(!p||!p._isDestroyed)return d&&d(),v(n,tn,[y])}:j,r&&c){var g=f;f=function(){return Bn(g())}}var y=function(t){d=_.onStop=function(){v(t,rn)}};if(rt())return y=j,r?s&&v(r,en,[f(),m?[]:void 0,y]):f(),j;var _=new Vn(ct,f,j,{lazy:!0});_.noRecurse=!r;var b=m?[]:sn;return _.run=function(){if(_.active)if(r){var t=_.get();(c||h||(m?t.some((function(t,e){return I(t,b[e])})):I(t,b)))&&(d&&d(),v(r,en,[t,b===sn?void 0:b,y]),b=t)}else _.get()},"sync"===l?_.update=_.run:"post"===l?(_.post=!0,_.update=function(){return Qe(_)}):_.update=function(){if(p&&p===ct&&!p._isMounted){var t=p._preWatchers||(p._preWatchers=[]);t.indexOf(_)<0&&t.push(_)}else Qe(_)},r?s?_.run():b=_.get():"post"===l&&p?p.$once("hook:mounted",(function(){return _.get()})):_.get(),function(){_.teardown()}}var un=function(){function t(t){void 0===t&&(t=!1),this.detached=t,this.active=!0,this.effects=[],this.cleanups=[],this.parent=an,!t&&an&&(this.index=(an.scopes||(an.scopes=[])).push(this)-1)}return t.prototype.run=function(t){if(this.active){var e=an;try{return an=this,t()}finally{an=e}}},t.prototype.on=function(){an=this},t.prototype.off=function(){an=this.parent},t.prototype.stop=function(t){if(this.active){var e=void 0,n=void 0;for(e=0,n=this.effects.length;e<n;e++)this.effects[e].teardown();for(e=0,n=this.cleanups.length;e<n;e++)this.cleanups[e]();if(this.scopes)for(e=0,n=this.scopes.length;e<n;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!t){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},t}();function ln(t){var e=t._provided,n=t.$parent&&t.$parent._provided;return n===e?t._provided=Object.create(n):e}function fn(t,e,n){yt();try{if(e)for(var r=e;r=r.$parent;){var o=r.$options.errorCaptured;if(o)for(var i=0;i<o.length;i++)try{if(!1===o[i].call(r,t,e,n))return}catch(t){pn(t,r,"errorCaptured hook")}}pn(t,e,n)}finally{_t()}}function dn(t,e,n,r,o){var i;try{(i=n?t.apply(e,n):t.call(e))&&!i._isVue&&f(i)&&!i._handled&&(i.catch((function(t){return fn(t,r,o+" (Promise/async)")})),i._handled=!0)}catch(t){fn(t,r,o)}return i}function pn(t,e,n){if(H.errorHandler)try{return H.errorHandler.call(null,t,e,n)}catch(e){e!==t&&vn(e)}vn(t)}function vn(t,e,n){if(!J||"undefined"==typeof console)throw t;console.error(t)}var hn,mn=!1,gn=[],yn=!1;function _n(){yn=!1;var t=gn.slice(0);gn.length=0;for(var e=0;e<t.length;e++)t[e]()}if("undefined"!=typeof Promise&&it(Promise)){var bn=Promise.resolve();hn=function(){bn.then(_n),X&&setTimeout(j)},mn=!0}else if(W||"undefined"==typeof MutationObserver||!it(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())hn="undefined"!=typeof setImmediate&&it(setImmediate)?function(){setImmediate(_n)}:function(){setTimeout(_n,0)};else{var $n=1,wn=new MutationObserver(_n),xn=document.createTextNode(String($n));wn.observe(xn,{characterData:!0}),hn=function(){$n=($n+1)%2,xn.data=String($n)},mn=!0}function Cn(t,e){var n;if(gn.push((function(){if(t)try{t.call(e)}catch(t){fn(t,e,"nextTick")}else n&&n(e)})),yn||(yn=!0,hn()),!t&&"undefined"!=typeof Promise)return new Promise((function(t){n=t}))}function kn(t){return function(e,n){if(void 0===n&&(n=ct),n)return function(t,e,n){var r=t.$options;r[e]=vr(r[e],n)}(n,t,e)}}var Sn=kn("beforeMount"),On=kn("mounted"),Tn=kn("beforeUpdate"),An=kn("updated"),jn=kn("beforeDestroy"),En=kn("destroyed"),Nn=kn("activated"),Pn=kn("deactivated"),Dn=kn("serverPrefetch"),Mn=kn("renderTracked"),In=kn("renderTriggered"),Ln=kn("errorCaptured");var Rn="2.7.14";var Fn=Object.freeze({__proto__:null,version:Rn,defineComponent:function(t){return t},ref:function(t){return Ht(t,!1)},shallowRef:function(t){return Ht(t,!0)},isRef:Ft,toRef:Ut,toRefs:function(t){var n=e(t)?new Array(t.length):{};for(var r in t)n[r]=Ut(t,r);return n},unref:function(t){return Ft(t)?t.value:t},proxyRefs:function(t){if(Mt(t))return t;for(var e={},n=Object.keys(t),r=0;r<n.length;r++)Bt(e,t,n[r]);return e},customRef:function(t){var e=new mt,n=t((function(){e.depend()}),(function(){e.notify()})),r=n.get,o=n.set,i={get value(){return r()},set value(t){o(t)}};return z(i,Rt,!0),i},triggerRef:function(t){t.dep&&t.dep.notify()},reactive:function(t){return Dt(t,!1),t},isReactive:Mt,isReadonly:Lt,isShallow:It,isProxy:function(t){return Mt(t)||Lt(t)},shallowReactive:Pt,markRaw:function(t){return Object.isExtensible(t)&&z(t,"__v_skip",!0),t},toRaw:function t(e){var n=e&&e.__v_raw;return n?t(n):e},readonly:zt,shallowReadonly:function(t){return Vt(t,!0)},computed:function(t,e){var n,r,o=a(t);o?(n=t,r=j):(n=t.get,r=t.set);var i=rt()?null:new Vn(ct,n,j,{lazy:!0}),s={effect:i,get value(){return i?(i.dirty&&i.evaluate(),mt.target&&i.depend(),i.value):n()},set value(t){r(t)}};return z(s,Rt,!0),z(s,"__v_isReadonly",o),s},watch:function(t,e,n){return cn(t,e,n)},watchEffect:function(t,e){return cn(t,null,e)},watchPostEffect:on,watchSyncEffect:function(t,e){return cn(t,null,{flush:"sync"})},EffectScope:un,effectScope:function(t){return new un(t)},onScopeDispose:function(t){an&&an.cleanups.push(t)},getCurrentScope:function(){return an},provide:function(t,e){ct&&(ln(ct)[t]=e)},inject:function(t,e,n){void 0===n&&(n=!1);var r=ct;if(r){var o=r.$parent&&r.$parent._provided;if(o&&t in o)return o[t];if(arguments.length>1)return n&&a(e)?e.call(r):e}},h:function(t,e,n){return te(ct,t,e,n,2,!0)},getCurrentInstance:function(){return ct&&{proxy:ct}},useSlots:function(){return Oe().slots},useAttrs:function(){return Oe().attrs},useListeners:function(){return Oe().listeners},mergeDefaults:function(t,n){var r=e(t)?t.reduce((function(t,e){return t[e]={},t}),{}):t;for(var o in n){var i=r[o];i?e(i)||a(i)?r[o]={type:i,default:n[o]}:i.default=n[o]:null===i&&(r[o]={default:n[o]})}return r},nextTick:Cn,set:jt,del:Et,useCssModule:function(e){return t},useCssVars:function(t){if(J){var e=ct;e&&on((function(){var n=e.$el,r=t(e,e._setupProxy);if(n&&1===n.nodeType){var o=n.style;for(var i in r)o.setProperty("--".concat(i),r[i])}}))}},defineAsyncComponent:function(t){a(t)&&(t={loader:t});var e=t.loader,n=t.loadingComponent,r=t.errorComponent,o=t.delay,i=void 0===o?200:o,s=t.timeout;t.suspensible;var c=t.onError,u=null,l=0,f=function(){var t;return u||(t=u=e().catch((function(t){if(t=t instanceof Error?t:new Error(String(t)),c)return new Promise((function(e,n){c(t,(function(){return e((l++,u=null,f()))}),(function(){return n(t)}),l+1)}));throw t})).then((function(e){return t!==u&&u?u:(e&&(e.__esModule||"Module"===e[Symbol.toStringTag])&&(e=e.default),e)})))};return function(){return{component:f(),delay:i,timeout:s,error:r,loading:n}}},onBeforeMount:Sn,onMounted:On,onBeforeUpdate:Tn,onUpdated:An,onBeforeUnmount:jn,onUnmounted:En,onActivated:Nn,onDeactivated:Pn,onServerPrefetch:Dn,onRenderTracked:Mn,onRenderTriggered:In,onErrorCaptured:function(t,e){void 0===e&&(e=ct),Ln(t,e)}}),Hn=new at;function Bn(t){return Un(t,Hn),Hn.clear(),t}function Un(t,n){var r,o,i=e(t);if(!(!i&&!s(t)||t.__v_skip||Object.isFrozen(t)||t instanceof lt)){if(t.__ob__){var a=t.__ob__.dep.id;if(n.has(a))return;n.add(a)}if(i)for(r=t.length;r--;)Un(t[r],n);else if(Ft(t))Un(t.value,n);else for(r=(o=Object.keys(t)).length;r--;)Un(t[o[r]],n)}}var zn=0,Vn=function(){function t(t,e,n,r,o){!function(t,e){void 0===e&&(e=an),e&&e.active&&e.effects.push(t)}(this,an&&!an._vm?an:t?t._scope:void 0),(this.vm=t)&&o&&(t._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++zn,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new at,this.newDepIds=new at,this.expression="",a(e)?this.getter=e:(this.getter=function(t){if(!V.test(t)){var e=t.split(".");return function(t){for(var n=0;n<e.length;n++){if(!t)return;t=t[e[n]]}return t}}}(e),this.getter||(this.getter=j)),this.value=this.lazy?void 0:this.get()}return t.prototype.get=function(){var t;yt(this);var e=this.vm;try{t=this.getter.call(e,e)}catch(t){if(!this.user)throw t;fn(t,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Bn(t),_t(),this.cleanupDeps()}return t},t.prototype.addDep=function(t){var e=t.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(t),this.depIds.has(e)||t.addSub(this))},t.prototype.cleanupDeps=function(){for(var t=this.deps.length;t--;){var e=this.deps[t];this.newDepIds.has(e.id)||e.removeSub(this)}var n=this.depIds;this.depIds=this.newDepIds,this.newDepIds=n,this.newDepIds.clear(),n=this.deps,this.deps=this.newDeps,this.newDeps=n,this.newDeps.length=0},t.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():Qe(this)},t.prototype.run=function(){if(this.active){var t=this.get();if(t!==this.value||s(t)||this.deep){var e=this.value;if(this.value=t,this.user){var n='callback for watcher "'.concat(this.expression,'"');dn(this.cb,this.vm,[t,e],this.vm,n)}else this.cb.call(this.vm,t,e)}}},t.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},t.prototype.depend=function(){for(var t=this.deps.length;t--;)this.deps[t].depend()},t.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&g(this.vm._scope.effects,this),this.active){for(var t=this.deps.length;t--;)this.deps[t].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},t}(),Kn={enumerable:!0,configurable:!0,get:j,set:j};function Jn(t,e,n){Kn.get=function(){return this[e][n]},Kn.set=function(t){this[e][n]=t},Object.defineProperty(t,n,Kn)}function qn(t){var n=t.$options;if(n.props&&function(t,e){var n=t.$options.propsData||{},r=t._props=Pt({}),o=t.$options._propKeys=[];t.$parent&&kt(!1);var i=function(i){o.push(i);var a=_r(i,e,n,t);At(r,i,a),i in t||Jn(t,"_props",i)};for(var a in e)i(a);kt(!0)}(t,n.props),function(t){var e=t.$options,n=e.setup;if(n){var r=t._setupContext=xe(t);ut(t),yt();var o=dn(n,null,[t._props||Pt({}),r],t,"setup");if(_t(),ut(),a(o))e.render=o;else if(s(o))if(t._setupState=o,o.__sfc){var i=t._setupProxy={};for(var c in o)"__sfc"!==c&&Bt(i,o,c)}else for(var c in o)U(c)||Bt(t,o,c)}}(t),n.methods&&function(t,e){for(var n in t.$options.props,e)t[n]="function"!=typeof e[n]?j:S(e[n],t)}(t,n.methods),n.data)!function(t){var e=t.$options.data;u(e=t._data=a(e)?function(t,e){yt();try{return t.call(e,e)}catch(t){return fn(t,e,"data()"),{}}finally{_t()}}(e,t):e||{})||(e={});var n=Object.keys(e),r=t.$options.props;t.$options.methods;var o=n.length;for(;o--;){var i=n[o];r&&_(r,i)||U(i)||Jn(t,"_data",i)}var s=Tt(e);s&&s.vmCount++}(t);else{var r=Tt(t._data={});r&&r.vmCount++}n.computed&&function(t,e){var n=t._computedWatchers=Object.create(null),r=rt();for(var o in e){var i=e[o],s=a(i)?i:i.get;r||(n[o]=new Vn(t,s||j,j,Wn)),o in t||Zn(t,o,i)}}(t,n.computed),n.watch&&n.watch!==tt&&function(t,n){for(var r in n){var o=n[r];if(e(o))for(var i=0;i<o.length;i++)Yn(t,r,o[i]);else Yn(t,r,o)}}(t,n.watch)}var Wn={lazy:!0};function Zn(t,e,n){var r=!rt();a(n)?(Kn.get=r?Gn(e):Xn(n),Kn.set=j):(Kn.get=n.get?r&&!1!==n.cache?Gn(e):Xn(n.get):j,Kn.set=n.set||j),Object.defineProperty(t,e,Kn)}function Gn(t){return function(){var e=this._computedWatchers&&this._computedWatchers[t];if(e)return e.dirty&&e.evaluate(),mt.target&&e.depend(),e.value}}function Xn(t){return function(){return t.call(this,this)}}function Yn(t,e,n,r){return u(n)&&(r=n,n=n.handler),"string"==typeof n&&(n=t[n]),t.$watch(e,n,r)}function Qn(t,e){if(t){for(var n=Object.create(null),r=st?Reflect.ownKeys(t):Object.keys(t),o=0;o<r.length;o++){var i=r[o];if("__ob__"!==i){var s=t[i].from;if(s in e._provided)n[i]=e._provided[s];else if("default"in t[i]){var c=t[i].default;n[i]=a(c)?c.call(e):c}}}return n}}var tr=0;function er(t){var e=t.options;if(t.super){var n=er(t.super);if(n!==t.superOptions){t.superOptions=n;var r=function(t){var e,n=t.options,r=t.sealedOptions;for(var o in n)n[o]!==r[o]&&(e||(e={}),e[o]=n[o]);return e}(t);r&&T(t.extendOptions,r),(e=t.options=gr(n,t.extendOptions)).name&&(e.components[e.name]=t)}}return e}function nr(n,r,i,a,s){var c,u=this,l=s.options;_(a,"_uid")?(c=Object.create(a))._original=a:(c=a,a=a._original);var f=o(l._compiled),d=!f;this.data=n,this.props=r,this.children=i,this.parent=a,this.listeners=n.on||t,this.injections=Qn(l.inject,a),this.slots=function(){return u.$slots||be(a,n.scopedSlots,u.$slots=ge(i,a)),u.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return be(a,n.scopedSlots,this.slots())}}),f&&(this.$options=l,this.$slots=this.slots(),this.$scopedSlots=be(a,n.scopedSlots,this.$slots)),l._scopeId?this._c=function(t,n,r,o){var i=te(c,t,n,r,o,d);return i&&!e(i)&&(i.fnScopeId=l._scopeId,i.fnContext=a),i}:this._c=function(t,e,n,r){return te(c,t,e,n,r,d)}}function rr(t,e,n,r,o){var i=pt(t);return i.fnContext=n,i.fnOptions=r,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function or(t,e){for(var n in e)t[w(n)]=e[n]}function ir(t){return t.name||t.__name||t._componentTag}me(nr.prototype);var ar={init:function(t,e){if(t.componentInstance&&!t.componentInstance._isDestroyed&&t.data.keepAlive){var n=t;ar.prepatch(n,n)}else{(t.componentInstance=function(t,e){var n={_isComponent:!0,_parentVnode:t,parent:e},o=t.data.inlineTemplate;r(o)&&(n.render=o.render,n.staticRenderFns=o.staticRenderFns);return new t.componentOptions.Ctor(n)}(t,Ie)).$mount(e?t.elm:void 0,e)}},prepatch:function(e,n){var r=n.componentOptions;!function(e,n,r,o,i){var a=o.data.scopedSlots,s=e.$scopedSlots,c=!!(a&&!a.$stable||s!==t&&!s.$stable||a&&e.$scopedSlots.$key!==a.$key||!a&&e.$scopedSlots.$key),u=!!(i||e.$options._renderChildren||c),l=e.$vnode;e.$options._parentVnode=o,e.$vnode=o,e._vnode&&(e._vnode.parent=o),e.$options._renderChildren=i;var f=o.data.attrs||t;e._attrsProxy&&Ce(e._attrsProxy,f,l.data&&l.data.attrs||t,e,"$attrs")&&(u=!0),e.$attrs=f,r=r||t;var d=e.$options._parentListeners;if(e._listenersProxy&&Ce(e._listenersProxy,r,d||t,e,"$listeners"),e.$listeners=e.$options._parentListeners=r,Me(e,r,d),n&&e.$options.props){kt(!1);for(var p=e._props,v=e.$options._propKeys||[],h=0;h<v.length;h++){var m=v[h],g=e.$options.props;p[m]=_r(m,g,n,e)}kt(!0),e.$options.propsData=n}u&&(e.$slots=ge(i,o.context),e.$forceUpdate())}(n.componentInstance=e.componentInstance,r.propsData,r.listeners,n,r.children)},insert:function(t){var e,n=t.context,r=t.componentInstance;r._isMounted||(r._isMounted=!0,Be(r,"mounted")),t.data.keepAlive&&(n._isMounted?((e=r)._inactive=!1,ze.push(e)):Fe(r,!0))},destroy:function(t){var e=t.componentInstance;e._isDestroyed||(t.data.keepAlive?He(e,!0):e.$destroy())}},sr=Object.keys(ar);function cr(i,a,c,u,l){if(!n(i)){var d=c.$options._base;if(s(i)&&(i=d.extend(i)),"function"==typeof i){var p;if(n(i.cid)&&(i=function(t,e){if(o(t.error)&&r(t.errorComp))return t.errorComp;if(r(t.resolved))return t.resolved;var i=Ae;if(i&&r(t.owners)&&-1===t.owners.indexOf(i)&&t.owners.push(i),o(t.loading)&&r(t.loadingComp))return t.loadingComp;if(i&&!r(t.owners)){var a=t.owners=[i],c=!0,u=null,l=null;i.$on("hook:destroyed",(function(){return g(a,i)}));var d=function(t){for(var e=0,n=a.length;e<n;e++)a[e].$forceUpdate();t&&(a.length=0,null!==u&&(clearTimeout(u),u=null),null!==l&&(clearTimeout(l),l=null))},p=M((function(n){t.resolved=je(n,e),c?a.length=0:d(!0)})),v=M((function(e){r(t.errorComp)&&(t.error=!0,d(!0))})),h=t(p,v);return s(h)&&(f(h)?n(t.resolved)&&h.then(p,v):f(h.component)&&(h.component.then(p,v),r(h.error)&&(t.errorComp=je(h.error,e)),r(h.loading)&&(t.loadingComp=je(h.loading,e),0===h.delay?t.loading=!0:u=setTimeout((function(){u=null,n(t.resolved)&&n(t.error)&&(t.loading=!0,d(!1))}),h.delay||200)),r(h.timeout)&&(l=setTimeout((function(){l=null,n(t.resolved)&&v(null)}),h.timeout)))),c=!1,t.loading?t.loadingComp:t.resolved}}(p=i,d),void 0===i))return function(t,e,n,r,o){var i=ft();return i.asyncFactory=t,i.asyncMeta={data:e,context:n,children:r,tag:o},i}(p,a,c,u,l);a=a||{},er(i),r(a.model)&&function(t,n){var o=t.model&&t.model.prop||"value",i=t.model&&t.model.event||"input";(n.attrs||(n.attrs={}))[o]=n.model.value;var a=n.on||(n.on={}),s=a[i],c=n.model.callback;r(s)?(e(s)?-1===s.indexOf(c):s!==c)&&(a[i]=[c].concat(s)):a[i]=c}(i.options,a);var v=function(t,e,o){var i=e.options.props;if(!n(i)){var a={},s=t.attrs,c=t.props;if(r(s)||r(c))for(var u in i){var l=k(u);Gt(a,c,u,l,!0)||Gt(a,s,u,l,!1)}return a}}(a,i);if(o(i.options.functional))return function(n,o,i,a,s){var c=n.options,u={},l=c.props;if(r(l))for(var f in l)u[f]=_r(f,l,o||t);else r(i.attrs)&&or(u,i.attrs),r(i.props)&&or(u,i.props);var d=new nr(i,u,s,a,n),p=c.render.call(null,d._c,d);if(p instanceof lt)return rr(p,i,d.parent,c);if(e(p)){for(var v=Xt(p)||[],h=new Array(v.length),m=0;m<v.length;m++)h[m]=rr(v[m],i,d.parent,c);return h}}(i,v,a,c,u);var h=a.on;if(a.on=a.nativeOn,o(i.options.abstract)){var m=a.slot;a={},m&&(a.slot=m)}!function(t){for(var e=t.hook||(t.hook={}),n=0;n<sr.length;n++){var r=sr[n],o=e[r],i=ar[r];o===i||o&&o._merged||(e[r]=o?ur(i,o):i)}}(a);var y=ir(i.options)||l;return new lt("vue-component-".concat(i.cid).concat(y?"-".concat(y):""),a,void 0,void 0,void 0,c,{Ctor:i,propsData:v,listeners:h,tag:l,children:u},p)}}}function ur(t,e){var n=function(n,r){t(n,r),e(n,r)};return n._merged=!0,n}var lr=j,fr=H.optionMergeStrategies;function dr(t,e,n){if(void 0===n&&(n=!0),!e)return t;for(var r,o,i,a=st?Reflect.ownKeys(e):Object.keys(e),s=0;s<a.length;s++)"__ob__"!==(r=a[s])&&(o=t[r],i=e[r],n&&_(t,r)?o!==i&&u(o)&&u(i)&&dr(o,i):jt(t,r,i));return t}function pr(t,e,n){return n?function(){var r=a(e)?e.call(n,n):e,o=a(t)?t.call(n,n):t;return r?dr(r,o):o}:e?t?function(){return dr(a(e)?e.call(this,this):e,a(t)?t.call(this,this):t)}:e:t}function vr(t,n){var r=n?t?t.concat(n):e(n)?n:[n]:t;return r?function(t){for(var e=[],n=0;n<t.length;n++)-1===e.indexOf(t[n])&&e.push(t[n]);return e}(r):r}function hr(t,e,n,r){var o=Object.create(t||null);return e?T(o,e):o}fr.data=function(t,e,n){return n?pr(t,e,n):e&&"function"!=typeof e?t:pr(t,e)},F.forEach((function(t){fr[t]=vr})),R.forEach((function(t){fr[t+"s"]=hr})),fr.watch=function(t,n,r,o){if(t===tt&&(t=void 0),n===tt&&(n=void 0),!n)return Object.create(t||null);if(!t)return n;var i={};for(var a in T(i,t),n){var s=i[a],c=n[a];s&&!e(s)&&(s=[s]),i[a]=s?s.concat(c):e(c)?c:[c]}return i},fr.props=fr.methods=fr.inject=fr.computed=function(t,e,n,r){if(!t)return e;var o=Object.create(null);return T(o,t),e&&T(o,e),o},fr.provide=function(t,e){return t?function(){var n=Object.create(null);return dr(n,a(t)?t.call(this):t),e&&dr(n,a(e)?e.call(this):e,!1),n}:e};var mr=function(t,e){return void 0===e?t:e};function gr(t,n,r){if(a(n)&&(n=n.options),function(t,n){var r=t.props;if(r){var o,i,a={};if(e(r))for(o=r.length;o--;)"string"==typeof(i=r[o])&&(a[w(i)]={type:null});else if(u(r))for(var s in r)i=r[s],a[w(s)]=u(i)?i:{type:i};t.props=a}}(n),function(t,n){var r=t.inject;if(r){var o=t.inject={};if(e(r))for(var i=0;i<r.length;i++)o[r[i]]={from:r[i]};else if(u(r))for(var a in r){var s=r[a];o[a]=u(s)?T({from:a},s):{from:s}}}}(n),function(t){var e=t.directives;if(e)for(var n in e){var r=e[n];a(r)&&(e[n]={bind:r,update:r})}}(n),!n._base&&(n.extends&&(t=gr(t,n.extends,r)),n.mixins))for(var o=0,i=n.mixins.length;o<i;o++)t=gr(t,n.mixins[o],r);var s,c={};for(s in t)l(s);for(s in n)_(t,s)||l(s);function l(e){var o=fr[e]||mr;c[e]=o(t[e],n[e],r,e)}return c}function yr(t,e,n,r){if("string"==typeof n){var o=t[e];if(_(o,n))return o[n];var i=w(n);if(_(o,i))return o[i];var a=x(i);return _(o,a)?o[a]:o[n]||o[i]||o[a]}}function _r(t,e,n,r){var o=e[t],i=!_(n,t),s=n[t],c=xr(Boolean,o.type);if(c>-1)if(i&&!_(o,"default"))s=!1;else if(""===s||s===k(t)){var u=xr(String,o.type);(u<0||c<u)&&(s=!0)}if(void 0===s){s=function(t,e,n){if(!_(e,"default"))return;var r=e.default;if(t&&t.$options.propsData&&void 0===t.$options.propsData[n]&&void 0!==t._props[n])return t._props[n];return a(r)&&"Function"!==$r(e.type)?r.call(t):r}(r,o,t);var l=Ct;kt(!0),Tt(s),kt(l)}return s}var br=/^\s*function (\w+)/;function $r(t){var e=t&&t.toString().match(br);return e?e[1]:""}function wr(t,e){return $r(t)===$r(e)}function xr(t,n){if(!e(n))return wr(n,t)?0:-1;for(var r=0,o=n.length;r<o;r++)if(wr(n[r],t))return r;return-1}function Cr(t){this._init(t)}function kr(t){t.cid=0;var e=1;t.extend=function(t){t=t||{};var n=this,r=n.cid,o=t._Ctor||(t._Ctor={});if(o[r])return o[r];var i=ir(t)||ir(n.options),a=function(t){this._init(t)};return(a.prototype=Object.create(n.prototype)).constructor=a,a.cid=e++,a.options=gr(n.options,t),a.super=n,a.options.props&&function(t){var e=t.options.props;for(var n in e)Jn(t.prototype,"_props",n)}(a),a.options.computed&&function(t){var e=t.options.computed;for(var n in e)Zn(t.prototype,n,e[n])}(a),a.extend=n.extend,a.mixin=n.mixin,a.use=n.use,R.forEach((function(t){a[t]=n[t]})),i&&(a.options.components[i]=a),a.superOptions=n.options,a.extendOptions=t,a.sealedOptions=T({},a.options),o[r]=a,a}}function Sr(t){return t&&(ir(t.Ctor.options)||t.tag)}function Or(t,n){return e(t)?t.indexOf(n)>-1:"string"==typeof t?t.split(",").indexOf(n)>-1:(r=t,"[object RegExp]"===c.call(r)&&t.test(n));var r}function Tr(t,e){var n=t.cache,r=t.keys,o=t._vnode;for(var i in n){var a=n[i];if(a){var s=a.name;s&&!e(s)&&Ar(n,i,r,o)}}}function Ar(t,e,n,r){var o=t[e];!o||r&&o.tag===r.tag||o.componentInstance.$destroy(),t[e]=null,g(n,e)}!function(e){e.prototype._init=function(e){var n=this;n._uid=tr++,n._isVue=!0,n.__v_skip=!0,n._scope=new un(!0),n._scope._vm=!0,e&&e._isComponent?function(t,e){var n=t.$options=Object.create(t.constructor.options),r=e._parentVnode;n.parent=e.parent,n._parentVnode=r;var o=r.componentOptions;n.propsData=o.propsData,n._parentListeners=o.listeners,n._renderChildren=o.children,n._componentTag=o.tag,e.render&&(n.render=e.render,n.staticRenderFns=e.staticRenderFns)}(n,e):n.$options=gr(er(n.constructor),e||{},n),n._renderProxy=n,n._self=n,function(t){var e=t.$options,n=e.parent;if(n&&!e.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(t)}t.$parent=n,t.$root=n?n.$root:t,t.$children=[],t.$refs={},t._provided=n?n._provided:Object.create(null),t._watcher=null,t._inactive=null,t._directInactive=!1,t._isMounted=!1,t._isDestroyed=!1,t._isBeingDestroyed=!1}(n),function(t){t._events=Object.create(null),t._hasHookEvent=!1;var e=t.$options._parentListeners;e&&Me(t,e)}(n),function(e){e._vnode=null,e._staticTrees=null;var n=e.$options,r=e.$vnode=n._parentVnode,o=r&&r.context;e.$slots=ge(n._renderChildren,o),e.$scopedSlots=r?be(e.$parent,r.data.scopedSlots,e.$slots):t,e._c=function(t,n,r,o){return te(e,t,n,r,o,!1)},e.$createElement=function(t,n,r,o){return te(e,t,n,r,o,!0)};var i=r&&r.data;At(e,"$attrs",i&&i.attrs||t,null,!0),At(e,"$listeners",n._parentListeners||t,null,!0)}(n),Be(n,"beforeCreate",void 0,!1),function(t){var e=Qn(t.$options.inject,t);e&&(kt(!1),Object.keys(e).forEach((function(n){At(t,n,e[n])})),kt(!0))}(n),qn(n),function(t){var e=t.$options.provide;if(e){var n=a(e)?e.call(t):e;if(!s(n))return;for(var r=ln(t),o=st?Reflect.ownKeys(n):Object.keys(n),i=0;i<o.length;i++){var c=o[i];Object.defineProperty(r,c,Object.getOwnPropertyDescriptor(n,c))}}}(n),Be(n,"created"),n.$options.el&&n.$mount(n.$options.el)}}(Cr),function(t){var e={get:function(){return this._data}},n={get:function(){return this._props}};Object.defineProperty(t.prototype,"$data",e),Object.defineProperty(t.prototype,"$props",n),t.prototype.$set=jt,t.prototype.$delete=Et,t.prototype.$watch=function(t,e,n){var r=this;if(u(e))return Yn(r,t,e,n);(n=n||{}).user=!0;var o=new Vn(r,t,e,n);if(n.immediate){var i='callback for immediate watcher "'.concat(o.expression,'"');yt(),dn(e,r,[o.value],r,i),_t()}return function(){o.teardown()}}}(Cr),function(t){var n=/^hook:/;t.prototype.$on=function(t,r){var o=this;if(e(t))for(var i=0,a=t.length;i<a;i++)o.$on(t[i],r);else(o._events[t]||(o._events[t]=[])).push(r),n.test(t)&&(o._hasHookEvent=!0);return o},t.prototype.$once=function(t,e){var n=this;function r(){n.$off(t,r),e.apply(n,arguments)}return r.fn=e,n.$on(t,r),n},t.prototype.$off=function(t,n){var r=this;if(!arguments.length)return r._events=Object.create(null),r;if(e(t)){for(var o=0,i=t.length;o<i;o++)r.$off(t[o],n);return r}var a,s=r._events[t];if(!s)return r;if(!n)return r._events[t]=null,r;for(var c=s.length;c--;)if((a=s[c])===n||a.fn===n){s.splice(c,1);break}return r},t.prototype.$emit=function(t){var e=this,n=e._events[t];if(n){n=n.length>1?O(n):n;for(var r=O(arguments,1),o='event handler for "'.concat(t,'"'),i=0,a=n.length;i<a;i++)dn(n[i],e,r,e,o)}return e}}(Cr),function(t){t.prototype._update=function(t,e){var n=this,r=n.$el,o=n._vnode,i=Le(n);n._vnode=t,n.$el=o?n.__patch__(o,t):n.__patch__(n.$el,t,e,!1),i(),r&&(r.__vue__=null),n.$el&&(n.$el.__vue__=n);for(var a=n;a&&a.$vnode&&a.$parent&&a.$vnode===a.$parent._vnode;)a.$parent.$el=a.$el,a=a.$parent},t.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},t.prototype.$destroy=function(){var t=this;if(!t._isBeingDestroyed){Be(t,"beforeDestroy"),t._isBeingDestroyed=!0;var e=t.$parent;!e||e._isBeingDestroyed||t.$options.abstract||g(e.$children,t),t._scope.stop(),t._data.__ob__&&t._data.__ob__.vmCount--,t._isDestroyed=!0,t.__patch__(t._vnode,null),Be(t,"destroyed"),t.$off(),t.$el&&(t.$el.__vue__=null),t.$vnode&&(t.$vnode.parent=null)}}}(Cr),function(t){me(t.prototype),t.prototype.$nextTick=function(t){return Cn(t,this)},t.prototype._render=function(){var t,n=this,r=n.$options,o=r.render,i=r._parentVnode;i&&n._isMounted&&(n.$scopedSlots=be(n.$parent,i.data.scopedSlots,n.$slots,n.$scopedSlots),n._slotsProxy&&Se(n._slotsProxy,n.$scopedSlots)),n.$vnode=i;try{ut(n),Ae=n,t=o.call(n._renderProxy,n.$createElement)}catch(e){fn(e,n,"render"),t=n._vnode}finally{Ae=null,ut()}return e(t)&&1===t.length&&(t=t[0]),t instanceof lt||(t=ft()),t.parent=i,t}}(Cr);var jr=[String,RegExp,Array],Er={name:"keep-alive",abstract:!0,props:{include:jr,exclude:jr,max:[String,Number]},methods:{cacheVNode:function(){var t=this,e=t.cache,n=t.keys,r=t.vnodeToCache,o=t.keyToCache;if(r){var i=r.tag,a=r.componentInstance,s=r.componentOptions;e[o]={name:Sr(s),tag:i,componentInstance:a},n.push(o),this.max&&n.length>parseInt(this.max)&&Ar(e,n[0],n,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var t in this.cache)Ar(this.cache,t,this.keys)},mounted:function(){var t=this;this.cacheVNode(),this.$watch("include",(function(e){Tr(t,(function(t){return Or(e,t)}))})),this.$watch("exclude",(function(e){Tr(t,(function(t){return!Or(e,t)}))}))},updated:function(){this.cacheVNode()},render:function(){var t=this.$slots.default,e=Ee(t),n=e&&e.componentOptions;if(n){var r=Sr(n),o=this.include,i=this.exclude;if(o&&(!r||!Or(o,r))||i&&r&&Or(i,r))return e;var a=this.cache,s=this.keys,c=null==e.key?n.Ctor.cid+(n.tag?"::".concat(n.tag):""):e.key;a[c]?(e.componentInstance=a[c].componentInstance,g(s,c),s.push(c)):(this.vnodeToCache=e,this.keyToCache=c),e.data.keepAlive=!0}return e||t&&t[0]}},Nr={KeepAlive:Er};!function(t){var e={get:function(){return H}};Object.defineProperty(t,"config",e),t.util={warn:lr,extend:T,mergeOptions:gr,defineReactive:At},t.set=jt,t.delete=Et,t.nextTick=Cn,t.observable=function(t){return Tt(t),t},t.options=Object.create(null),R.forEach((function(e){t.options[e+"s"]=Object.create(null)})),t.options._base=t,T(t.options.components,Nr),function(t){t.use=function(t){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(t)>-1)return this;var n=O(arguments,1);return n.unshift(this),a(t.install)?t.install.apply(t,n):a(t)&&t.apply(null,n),e.push(t),this}}(t),function(t){t.mixin=function(t){return this.options=gr(this.options,t),this}}(t),kr(t),function(t){R.forEach((function(e){t[e]=function(t,n){return n?("component"===e&&u(n)&&(n.name=n.name||t,n=this.options._base.extend(n)),"directive"===e&&a(n)&&(n={bind:n,update:n}),this.options[e+"s"][t]=n,n):this.options[e+"s"][t]}}))}(t)}(Cr),Object.defineProperty(Cr.prototype,"$isServer",{get:rt}),Object.defineProperty(Cr.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Cr,"FunctionalRenderContext",{value:nr}),Cr.version=Rn;var Pr=v("style,class"),Dr=v("input,textarea,option,select,progress"),Mr=function(t,e,n){return"value"===n&&Dr(t)&&"button"!==e||"selected"===n&&"option"===t||"checked"===n&&"input"===t||"muted"===n&&"video"===t},Ir=v("contenteditable,draggable,spellcheck"),Lr=v("events,caret,typing,plaintext-only"),Rr=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Fr="http://www.w3.org/1999/xlink",Hr=function(t){return":"===t.charAt(5)&&"xlink"===t.slice(0,5)},Br=function(t){return Hr(t)?t.slice(6,t.length):""},Ur=function(t){return null==t||!1===t};function zr(t){for(var e=t.data,n=t,o=t;r(o.componentInstance);)(o=o.componentInstance._vnode)&&o.data&&(e=Vr(o.data,e));for(;r(n=n.parent);)n&&n.data&&(e=Vr(e,n.data));return function(t,e){if(r(t)||r(e))return Kr(t,Jr(e));return""}(e.staticClass,e.class)}function Vr(t,e){return{staticClass:Kr(t.staticClass,e.staticClass),class:r(t.class)?[t.class,e.class]:e.class}}function Kr(t,e){return t?e?t+" "+e:t:e||""}function Jr(t){return Array.isArray(t)?function(t){for(var e,n="",o=0,i=t.length;o<i;o++)r(e=Jr(t[o]))&&""!==e&&(n&&(n+=" "),n+=e);return n}(t):s(t)?function(t){var e="";for(var n in t)t[n]&&(e&&(e+=" "),e+=n);return e}(t):"string"==typeof t?t:""}var qr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Wr=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Zr=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Gr=function(t){return Wr(t)||Zr(t)};function Xr(t){return Zr(t)?"svg":"math"===t?"math":void 0}var Yr=Object.create(null);var Qr=v("text,number,password,search,email,tel,url");function to(t){if("string"==typeof t){var e=document.querySelector(t);return e||document.createElement("div")}return t}var eo=Object.freeze({__proto__:null,createElement:function(t,e){var n=document.createElement(t);return"select"!==t||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n},createElementNS:function(t,e){return document.createElementNS(qr[t],e)},createTextNode:function(t){return document.createTextNode(t)},createComment:function(t){return document.createComment(t)},insertBefore:function(t,e,n){t.insertBefore(e,n)},removeChild:function(t,e){t.removeChild(e)},appendChild:function(t,e){t.appendChild(e)},parentNode:function(t){return t.parentNode},nextSibling:function(t){return t.nextSibling},tagName:function(t){return t.tagName},setTextContent:function(t,e){t.textContent=e},setStyleScope:function(t,e){t.setAttribute(e,"")}}),no={create:function(t,e){ro(e)},update:function(t,e){t.data.ref!==e.data.ref&&(ro(t,!0),ro(e))},destroy:function(t){ro(t,!0)}};function ro(t,n){var o=t.data.ref;if(r(o)){var i=t.context,s=t.componentInstance||t.elm,c=n?null:s,u=n?void 0:s;if(a(o))dn(o,i,[c],i,"template ref function");else{var l=t.data.refInFor,f="string"==typeof o||"number"==typeof o,d=Ft(o),p=i.$refs;if(f||d)if(l){var v=f?p[o]:o.value;n?e(v)&&g(v,s):e(v)?v.includes(s)||v.push(s):f?(p[o]=[s],oo(i,o,p[o])):o.value=[s]}else if(f){if(n&&p[o]!==s)return;p[o]=u,oo(i,o,c)}else if(d){if(n&&o.value!==s)return;o.value=c}}}}function oo(t,e,n){var r=t._setupState;r&&_(r,e)&&(Ft(r[e])?r[e].value=n:r[e]=n)}var io=new lt("",{},[]),ao=["create","activate","update","remove","destroy"];function so(t,e){return t.key===e.key&&t.asyncFactory===e.asyncFactory&&(t.tag===e.tag&&t.isComment===e.isComment&&r(t.data)===r(e.data)&&function(t,e){if("input"!==t.tag)return!0;var n,o=r(n=t.data)&&r(n=n.attrs)&&n.type,i=r(n=e.data)&&r(n=n.attrs)&&n.type;return o===i||Qr(o)&&Qr(i)}(t,e)||o(t.isAsyncPlaceholder)&&n(e.asyncFactory.error))}function co(t,e,n){var o,i,a={};for(o=e;o<=n;++o)r(i=t[o].key)&&(a[i]=o);return a}var uo={create:lo,update:lo,destroy:function(t){lo(t,io)}};function lo(t,e){(t.data.directives||e.data.directives)&&function(t,e){var n,r,o,i=t===io,a=e===io,s=po(t.data.directives,t.context),c=po(e.data.directives,e.context),u=[],l=[];for(n in c)r=s[n],o=c[n],r?(o.oldValue=r.value,o.oldArg=r.arg,ho(o,"update",e,t),o.def&&o.def.componentUpdated&&l.push(o)):(ho(o,"bind",e,t),o.def&&o.def.inserted&&u.push(o));if(u.length){var f=function(){for(var n=0;n<u.length;n++)ho(u[n],"inserted",e,t)};i?Zt(e,"insert",f):f()}l.length&&Zt(e,"postpatch",(function(){for(var n=0;n<l.length;n++)ho(l[n],"componentUpdated",e,t)}));if(!i)for(n in s)c[n]||ho(s[n],"unbind",t,t,a)}(t,e)}var fo=Object.create(null);function po(t,e){var n,r,o=Object.create(null);if(!t)return o;for(n=0;n<t.length;n++){if((r=t[n]).modifiers||(r.modifiers=fo),o[vo(r)]=r,e._setupState&&e._setupState.__sfc){var i=r.def||yr(e,"_setupState","v-"+r.name);r.def="function"==typeof i?{bind:i,update:i}:i}r.def=r.def||yr(e.$options,"directives",r.name)}return o}function vo(t){return t.rawName||"".concat(t.name,".").concat(Object.keys(t.modifiers||{}).join("."))}function ho(t,e,n,r,o){var i=t.def&&t.def[e];if(i)try{i(n.elm,t,n,r,o)}catch(r){fn(r,n.context,"directive ".concat(t.name," ").concat(e," hook"))}}var mo=[no,uo];function go(t,e){var i=e.componentOptions;if(!(r(i)&&!1===i.Ctor.options.inheritAttrs||n(t.data.attrs)&&n(e.data.attrs))){var a,s,c=e.elm,u=t.data.attrs||{},l=e.data.attrs||{};for(a in(r(l.__ob__)||o(l._v_attr_proxy))&&(l=e.data.attrs=T({},l)),l)s=l[a],u[a]!==s&&yo(c,a,s,e.data.pre);for(a in(W||G)&&l.value!==u.value&&yo(c,"value",l.value),u)n(l[a])&&(Hr(a)?c.removeAttributeNS(Fr,Br(a)):Ir(a)||c.removeAttribute(a))}}function yo(t,e,n,r){r||t.tagName.indexOf("-")>-1?_o(t,e,n):Rr(e)?Ur(n)?t.removeAttribute(e):(n="allowfullscreen"===e&&"EMBED"===t.tagName?"true":e,t.setAttribute(e,n)):Ir(e)?t.setAttribute(e,function(t,e){return Ur(e)||"false"===e?"false":"contenteditable"===t&&Lr(e)?e:"true"}(e,n)):Hr(e)?Ur(n)?t.removeAttributeNS(Fr,Br(e)):t.setAttributeNS(Fr,e,n):_o(t,e,n)}function _o(t,e,n){if(Ur(n))t.removeAttribute(e);else{if(W&&!Z&&"TEXTAREA"===t.tagName&&"placeholder"===e&&""!==n&&!t.__ieph){var r=function(e){e.stopImmediatePropagation(),t.removeEventListener("input",r)};t.addEventListener("input",r),t.__ieph=!0}t.setAttribute(e,n)}}var bo={create:go,update:go};function $o(t,e){var o=e.elm,i=e.data,a=t.data;if(!(n(i.staticClass)&&n(i.class)&&(n(a)||n(a.staticClass)&&n(a.class)))){var s=zr(e),c=o._transitionClasses;r(c)&&(s=Kr(s,Jr(c))),s!==o._prevClass&&(o.setAttribute("class",s),o._prevClass=s)}}var wo,xo,Co,ko,So,Oo,To={create:$o,update:$o},Ao=/[\w).+\-_$\]]/;function jo(t){var e,n,r,o,i,a=!1,s=!1,c=!1,u=!1,l=0,f=0,d=0,p=0;for(r=0;r<t.length;r++)if(n=e,e=t.charCodeAt(r),a)39===e&&92!==n&&(a=!1);else if(s)34===e&&92!==n&&(s=!1);else if(c)96===e&&92!==n&&(c=!1);else if(u)47===e&&92!==n&&(u=!1);else if(124!==e||124===t.charCodeAt(r+1)||124===t.charCodeAt(r-1)||l||f||d){switch(e){case 34:s=!0;break;case 39:a=!0;break;case 96:c=!0;break;case 40:d++;break;case 41:d--;break;case 91:f++;break;case 93:f--;break;case 123:l++;break;case 125:l--}if(47===e){for(var v=r-1,h=void 0;v>=0&&" "===(h=t.charAt(v));v--);h&&Ao.test(h)||(u=!0)}}else void 0===o?(p=r+1,o=t.slice(0,r).trim()):m();function m(){(i||(i=[])).push(t.slice(p,r).trim()),p=r+1}if(void 0===o?o=t.slice(0,r).trim():0!==p&&m(),i)for(r=0;r<i.length;r++)o=Eo(o,i[r]);return o}function Eo(t,e){var n=e.indexOf("(");if(n<0)return'_f("'.concat(e,'")(').concat(t,")");var r=e.slice(0,n),o=e.slice(n+1);return'_f("'.concat(r,'")(').concat(t).concat(")"!==o?","+o:o)}function No(t,e){console.error("[Vue compiler]: ".concat(t))}function Po(t,e){return t?t.map((function(t){return t[e]})).filter((function(t){return t})):[]}function Do(t,e,n,r,o){(t.props||(t.props=[])).push(zo({name:e,value:n,dynamic:o},r)),t.plain=!1}function Mo(t,e,n,r,o){(o?t.dynamicAttrs||(t.dynamicAttrs=[]):t.attrs||(t.attrs=[])).push(zo({name:e,value:n,dynamic:o},r)),t.plain=!1}function Io(t,e,n,r){t.attrsMap[e]=n,t.attrsList.push(zo({name:e,value:n},r))}function Lo(t,e,n,r,o,i,a,s){(t.directives||(t.directives=[])).push(zo({name:e,rawName:n,value:r,arg:o,isDynamicArg:i,modifiers:a},s)),t.plain=!1}function Ro(t,e,n){return n?"_p(".concat(e,',"').concat(t,'")'):t+e}function Fo(e,n,r,o,i,a,s,c){var u;(o=o||t).right?c?n="(".concat(n,")==='click'?'contextmenu':(").concat(n,")"):"click"===n&&(n="contextmenu",delete o.right):o.middle&&(c?n="(".concat(n,")==='click'?'mouseup':(").concat(n,")"):"click"===n&&(n="mouseup")),o.capture&&(delete o.capture,n=Ro("!",n,c)),o.once&&(delete o.once,n=Ro("~",n,c)),o.passive&&(delete o.passive,n=Ro("&",n,c)),o.native?(delete o.native,u=e.nativeEvents||(e.nativeEvents={})):u=e.events||(e.events={});var l=zo({value:r.trim(),dynamic:c},s);o!==t&&(l.modifiers=o);var f=u[n];Array.isArray(f)?i?f.unshift(l):f.push(l):u[n]=f?i?[l,f]:[f,l]:l,e.plain=!1}function Ho(t,e,n){var r=Bo(t,":"+e)||Bo(t,"v-bind:"+e);if(null!=r)return jo(r);if(!1!==n){var o=Bo(t,e);if(null!=o)return JSON.stringify(o)}}function Bo(t,e,n){var r;if(null!=(r=t.attrsMap[e]))for(var o=t.attrsList,i=0,a=o.length;i<a;i++)if(o[i].name===e){o.splice(i,1);break}return n&&delete t.attrsMap[e],r}function Uo(t,e){for(var n=t.attrsList,r=0,o=n.length;r<o;r++){var i=n[r];if(e.test(i.name))return n.splice(r,1),i}}function zo(t,e){return e&&(null!=e.start&&(t.start=e.start),null!=e.end&&(t.end=e.end)),t}function Vo(t,e,n){var r=n||{},o=r.number,i="$$v",a=i;r.trim&&(a="(typeof ".concat(i," === 'string'")+"? ".concat(i,".trim()")+": ".concat(i,")")),o&&(a="_n(".concat(a,")"));var s=Ko(e,a);t.model={value:"(".concat(e,")"),expression:JSON.stringify(e),callback:"function (".concat(i,") {").concat(s,"}")}}function Ko(t,e){var n=function(t){if(t=t.trim(),wo=t.length,t.indexOf("[")<0||t.lastIndexOf("]")<wo-1)return(ko=t.lastIndexOf("."))>-1?{exp:t.slice(0,ko),key:'"'+t.slice(ko+1)+'"'}:{exp:t,key:null};xo=t,ko=So=Oo=0;for(;!qo();)Wo(Co=Jo())?Go(Co):91===Co&&Zo(Co);return{exp:t.slice(0,So),key:t.slice(So+1,Oo)}}(t);return null===n.key?"".concat(t,"=").concat(e):"$set(".concat(n.exp,", ").concat(n.key,", ").concat(e,")")}function Jo(){return xo.charCodeAt(++ko)}function qo(){return ko>=wo}function Wo(t){return 34===t||39===t}function Zo(t){var e=1;for(So=ko;!qo();)if(Wo(t=Jo()))Go(t);else if(91===t&&e++,93===t&&e--,0===e){Oo=ko;break}}function Go(t){for(var e=t;!qo()&&(t=Jo())!==e;);}var Xo,Yo="__r";function Qo(t,e,n){var r=Xo;return function o(){var i=e.apply(null,arguments);null!==i&&ni(t,o,n,r)}}var ti=mn&&!(Q&&Number(Q[1])<=53);function ei(t,e,n,r){if(ti){var o=We,i=e;e=i._wrapper=function(t){if(t.target===t.currentTarget||t.timeStamp>=o||t.timeStamp<=0||t.target.ownerDocument!==document)return i.apply(this,arguments)}}Xo.addEventListener(t,e,et?{capture:n,passive:r}:n)}function ni(t,e,n,r){(r||Xo).removeEventListener(t,e._wrapper||e,n)}function ri(t,e){if(!n(t.data.on)||!n(e.data.on)){var o=e.data.on||{},i=t.data.on||{};Xo=e.elm||t.elm,function(t){if(r(t.__r)){var e=W?"change":"input";t[e]=[].concat(t.__r,t[e]||[]),delete t.__r}r(t.__c)&&(t.change=[].concat(t.__c,t.change||[]),delete t.__c)}(o),Wt(o,i,ei,ni,Qo,e.context),Xo=void 0}}var oi,ii={create:ri,update:ri,destroy:function(t){return ri(t,io)}};function ai(t,e){if(!n(t.data.domProps)||!n(e.data.domProps)){var i,a,s=e.elm,c=t.data.domProps||{},u=e.data.domProps||{};for(i in(r(u.__ob__)||o(u._v_attr_proxy))&&(u=e.data.domProps=T({},u)),c)i in u||(s[i]="");for(i in u){if(a=u[i],"textContent"===i||"innerHTML"===i){if(e.children&&(e.children.length=0),a===c[i])continue;1===s.childNodes.length&&s.removeChild(s.childNodes[0])}if("value"===i&&"PROGRESS"!==s.tagName){s._value=a;var l=n(a)?"":String(a);si(s,l)&&(s.value=l)}else if("innerHTML"===i&&Zr(s.tagName)&&n(s.innerHTML)){(oi=oi||document.createElement("div")).innerHTML="<svg>".concat(a,"</svg>");for(var f=oi.firstChild;s.firstChild;)s.removeChild(s.firstChild);for(;f.firstChild;)s.appendChild(f.firstChild)}else if(a!==c[i])try{s[i]=a}catch(t){}}}}function si(t,e){return!t.composing&&("OPTION"===t.tagName||function(t,e){var n=!0;try{n=document.activeElement!==t}catch(t){}return n&&t.value!==e}(t,e)||function(t,e){var n=t.value,o=t._vModifiers;if(r(o)){if(o.number)return p(n)!==p(e);if(o.trim)return n.trim()!==e.trim()}return n!==e}(t,e))}var ci={create:ai,update:ai},ui=b((function(t){var e={},n=/:(.+)/;return t.split(/;(?![^(]*\))/g).forEach((function(t){if(t){var r=t.split(n);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function li(t){var e=fi(t.style);return t.staticStyle?T(t.staticStyle,e):e}function fi(t){return Array.isArray(t)?A(t):"string"==typeof t?ui(t):t}var di,pi=/^--/,vi=/\s*!important$/,hi=function(t,e,n){if(pi.test(e))t.style.setProperty(e,n);else if(vi.test(n))t.style.setProperty(k(e),n.replace(vi,""),"important");else{var r=gi(e);if(Array.isArray(n))for(var o=0,i=n.length;o<i;o++)t.style[r]=n[o];else t.style[r]=n}},mi=["Webkit","Moz","ms"],gi=b((function(t){if(di=di||document.createElement("div").style,"filter"!==(t=w(t))&&t in di)return t;for(var e=t.charAt(0).toUpperCase()+t.slice(1),n=0;n<mi.length;n++){var r=mi[n]+e;if(r in di)return r}}));function yi(t,e){var o=e.data,i=t.data;if(!(n(o.staticStyle)&&n(o.style)&&n(i.staticStyle)&&n(i.style))){var a,s,c=e.elm,u=i.staticStyle,l=i.normalizedStyle||i.style||{},f=u||l,d=fi(e.data.style)||{};e.data.normalizedStyle=r(d.__ob__)?T({},d):d;var p=function(t,e){var n,r={};if(e)for(var o=t;o.componentInstance;)(o=o.componentInstance._vnode)&&o.data&&(n=li(o.data))&&T(r,n);(n=li(t.data))&&T(r,n);for(var i=t;i=i.parent;)i.data&&(n=li(i.data))&&T(r,n);return r}(e,!0);for(s in f)n(p[s])&&hi(c,s,"");for(s in p)(a=p[s])!==f[s]&&hi(c,s,null==a?"":a)}}var _i={create:yi,update:yi},bi=/\s+/;function $i(t,e){if(e&&(e=e.trim()))if(t.classList)e.indexOf(" ")>-1?e.split(bi).forEach((function(e){return t.classList.add(e)})):t.classList.add(e);else{var n=" ".concat(t.getAttribute("class")||""," ");n.indexOf(" "+e+" ")<0&&t.setAttribute("class",(n+e).trim())}}function wi(t,e){if(e&&(e=e.trim()))if(t.classList)e.indexOf(" ")>-1?e.split(bi).forEach((function(e){return t.classList.remove(e)})):t.classList.remove(e),t.classList.length||t.removeAttribute("class");else{for(var n=" ".concat(t.getAttribute("class")||""," "),r=" "+e+" ";n.indexOf(r)>=0;)n=n.replace(r," ");(n=n.trim())?t.setAttribute("class",n):t.removeAttribute("class")}}function xi(t){if(t){if("object"==typeof t){var e={};return!1!==t.css&&T(e,Ci(t.name||"v")),T(e,t),e}return"string"==typeof t?Ci(t):void 0}}var Ci=b((function(t){return{enterClass:"".concat(t,"-enter"),enterToClass:"".concat(t,"-enter-to"),enterActiveClass:"".concat(t,"-enter-active"),leaveClass:"".concat(t,"-leave"),leaveToClass:"".concat(t,"-leave-to"),leaveActiveClass:"".concat(t,"-leave-active")}})),ki=J&&!Z,Si="transition",Oi="animation",Ti="transition",Ai="transitionend",ji="animation",Ei="animationend";ki&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Ti="WebkitTransition",Ai="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(ji="WebkitAnimation",Ei="webkitAnimationEnd"));var Ni=J?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(t){return t()};function Pi(t){Ni((function(){Ni(t)}))}function Di(t,e){var n=t._transitionClasses||(t._transitionClasses=[]);n.indexOf(e)<0&&(n.push(e),$i(t,e))}function Mi(t,e){t._transitionClasses&&g(t._transitionClasses,e),wi(t,e)}function Ii(t,e,n){var r=Ri(t,e),o=r.type,i=r.timeout,a=r.propCount;if(!o)return n();var s=o===Si?Ai:Ei,c=0,u=function(){t.removeEventListener(s,l),n()},l=function(e){e.target===t&&++c>=a&&u()};setTimeout((function(){c<a&&u()}),i+1),t.addEventListener(s,l)}var Li=/\b(transform|all)(,|$)/;function Ri(t,e){var n,r=window.getComputedStyle(t),o=(r[Ti+"Delay"]||"").split(", "),i=(r[Ti+"Duration"]||"").split(", "),a=Fi(o,i),s=(r[ji+"Delay"]||"").split(", "),c=(r[ji+"Duration"]||"").split(", "),u=Fi(s,c),l=0,f=0;return e===Si?a>0&&(n=Si,l=a,f=i.length):e===Oi?u>0&&(n=Oi,l=u,f=c.length):f=(n=(l=Math.max(a,u))>0?a>u?Si:Oi:null)?n===Si?i.length:c.length:0,{type:n,timeout:l,propCount:f,hasTransform:n===Si&&Li.test(r[Ti+"Property"])}}function Fi(t,e){for(;t.length<e.length;)t=t.concat(t);return Math.max.apply(null,e.map((function(e,n){return Hi(e)+Hi(t[n])})))}function Hi(t){return 1e3*Number(t.slice(0,-1).replace(",","."))}function Bi(t,e){var o=t.elm;r(o._leaveCb)&&(o._leaveCb.cancelled=!0,o._leaveCb());var i=xi(t.data.transition);if(!n(i)&&!r(o._enterCb)&&1===o.nodeType){for(var c=i.css,u=i.type,l=i.enterClass,f=i.enterToClass,d=i.enterActiveClass,v=i.appearClass,h=i.appearToClass,m=i.appearActiveClass,g=i.beforeEnter,y=i.enter,_=i.afterEnter,b=i.enterCancelled,$=i.beforeAppear,w=i.appear,x=i.afterAppear,C=i.appearCancelled,k=i.duration,S=Ie,O=Ie.$vnode;O&&O.parent;)S=O.context,O=O.parent;var T=!S._isMounted||!t.isRootInsert;if(!T||w||""===w){var A=T&&v?v:l,j=T&&m?m:d,E=T&&h?h:f,N=T&&$||g,P=T&&a(w)?w:y,D=T&&x||_,I=T&&C||b,L=p(s(k)?k.enter:k),R=!1!==c&&!Z,F=Vi(P),H=o._enterCb=M((function(){R&&(Mi(o,E),Mi(o,j)),H.cancelled?(R&&Mi(o,A),I&&I(o)):D&&D(o),o._enterCb=null}));t.data.show||Zt(t,"insert",(function(){var e=o.parentNode,n=e&&e._pending&&e._pending[t.key];n&&n.tag===t.tag&&n.elm._leaveCb&&n.elm._leaveCb(),P&&P(o,H)})),N&&N(o),R&&(Di(o,A),Di(o,j),Pi((function(){Mi(o,A),H.cancelled||(Di(o,E),F||(zi(L)?setTimeout(H,L):Ii(o,u,H)))}))),t.data.show&&(e&&e(),P&&P(o,H)),R||F||H()}}}function Ui(t,e){var o=t.elm;r(o._enterCb)&&(o._enterCb.cancelled=!0,o._enterCb());var i=xi(t.data.transition);if(n(i)||1!==o.nodeType)return e();if(!r(o._leaveCb)){var a=i.css,c=i.type,u=i.leaveClass,l=i.leaveToClass,f=i.leaveActiveClass,d=i.beforeLeave,v=i.leave,h=i.afterLeave,m=i.leaveCancelled,g=i.delayLeave,y=i.duration,_=!1!==a&&!Z,b=Vi(v),$=p(s(y)?y.leave:y),w=o._leaveCb=M((function(){o.parentNode&&o.parentNode._pending&&(o.parentNode._pending[t.key]=null),_&&(Mi(o,l),Mi(o,f)),w.cancelled?(_&&Mi(o,u),m&&m(o)):(e(),h&&h(o)),o._leaveCb=null}));g?g(x):x()}function x(){w.cancelled||(!t.data.show&&o.parentNode&&((o.parentNode._pending||(o.parentNode._pending={}))[t.key]=t),d&&d(o),_&&(Di(o,u),Di(o,f),Pi((function(){Mi(o,u),w.cancelled||(Di(o,l),b||(zi($)?setTimeout(w,$):Ii(o,c,w)))}))),v&&v(o,w),_||b||w())}}function zi(t){return"number"==typeof t&&!isNaN(t)}function Vi(t){if(n(t))return!1;var e=t.fns;return r(e)?Vi(Array.isArray(e)?e[0]:e):(t._length||t.length)>1}function Ki(t,e){!0!==e.data.show&&Bi(e)}var Ji=function(t){var a,s,c={},u=t.modules,l=t.nodeOps;for(a=0;a<ao.length;++a)for(c[ao[a]]=[],s=0;s<u.length;++s)r(u[s][ao[a]])&&c[ao[a]].push(u[s][ao[a]]);function f(t){var e=l.parentNode(t);r(e)&&l.removeChild(e,t)}function d(t,e,n,i,a,s,u){if(r(t.elm)&&r(s)&&(t=s[u]=pt(t)),t.isRootInsert=!a,!function(t,e,n,i){var a=t.data;if(r(a)){var s=r(t.componentInstance)&&a.keepAlive;if(r(a=a.hook)&&r(a=a.init)&&a(t,!1),r(t.componentInstance))return p(t,e),h(n,t.elm,i),o(s)&&function(t,e,n,o){var i,a=t;for(;a.componentInstance;)if(r(i=(a=a.componentInstance._vnode).data)&&r(i=i.transition)){for(i=0;i<c.activate.length;++i)c.activate[i](io,a);e.push(a);break}h(n,t.elm,o)}(t,e,n,i),!0}}(t,e,n,i)){var f=t.data,d=t.children,v=t.tag;r(v)?(t.elm=t.ns?l.createElementNS(t.ns,v):l.createElement(v,t),_(t),m(t,d,e),r(f)&&y(t,e),h(n,t.elm,i)):o(t.isComment)?(t.elm=l.createComment(t.text),h(n,t.elm,i)):(t.elm=l.createTextNode(t.text),h(n,t.elm,i))}}function p(t,e){r(t.data.pendingInsert)&&(e.push.apply(e,t.data.pendingInsert),t.data.pendingInsert=null),t.elm=t.componentInstance.$el,g(t)?(y(t,e),_(t)):(ro(t),e.push(t))}function h(t,e,n){r(t)&&(r(n)?l.parentNode(n)===t&&l.insertBefore(t,e,n):l.appendChild(t,e))}function m(t,n,r){if(e(n))for(var o=0;o<n.length;++o)d(n[o],r,t.elm,null,!0,n,o);else i(t.text)&&l.appendChild(t.elm,l.createTextNode(String(t.text)))}function g(t){for(;t.componentInstance;)t=t.componentInstance._vnode;return r(t.tag)}function y(t,e){for(var n=0;n<c.create.length;++n)c.create[n](io,t);r(a=t.data.hook)&&(r(a.create)&&a.create(io,t),r(a.insert)&&e.push(t))}function _(t){var e;if(r(e=t.fnScopeId))l.setStyleScope(t.elm,e);else for(var n=t;n;)r(e=n.context)&&r(e=e.$options._scopeId)&&l.setStyleScope(t.elm,e),n=n.parent;r(e=Ie)&&e!==t.context&&e!==t.fnContext&&r(e=e.$options._scopeId)&&l.setStyleScope(t.elm,e)}function b(t,e,n,r,o,i){for(;r<=o;++r)d(n[r],i,t,e,!1,n,r)}function $(t){var e,n,o=t.data;if(r(o))for(r(e=o.hook)&&r(e=e.destroy)&&e(t),e=0;e<c.destroy.length;++e)c.destroy[e](t);if(r(e=t.children))for(n=0;n<t.children.length;++n)$(t.children[n])}function w(t,e,n){for(;e<=n;++e){var o=t[e];r(o)&&(r(o.tag)?(x(o),$(o)):f(o.elm))}}function x(t,e){if(r(e)||r(t.data)){var n,o=c.remove.length+1;for(r(e)?e.listeners+=o:e=function(t,e){function n(){0==--n.listeners&&f(t)}return n.listeners=e,n}(t.elm,o),r(n=t.componentInstance)&&r(n=n._vnode)&&r(n.data)&&x(n,e),n=0;n<c.remove.length;++n)c.remove[n](t,e);r(n=t.data.hook)&&r(n=n.remove)?n(t,e):e()}else f(t.elm)}function C(t,e,n,o){for(var i=n;i<o;i++){var a=e[i];if(r(a)&&so(t,a))return i}}function k(t,e,i,a,s,u){if(t!==e){r(e.elm)&&r(a)&&(e=a[s]=pt(e));var f=e.elm=t.elm;if(o(t.isAsyncPlaceholder))r(e.asyncFactory.resolved)?T(t.elm,e,i):e.isAsyncPlaceholder=!0;else if(o(e.isStatic)&&o(t.isStatic)&&e.key===t.key&&(o(e.isCloned)||o(e.isOnce)))e.componentInstance=t.componentInstance;else{var p,v=e.data;r(v)&&r(p=v.hook)&&r(p=p.prepatch)&&p(t,e);var h=t.children,m=e.children;if(r(v)&&g(e)){for(p=0;p<c.update.length;++p)c.update[p](t,e);r(p=v.hook)&&r(p=p.update)&&p(t,e)}n(e.text)?r(h)&&r(m)?h!==m&&function(t,e,o,i,a){for(var s,c,u,f=0,p=0,v=e.length-1,h=e[0],m=e[v],g=o.length-1,y=o[0],_=o[g],$=!a;f<=v&&p<=g;)n(h)?h=e[++f]:n(m)?m=e[--v]:so(h,y)?(k(h,y,i,o,p),h=e[++f],y=o[++p]):so(m,_)?(k(m,_,i,o,g),m=e[--v],_=o[--g]):so(h,_)?(k(h,_,i,o,g),$&&l.insertBefore(t,h.elm,l.nextSibling(m.elm)),h=e[++f],_=o[--g]):so(m,y)?(k(m,y,i,o,p),$&&l.insertBefore(t,m.elm,h.elm),m=e[--v],y=o[++p]):(n(s)&&(s=co(e,f,v)),n(c=r(y.key)?s[y.key]:C(y,e,f,v))?d(y,i,t,h.elm,!1,o,p):so(u=e[c],y)?(k(u,y,i,o,p),e[c]=void 0,$&&l.insertBefore(t,u.elm,h.elm)):d(y,i,t,h.elm,!1,o,p),y=o[++p]);f>v?b(t,n(o[g+1])?null:o[g+1].elm,o,p,g,i):p>g&&w(e,f,v)}(f,h,m,i,u):r(m)?(r(t.text)&&l.setTextContent(f,""),b(f,null,m,0,m.length-1,i)):r(h)?w(h,0,h.length-1):r(t.text)&&l.setTextContent(f,""):t.text!==e.text&&l.setTextContent(f,e.text),r(v)&&r(p=v.hook)&&r(p=p.postpatch)&&p(t,e)}}}function S(t,e,n){if(o(n)&&r(t.parent))t.parent.data.pendingInsert=e;else for(var i=0;i<e.length;++i)e[i].data.hook.insert(e[i])}var O=v("attrs,class,staticClass,staticStyle,key");function T(t,e,n,i){var a,s=e.tag,c=e.data,u=e.children;if(i=i||c&&c.pre,e.elm=t,o(e.isComment)&&r(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(r(c)&&(r(a=c.hook)&&r(a=a.init)&&a(e,!0),r(a=e.componentInstance)))return p(e,n),!0;if(r(s)){if(r(u))if(t.hasChildNodes())if(r(a=c)&&r(a=a.domProps)&&r(a=a.innerHTML)){if(a!==t.innerHTML)return!1}else{for(var l=!0,f=t.firstChild,d=0;d<u.length;d++){if(!f||!T(f,u[d],n,i)){l=!1;break}f=f.nextSibling}if(!l||f)return!1}else m(e,u,n);if(r(c)){var v=!1;for(var h in c)if(!O(h)){v=!0,y(e,n);break}!v&&c.class&&Bn(c.class)}}else t.data!==e.text&&(t.data=e.text);return!0}return function(t,e,i,a){if(!n(e)){var s,u=!1,f=[];if(n(t))u=!0,d(e,f);else{var p=r(t.nodeType);if(!p&&so(t,e))k(t,e,f,null,null,a);else{if(p){if(1===t.nodeType&&t.hasAttribute(L)&&(t.removeAttribute(L),i=!0),o(i)&&T(t,e,f))return S(e,f,!0),t;s=t,t=new lt(l.tagName(s).toLowerCase(),{},[],void 0,s)}var v=t.elm,h=l.parentNode(v);if(d(e,f,v._leaveCb?null:h,l.nextSibling(v)),r(e.parent))for(var m=e.parent,y=g(e);m;){for(var _=0;_<c.destroy.length;++_)c.destroy[_](m);if(m.elm=e.elm,y){for(var b=0;b<c.create.length;++b)c.create[b](io,m);var x=m.data.hook.insert;if(x.merged)for(var C=1;C<x.fns.length;C++)x.fns[C]()}else ro(m);m=m.parent}r(h)?w([t],0,0):r(t.tag)&&$(t)}}return S(e,f,u),e.elm}r(t)&&$(t)}}({nodeOps:eo,modules:[bo,To,ii,ci,_i,J?{create:Ki,activate:Ki,remove:function(t,e){!0!==t.data.show?Ui(t,e):e()}}:{}].concat(mo)});Z&&document.addEventListener("selectionchange",(function(){var t=document.activeElement;t&&t.vmodel&&ta(t,"input")}));var qi={inserted:function(t,e,n,r){"select"===n.tag?(r.elm&&!r.elm._vOptions?Zt(n,"postpatch",(function(){qi.componentUpdated(t,e,n)})):Wi(t,e,n.context),t._vOptions=[].map.call(t.options,Xi)):("textarea"===n.tag||Qr(t.type))&&(t._vModifiers=e.modifiers,e.modifiers.lazy||(t.addEventListener("compositionstart",Yi),t.addEventListener("compositionend",Qi),t.addEventListener("change",Qi),Z&&(t.vmodel=!0)))},componentUpdated:function(t,e,n){if("select"===n.tag){Wi(t,e,n.context);var r=t._vOptions,o=t._vOptions=[].map.call(t.options,Xi);if(o.some((function(t,e){return!P(t,r[e])})))(t.multiple?e.value.some((function(t){return Gi(t,o)})):e.value!==e.oldValue&&Gi(e.value,o))&&ta(t,"change")}}};function Wi(t,e,n){Zi(t,e),(W||G)&&setTimeout((function(){Zi(t,e)}),0)}function Zi(t,e,n){var r=e.value,o=t.multiple;if(!o||Array.isArray(r)){for(var i,a,s=0,c=t.options.length;s<c;s++)if(a=t.options[s],o)i=D(r,Xi(a))>-1,a.selected!==i&&(a.selected=i);else if(P(Xi(a),r))return void(t.selectedIndex!==s&&(t.selectedIndex=s));o||(t.selectedIndex=-1)}}function Gi(t,e){return e.every((function(e){return!P(e,t)}))}function Xi(t){return"_value"in t?t._value:t.value}function Yi(t){t.target.composing=!0}function Qi(t){t.target.composing&&(t.target.composing=!1,ta(t.target,"input"))}function ta(t,e){var n=document.createEvent("HTMLEvents");n.initEvent(e,!0,!0),t.dispatchEvent(n)}function ea(t){return!t.componentInstance||t.data&&t.data.transition?t:ea(t.componentInstance._vnode)}var na={bind:function(t,e,n){var r=e.value,o=(n=ea(n)).data&&n.data.transition,i=t.__vOriginalDisplay="none"===t.style.display?"":t.style.display;r&&o?(n.data.show=!0,Bi(n,(function(){t.style.display=i}))):t.style.display=r?i:"none"},update:function(t,e,n){var r=e.value;!r!=!e.oldValue&&((n=ea(n)).data&&n.data.transition?(n.data.show=!0,r?Bi(n,(function(){t.style.display=t.__vOriginalDisplay})):Ui(n,(function(){t.style.display="none"}))):t.style.display=r?t.__vOriginalDisplay:"none")},unbind:function(t,e,n,r,o){o||(t.style.display=t.__vOriginalDisplay)}},ra={model:qi,show:na},oa={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function ia(t){var e=t&&t.componentOptions;return e&&e.Ctor.options.abstract?ia(Ee(e.children)):t}function aa(t){var e={},n=t.$options;for(var r in n.propsData)e[r]=t[r];var o=n._parentListeners;for(var r in o)e[w(r)]=o[r];return e}function sa(t,e){if(/\d-keep-alive$/.test(e.tag))return t("keep-alive",{props:e.componentOptions.propsData})}var ca=function(t){return t.tag||_e(t)},ua=function(t){return"show"===t.name},la={name:"transition",props:oa,abstract:!0,render:function(t){var e=this,n=this.$slots.default;if(n&&(n=n.filter(ca)).length){var r=this.mode,o=n[0];if(function(t){for(;t=t.parent;)if(t.data.transition)return!0}(this.$vnode))return o;var a=ia(o);if(!a)return o;if(this._leaving)return sa(t,o);var s="__transition-".concat(this._uid,"-");a.key=null==a.key?a.isComment?s+"comment":s+a.tag:i(a.key)?0===String(a.key).indexOf(s)?a.key:s+a.key:a.key;var c=(a.data||(a.data={})).transition=aa(this),u=this._vnode,l=ia(u);if(a.data.directives&&a.data.directives.some(ua)&&(a.data.show=!0),l&&l.data&&!function(t,e){return e.key===t.key&&e.tag===t.tag}(a,l)&&!_e(l)&&(!l.componentInstance||!l.componentInstance._vnode.isComment)){var f=l.data.transition=T({},c);if("out-in"===r)return this._leaving=!0,Zt(f,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),sa(t,o);if("in-out"===r){if(_e(a))return u;var d,p=function(){d()};Zt(c,"afterEnter",p),Zt(c,"enterCancelled",p),Zt(f,"delayLeave",(function(t){d=t}))}}return o}}},fa=T({tag:String,moveClass:String},oa);delete fa.mode;var da={props:fa,beforeMount:function(){var t=this,e=this._update;this._update=function(n,r){var o=Le(t);t.__patch__(t._vnode,t.kept,!1,!0),t._vnode=t.kept,o(),e.call(t,n,r)}},render:function(t){for(var e=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),r=this.prevChildren=this.children,o=this.$slots.default||[],i=this.children=[],a=aa(this),s=0;s<o.length;s++){(l=o[s]).tag&&null!=l.key&&0!==String(l.key).indexOf("__vlist")&&(i.push(l),n[l.key]=l,(l.data||(l.data={})).transition=a)}if(r){var c=[],u=[];for(s=0;s<r.length;s++){var l;(l=r[s]).data.transition=a,l.data.pos=l.elm.getBoundingClientRect(),n[l.key]?c.push(l):u.push(l)}this.kept=t(e,null,c),this.removed=u}return t(e,null,i)},updated:function(){var t=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";t.length&&this.hasMove(t[0].elm,e)&&(t.forEach(pa),t.forEach(va),t.forEach(ha),this._reflow=document.body.offsetHeight,t.forEach((function(t){if(t.data.moved){var n=t.elm,r=n.style;Di(n,e),r.transform=r.WebkitTransform=r.transitionDuration="",n.addEventListener(Ai,n._moveCb=function t(r){r&&r.target!==n||r&&!/transform$/.test(r.propertyName)||(n.removeEventListener(Ai,t),n._moveCb=null,Mi(n,e))})}})))},methods:{hasMove:function(t,e){if(!ki)return!1;if(this._hasMove)return this._hasMove;var n=t.cloneNode();t._transitionClasses&&t._transitionClasses.forEach((function(t){wi(n,t)})),$i(n,e),n.style.display="none",this.$el.appendChild(n);var r=Ri(n);return this.$el.removeChild(n),this._hasMove=r.hasTransform}}};function pa(t){t.elm._moveCb&&t.elm._moveCb(),t.elm._enterCb&&t.elm._enterCb()}function va(t){t.data.newPos=t.elm.getBoundingClientRect()}function ha(t){var e=t.data.pos,n=t.data.newPos,r=e.left-n.left,o=e.top-n.top;if(r||o){t.data.moved=!0;var i=t.elm.style;i.transform=i.WebkitTransform="translate(".concat(r,"px,").concat(o,"px)"),i.transitionDuration="0s"}}var ma={Transition:la,TransitionGroup:da};Cr.config.mustUseProp=Mr,Cr.config.isReservedTag=Gr,Cr.config.isReservedAttr=Pr,Cr.config.getTagNamespace=Xr,Cr.config.isUnknownElement=function(t){if(!J)return!0;if(Gr(t))return!1;if(t=t.toLowerCase(),null!=Yr[t])return Yr[t];var e=document.createElement(t);return t.indexOf("-")>-1?Yr[t]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Yr[t]=/HTMLUnknownElement/.test(e.toString())},T(Cr.options.directives,ra),T(Cr.options.components,ma),Cr.prototype.__patch__=J?Ji:j,Cr.prototype.$mount=function(t,e){return function(t,e,n){var r;t.$el=e,t.$options.render||(t.$options.render=ft),Be(t,"beforeMount"),r=function(){t._update(t._render(),n)},new Vn(t,r,j,{before:function(){t._isMounted&&!t._isDestroyed&&Be(t,"beforeUpdate")}},!0),n=!1;var o=t._preWatchers;if(o)for(var i=0;i<o.length;i++)o[i].run();return null==t.$vnode&&(t._isMounted=!0,Be(t,"mounted")),t}(this,t=t&&J?to(t):void 0,e)},J&&setTimeout((function(){H.devtools&&ot&&ot.emit("init",Cr)}),0);var ga=/\{\{((?:.|\r?\n)+?)\}\}/g,ya=/[-.*+?^${}()|[\]\/\\]/g,_a=b((function(t){var e=t[0].replace(ya,"\\$&"),n=t[1].replace(ya,"\\$&");return new RegExp(e+"((?:.|\\n)+?)"+n,"g")}));var ba={staticKeys:["staticClass"],transformNode:function(t,e){e.warn;var n=Bo(t,"class");n&&(t.staticClass=JSON.stringify(n.replace(/\s+/g," ").trim()));var r=Ho(t,"class",!1);r&&(t.classBinding=r)},genData:function(t){var e="";return t.staticClass&&(e+="staticClass:".concat(t.staticClass,",")),t.classBinding&&(e+="class:".concat(t.classBinding,",")),e}};var $a,wa={staticKeys:["staticStyle"],transformNode:function(t,e){e.warn;var n=Bo(t,"style");n&&(t.staticStyle=JSON.stringify(ui(n)));var r=Ho(t,"style",!1);r&&(t.styleBinding=r)},genData:function(t){var e="";return t.staticStyle&&(e+="staticStyle:".concat(t.staticStyle,",")),t.styleBinding&&(e+="style:(".concat(t.styleBinding,"),")),e}},xa=function(t){return($a=$a||document.createElement("div")).innerHTML=t,$a.textContent},Ca=v("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),ka=v("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),Sa=v("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),Oa=/^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Ta=/^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Aa="[a-zA-Z_][\\-\\.0-9_a-zA-Z".concat(B.source,"]*"),ja="((?:".concat(Aa,"\\:)?").concat(Aa,")"),Ea=new RegExp("^<".concat(ja)),Na=/^\s*(\/?)>/,Pa=new RegExp("^<\\/".concat(ja,"[^>]*>")),Da=/^<!DOCTYPE [^>]+>/i,Ma=/^<!\--/,Ia=/^<!\[/,La=v("script,style,textarea",!0),Ra={},Fa={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n","&#9;":"\t","&#39;":"'"},Ha=/&(?:lt|gt|quot|amp|#39);/g,Ba=/&(?:lt|gt|quot|amp|#39|#10|#9);/g,Ua=v("pre,textarea",!0),za=function(t,e){return t&&Ua(t)&&"\n"===e[0]};function Va(t,e){var n=e?Ba:Ha;return t.replace(n,(function(t){return Fa[t]}))}function Ka(t,e){for(var n,r,o=[],i=e.expectHTML,a=e.isUnaryTag||E,s=e.canBeLeftOpenTag||E,c=0,u=function(){if(n=t,r&&La(r)){var u=0,d=r.toLowerCase(),p=Ra[d]||(Ra[d]=new RegExp("([\\s\\S]*?)(</"+d+"[^>]*>)","i"));w=t.replace(p,(function(t,n,r){return u=r.length,La(d)||"noscript"===d||(n=n.replace(/<!\--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),za(d,n)&&(n=n.slice(1)),e.chars&&e.chars(n),""}));c+=t.length-w.length,t=w,f(d,c-u,c)}else{var v=t.indexOf("<");if(0===v){if(Ma.test(t)){var h=t.indexOf("--\x3e");if(h>=0)return e.shouldKeepComment&&e.comment&&e.comment(t.substring(4,h),c,c+h+3),l(h+3),"continue"}if(Ia.test(t)){var m=t.indexOf("]>");if(m>=0)return l(m+2),"continue"}var g=t.match(Da);if(g)return l(g[0].length),"continue";var y=t.match(Pa);if(y){var _=c;return l(y[0].length),f(y[1],_,c),"continue"}var b=function(){var e=t.match(Ea);if(e){var n={tagName:e[1],attrs:[],start:c};l(e[0].length);for(var r=void 0,o=void 0;!(r=t.match(Na))&&(o=t.match(Ta)||t.match(Oa));)o.start=c,l(o[0].length),o.end=c,n.attrs.push(o);if(r)return n.unarySlash=r[1],l(r[0].length),n.end=c,n}}();if(b)return function(t){var n=t.tagName,c=t.unarySlash;i&&("p"===r&&Sa(n)&&f(r),s(n)&&r===n&&f(n));for(var u=a(n)||!!c,l=t.attrs.length,d=new Array(l),p=0;p<l;p++){var v=t.attrs[p],h=v[3]||v[4]||v[5]||"",m="a"===n&&"href"===v[1]?e.shouldDecodeNewlinesForHref:e.shouldDecodeNewlines;d[p]={name:v[1],value:Va(h,m)}}u||(o.push({tag:n,lowerCasedTag:n.toLowerCase(),attrs:d,start:t.start,end:t.end}),r=n);e.start&&e.start(n,d,u,t.start,t.end)}(b),za(b.tagName,t)&&l(1),"continue"}var $=void 0,w=void 0,x=void 0;if(v>=0){for(w=t.slice(v);!(Pa.test(w)||Ea.test(w)||Ma.test(w)||Ia.test(w)||(x=w.indexOf("<",1))<0);)v+=x,w=t.slice(v);$=t.substring(0,v)}v<0&&($=t),$&&l($.length),e.chars&&$&&e.chars($,c-$.length,c)}if(t===n)return e.chars&&e.chars(t),"break"};t;){if("break"===u())break}function l(e){c+=e,t=t.substring(e)}function f(t,n,i){var a,s;if(null==n&&(n=c),null==i&&(i=c),t)for(s=t.toLowerCase(),a=o.length-1;a>=0&&o[a].lowerCasedTag!==s;a--);else a=0;if(a>=0){for(var u=o.length-1;u>=a;u--)e.end&&e.end(o[u].tag,n,i);o.length=a,r=a&&o[a-1].tag}else"br"===s?e.start&&e.start(t,[],!0,n,i):"p"===s&&(e.start&&e.start(t,[],!1,n,i),e.end&&e.end(t,n,i))}f()}var Ja,qa,Wa,Za,Ga,Xa,Ya,Qa,ts=/^@|^v-on:/,es=/^v-|^@|^:|^#/,ns=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,rs=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,os=/^\(|\)$/g,is=/^\[.*\]$/,as=/:(.*)$/,ss=/^:|^\.|^v-bind:/,cs=/\.[^.\]]+(?=[^\]]*$)/g,us=/^v-slot(:|$)|^#/,ls=/[\r\n]/,fs=/[ \f\t\r\n]+/g,ds=b(xa),ps="_empty_";function vs(t,e,n){return{type:1,tag:t,attrsList:e,attrsMap:$s(e),rawAttrsMap:{},parent:n,children:[]}}function hs(t,e){Ja=e.warn||No,Xa=e.isPreTag||E,Ya=e.mustUseProp||E,Qa=e.getTagNamespace||E,e.isReservedTag,Wa=Po(e.modules,"transformNode"),Za=Po(e.modules,"preTransformNode"),Ga=Po(e.modules,"postTransformNode"),qa=e.delimiters;var n,r,o=[],i=!1!==e.preserveWhitespace,a=e.whitespace,s=!1,c=!1;function u(t){if(l(t),s||t.processed||(t=ms(t,e)),o.length||t===n||n.if&&(t.elseif||t.else)&&ys(n,{exp:t.elseif,block:t}),r&&!t.forbidden)if(t.elseif||t.else)a=t,u=function(t){for(var e=t.length;e--;){if(1===t[e].type)return t[e];t.pop()}}(r.children),u&&u.if&&ys(u,{exp:a.elseif,block:a});else{if(t.slotScope){var i=t.slotTarget||'"default"';(r.scopedSlots||(r.scopedSlots={}))[i]=t}r.children.push(t),t.parent=r}var a,u;t.children=t.children.filter((function(t){return!t.slotScope})),l(t),t.pre&&(s=!1),Xa(t.tag)&&(c=!1);for(var f=0;f<Ga.length;f++)Ga[f](t,e)}function l(t){if(!c)for(var e=void 0;(e=t.children[t.children.length-1])&&3===e.type&&" "===e.text;)t.children.pop()}return Ka(t,{warn:Ja,expectHTML:e.expectHTML,isUnaryTag:e.isUnaryTag,canBeLeftOpenTag:e.canBeLeftOpenTag,shouldDecodeNewlines:e.shouldDecodeNewlines,shouldDecodeNewlinesForHref:e.shouldDecodeNewlinesForHref,shouldKeepComment:e.comments,outputSourceRange:e.outputSourceRange,start:function(t,i,a,l,f){var d=r&&r.ns||Qa(t);W&&"svg"===d&&(i=function(t){for(var e=[],n=0;n<t.length;n++){var r=t[n];ws.test(r.name)||(r.name=r.name.replace(xs,""),e.push(r))}return e}(i));var p,v=vs(t,i,r);d&&(v.ns=d),"style"!==(p=v).tag&&("script"!==p.tag||p.attrsMap.type&&"text/javascript"!==p.attrsMap.type)||rt()||(v.forbidden=!0);for(var h=0;h<Za.length;h++)v=Za[h](v,e)||v;s||(!function(t){null!=Bo(t,"v-pre")&&(t.pre=!0)}(v),v.pre&&(s=!0)),Xa(v.tag)&&(c=!0),s?function(t){var e=t.attrsList,n=e.length;if(n)for(var r=t.attrs=new Array(n),o=0;o<n;o++)r[o]={name:e[o].name,value:JSON.stringify(e[o].value)},null!=e[o].start&&(r[o].start=e[o].start,r[o].end=e[o].end);else t.pre||(t.plain=!0)}(v):v.processed||(gs(v),function(t){var e=Bo(t,"v-if");if(e)t.if=e,ys(t,{exp:e,block:t});else{null!=Bo(t,"v-else")&&(t.else=!0);var n=Bo(t,"v-else-if");n&&(t.elseif=n)}}(v),function(t){null!=Bo(t,"v-once")&&(t.once=!0)}(v)),n||(n=v),a?u(v):(r=v,o.push(v))},end:function(t,e,n){var i=o[o.length-1];o.length-=1,r=o[o.length-1],u(i)},chars:function(t,e,n){if(r&&(!W||"textarea"!==r.tag||r.attrsMap.placeholder!==t)){var o,u=r.children;if(t=c||t.trim()?"script"===(o=r).tag||"style"===o.tag?t:ds(t):u.length?a?"condense"===a&&ls.test(t)?"":" ":i?" ":"":""){c||"condense"!==a||(t=t.replace(fs," "));var l=void 0,f=void 0;!s&&" "!==t&&(l=function(t,e){var n=e?_a(e):ga;if(n.test(t)){for(var r,o,i,a=[],s=[],c=n.lastIndex=0;r=n.exec(t);){(o=r.index)>c&&(s.push(i=t.slice(c,o)),a.push(JSON.stringify(i)));var u=jo(r[1].trim());a.push("_s(".concat(u,")")),s.push({"@binding":u}),c=o+r[0].length}return c<t.length&&(s.push(i=t.slice(c)),a.push(JSON.stringify(i))),{expression:a.join("+"),tokens:s}}}(t,qa))?f={type:2,expression:l.expression,tokens:l.tokens,text:t}:" "===t&&u.length&&" "===u[u.length-1].text||(f={type:3,text:t}),f&&u.push(f)}}},comment:function(t,e,n){if(r){var o={type:3,text:t,isComment:!0};r.children.push(o)}}}),n}function ms(t,e){var n,r;(r=Ho(n=t,"key"))&&(n.key=r),t.plain=!t.key&&!t.scopedSlots&&!t.attrsList.length,function(t){var e=Ho(t,"ref");e&&(t.ref=e,t.refInFor=function(t){var e=t;for(;e;){if(void 0!==e.for)return!0;e=e.parent}return!1}(t))}(t),function(t){var e;"template"===t.tag?(e=Bo(t,"scope"),t.slotScope=e||Bo(t,"slot-scope")):(e=Bo(t,"slot-scope"))&&(t.slotScope=e);var n=Ho(t,"slot");n&&(t.slotTarget='""'===n?'"default"':n,t.slotTargetDynamic=!(!t.attrsMap[":slot"]&&!t.attrsMap["v-bind:slot"]),"template"===t.tag||t.slotScope||Mo(t,"slot",n,function(t,e){return t.rawAttrsMap[":"+e]||t.rawAttrsMap["v-bind:"+e]||t.rawAttrsMap[e]}(t,"slot")));if("template"===t.tag){if(a=Uo(t,us)){var r=_s(a),o=r.name,i=r.dynamic;t.slotTarget=o,t.slotTargetDynamic=i,t.slotScope=a.value||ps}}else{var a;if(a=Uo(t,us)){var s=t.scopedSlots||(t.scopedSlots={}),c=_s(a),u=c.name,l=(i=c.dynamic,s[u]=vs("template",[],t));l.slotTarget=u,l.slotTargetDynamic=i,l.children=t.children.filter((function(t){if(!t.slotScope)return t.parent=l,!0})),l.slotScope=a.value||ps,t.children=[],t.plain=!1}}}(t),function(t){"slot"===t.tag&&(t.slotName=Ho(t,"name"))}(t),function(t){var e;(e=Ho(t,"is"))&&(t.component=e);null!=Bo(t,"inline-template")&&(t.inlineTemplate=!0)}(t);for(var o=0;o<Wa.length;o++)t=Wa[o](t,e)||t;return function(t){var e,n,r,o,i,a,s,c,u=t.attrsList;for(e=0,n=u.length;e<n;e++)if(r=o=u[e].name,i=u[e].value,es.test(r))if(t.hasBindings=!0,(a=bs(r.replace(es,"")))&&(r=r.replace(cs,"")),ss.test(r))r=r.replace(ss,""),i=jo(i),(c=is.test(r))&&(r=r.slice(1,-1)),a&&(a.prop&&!c&&"innerHtml"===(r=w(r))&&(r="innerHTML"),a.camel&&!c&&(r=w(r)),a.sync&&(s=Ko(i,"$event"),c?Fo(t,'"update:"+('.concat(r,")"),s,null,!1,0,u[e],!0):(Fo(t,"update:".concat(w(r)),s,null,!1,0,u[e]),k(r)!==w(r)&&Fo(t,"update:".concat(k(r)),s,null,!1,0,u[e])))),a&&a.prop||!t.component&&Ya(t.tag,t.attrsMap.type,r)?Do(t,r,i,u[e],c):Mo(t,r,i,u[e],c);else if(ts.test(r))r=r.replace(ts,""),(c=is.test(r))&&(r=r.slice(1,-1)),Fo(t,r,i,a,!1,0,u[e],c);else{var l=(r=r.replace(es,"")).match(as),f=l&&l[1];c=!1,f&&(r=r.slice(0,-(f.length+1)),is.test(f)&&(f=f.slice(1,-1),c=!0)),Lo(t,r,o,i,f,c,a,u[e])}else Mo(t,r,JSON.stringify(i),u[e]),!t.component&&"muted"===r&&Ya(t.tag,t.attrsMap.type,r)&&Do(t,r,"true",u[e])}(t),t}function gs(t){var e;if(e=Bo(t,"v-for")){var n=function(t){var e=t.match(ns);if(!e)return;var n={};n.for=e[2].trim();var r=e[1].trim().replace(os,""),o=r.match(rs);o?(n.alias=r.replace(rs,"").trim(),n.iterator1=o[1].trim(),o[2]&&(n.iterator2=o[2].trim())):n.alias=r;return n}(e);n&&T(t,n)}}function ys(t,e){t.ifConditions||(t.ifConditions=[]),t.ifConditions.push(e)}function _s(t){var e=t.name.replace(us,"");return e||"#"!==t.name[0]&&(e="default"),is.test(e)?{name:e.slice(1,-1),dynamic:!0}:{name:'"'.concat(e,'"'),dynamic:!1}}function bs(t){var e=t.match(cs);if(e){var n={};return e.forEach((function(t){n[t.slice(1)]=!0})),n}}function $s(t){for(var e={},n=0,r=t.length;n<r;n++)e[t[n].name]=t[n].value;return e}var ws=/^xmlns:NS\d+/,xs=/^NS\d+:/;function Cs(t){return vs(t.tag,t.attrsList.slice(),t.parent)}var ks=[ba,wa,{preTransformNode:function(t,e){if("input"===t.tag){var n=t.attrsMap;if(!n["v-model"])return;var r=void 0;if((n[":type"]||n["v-bind:type"])&&(r=Ho(t,"type")),n.type||r||!n["v-bind"]||(r="(".concat(n["v-bind"],").type")),r){var o=Bo(t,"v-if",!0),i=o?"&&(".concat(o,")"):"",a=null!=Bo(t,"v-else",!0),s=Bo(t,"v-else-if",!0),c=Cs(t);gs(c),Io(c,"type","checkbox"),ms(c,e),c.processed=!0,c.if="(".concat(r,")==='checkbox'")+i,ys(c,{exp:c.if,block:c});var u=Cs(t);Bo(u,"v-for",!0),Io(u,"type","radio"),ms(u,e),ys(c,{exp:"(".concat(r,")==='radio'")+i,block:u});var l=Cs(t);return Bo(l,"v-for",!0),Io(l,":type",r),ms(l,e),ys(c,{exp:o,block:l}),a?c.else=!0:s&&(c.elseif=s),c}}}}];var Ss,Os,Ts={model:function(t,e,n){var r=e.value,o=e.modifiers,i=t.tag,a=t.attrsMap.type;if(t.component)return Vo(t,r,o),!1;if("select"===i)!function(t,e,n){var r=n&&n.number,o='Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;'+"return ".concat(r?"_n(val)":"val","})"),i="$event.target.multiple ? $$selectedVal : $$selectedVal[0]",a="var $$selectedVal = ".concat(o,";");a="".concat(a," ").concat(Ko(e,i)),Fo(t,"change",a,null,!0)}(t,r,o);else if("input"===i&&"checkbox"===a)!function(t,e,n){var r=n&&n.number,o=Ho(t,"value")||"null",i=Ho(t,"true-value")||"true",a=Ho(t,"false-value")||"false";Do(t,"checked","Array.isArray(".concat(e,")")+"?_i(".concat(e,",").concat(o,")>-1")+("true"===i?":(".concat(e,")"):":_q(".concat(e,",").concat(i,")"))),Fo(t,"change","var $$a=".concat(e,",")+"$$el=$event.target,"+"$$c=$$el.checked?(".concat(i,"):(").concat(a,");")+"if(Array.isArray($$a)){"+"var $$v=".concat(r?"_n("+o+")":o,",")+"$$i=_i($$a,$$v);"+"if($$el.checked){$$i<0&&(".concat(Ko(e,"$$a.concat([$$v])"),")}")+"else{$$i>-1&&(".concat(Ko(e,"$$a.slice(0,$$i).concat($$a.slice($$i+1))"),")}")+"}else{".concat(Ko(e,"$$c"),"}"),null,!0)}(t,r,o);else if("input"===i&&"radio"===a)!function(t,e,n){var r=n&&n.number,o=Ho(t,"value")||"null";o=r?"_n(".concat(o,")"):o,Do(t,"checked","_q(".concat(e,",").concat(o,")")),Fo(t,"change",Ko(e,o),null,!0)}(t,r,o);else if("input"===i||"textarea"===i)!function(t,e,n){var r=t.attrsMap.type,o=n||{},i=o.lazy,a=o.number,s=o.trim,c=!i&&"range"!==r,u=i?"change":"range"===r?Yo:"input",l="$event.target.value";s&&(l="$event.target.value.trim()");a&&(l="_n(".concat(l,")"));var f=Ko(e,l);c&&(f="if($event.target.composing)return;".concat(f));Do(t,"value","(".concat(e,")")),Fo(t,u,f,null,!0),(s||a)&&Fo(t,"blur","$forceUpdate()")}(t,r,o);else if(!H.isReservedTag(i))return Vo(t,r,o),!1;return!0},text:function(t,e){e.value&&Do(t,"textContent","_s(".concat(e.value,")"),e)},html:function(t,e){e.value&&Do(t,"innerHTML","_s(".concat(e.value,")"),e)}},As={expectHTML:!0,modules:ks,directives:Ts,isPreTag:function(t){return"pre"===t},isUnaryTag:Ca,mustUseProp:Mr,canBeLeftOpenTag:ka,isReservedTag:Gr,getTagNamespace:Xr,staticKeys:function(t){return t.reduce((function(t,e){return t.concat(e.staticKeys||[])}),[]).join(",")}(ks)},js=b((function(t){return v("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap"+(t?","+t:""))}));function Es(t,e){t&&(Ss=js(e.staticKeys||""),Os=e.isReservedTag||E,Ns(t),Ps(t,!1))}function Ns(t){if(t.static=function(t){if(2===t.type)return!1;if(3===t.type)return!0;return!(!t.pre&&(t.hasBindings||t.if||t.for||h(t.tag)||!Os(t.tag)||function(t){for(;t.parent;){if("template"!==(t=t.parent).tag)return!1;if(t.for)return!0}return!1}(t)||!Object.keys(t).every(Ss)))}(t),1===t.type){if(!Os(t.tag)&&"slot"!==t.tag&&null==t.attrsMap["inline-template"])return;for(var e=0,n=t.children.length;e<n;e++){var r=t.children[e];Ns(r),r.static||(t.static=!1)}if(t.ifConditions)for(e=1,n=t.ifConditions.length;e<n;e++){var o=t.ifConditions[e].block;Ns(o),o.static||(t.static=!1)}}}function Ps(t,e){if(1===t.type){if((t.static||t.once)&&(t.staticInFor=e),t.static&&t.children.length&&(1!==t.children.length||3!==t.children[0].type))return void(t.staticRoot=!0);if(t.staticRoot=!1,t.children)for(var n=0,r=t.children.length;n<r;n++)Ps(t.children[n],e||!!t.for);if(t.ifConditions)for(n=1,r=t.ifConditions.length;n<r;n++)Ps(t.ifConditions[n].block,e)}}var Ds=/^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,Ms=/\([^)]*?\);*$/,Is=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,Ls={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},Rs={esc:["Esc","Escape"],tab:"Tab",enter:"Enter",space:[" ","Spacebar"],up:["Up","ArrowUp"],left:["Left","ArrowLeft"],right:["Right","ArrowRight"],down:["Down","ArrowDown"],delete:["Backspace","Delete","Del"]},Fs=function(t){return"if(".concat(t,")return null;")},Hs={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:Fs("$event.target !== $event.currentTarget"),ctrl:Fs("!$event.ctrlKey"),shift:Fs("!$event.shiftKey"),alt:Fs("!$event.altKey"),meta:Fs("!$event.metaKey"),left:Fs("'button' in $event && $event.button !== 0"),middle:Fs("'button' in $event && $event.button !== 1"),right:Fs("'button' in $event && $event.button !== 2")};function Bs(t,e){var n=e?"nativeOn:":"on:",r="",o="";for(var i in t){var a=Us(t[i]);t[i]&&t[i].dynamic?o+="".concat(i,",").concat(a,","):r+='"'.concat(i,'":').concat(a,",")}return r="{".concat(r.slice(0,-1),"}"),o?n+"_d(".concat(r,",[").concat(o.slice(0,-1),"])"):n+r}function Us(t){if(!t)return"function(){}";if(Array.isArray(t))return"[".concat(t.map((function(t){return Us(t)})).join(","),"]");var e=Is.test(t.value),n=Ds.test(t.value),r=Is.test(t.value.replace(Ms,""));if(t.modifiers){var o="",i="",a=[],s=function(e){if(Hs[e])i+=Hs[e],Ls[e]&&a.push(e);else if("exact"===e){var n=t.modifiers;i+=Fs(["ctrl","shift","alt","meta"].filter((function(t){return!n[t]})).map((function(t){return"$event.".concat(t,"Key")})).join("||"))}else a.push(e)};for(var c in t.modifiers)s(c);a.length&&(o+=function(t){return"if(!$event.type.indexOf('key')&&"+"".concat(t.map(zs).join("&&"),")return null;")}(a)),i&&(o+=i);var u=e?"return ".concat(t.value,".apply(null, arguments)"):n?"return (".concat(t.value,").apply(null, arguments)"):r?"return ".concat(t.value):t.value;return"function($event){".concat(o).concat(u,"}")}return e||n?t.value:"function($event){".concat(r?"return ".concat(t.value):t.value,"}")}function zs(t){var e=parseInt(t,10);if(e)return"$event.keyCode!==".concat(e);var n=Ls[t],r=Rs[t];return"_k($event.keyCode,"+"".concat(JSON.stringify(t),",")+"".concat(JSON.stringify(n),",")+"$event.key,"+"".concat(JSON.stringify(r))+")"}var Vs={on:function(t,e){t.wrapListeners=function(t){return"_g(".concat(t,",").concat(e.value,")")}},bind:function(t,e){t.wrapData=function(n){return"_b(".concat(n,",'").concat(t.tag,"',").concat(e.value,",").concat(e.modifiers&&e.modifiers.prop?"true":"false").concat(e.modifiers&&e.modifiers.sync?",true":"",")")}},cloak:j},Ks=function(t){this.options=t,this.warn=t.warn||No,this.transforms=Po(t.modules,"transformCode"),this.dataGenFns=Po(t.modules,"genData"),this.directives=T(T({},Vs),t.directives);var e=t.isReservedTag||E;this.maybeComponent=function(t){return!!t.component||!e(t.tag)},this.onceId=0,this.staticRenderFns=[],this.pre=!1};function Js(t,e){var n=new Ks(e),r=t?"script"===t.tag?"null":qs(t,n):'_c("div")';return{render:"with(this){return ".concat(r,"}"),staticRenderFns:n.staticRenderFns}}function qs(t,e){if(t.parent&&(t.pre=t.pre||t.parent.pre),t.staticRoot&&!t.staticProcessed)return Ws(t,e);if(t.once&&!t.onceProcessed)return Zs(t,e);if(t.for&&!t.forProcessed)return Ys(t,e);if(t.if&&!t.ifProcessed)return Gs(t,e);if("template"!==t.tag||t.slotTarget||e.pre){if("slot"===t.tag)return function(t,e){var n=t.slotName||'"default"',r=nc(t,e),o="_t(".concat(n).concat(r?",function(){return ".concat(r,"}"):""),i=t.attrs||t.dynamicAttrs?ic((t.attrs||[]).concat(t.dynamicAttrs||[]).map((function(t){return{name:w(t.name),value:t.value,dynamic:t.dynamic}}))):null,a=t.attrsMap["v-bind"];!i&&!a||r||(o+=",null");i&&(o+=",".concat(i));a&&(o+="".concat(i?"":",null",",").concat(a));return o+")"}(t,e);var n=void 0;if(t.component)n=function(t,e,n){var r=e.inlineTemplate?null:nc(e,n,!0);return"_c(".concat(t,",").concat(Qs(e,n)).concat(r?",".concat(r):"",")")}(t.component,t,e);else{var r=void 0,o=e.maybeComponent(t);(!t.plain||t.pre&&o)&&(r=Qs(t,e));var i=void 0,a=e.options.bindings;o&&a&&!1!==a.__isScriptSetup&&(i=function(t,e){var n=w(e),r=x(n),o=function(o){return t[e]===o?e:t[n]===o?n:t[r]===o?r:void 0},i=o("setup-const")||o("setup-reactive-const");if(i)return i;var a=o("setup-let")||o("setup-ref")||o("setup-maybe-ref");if(a)return a}(a,t.tag)),i||(i="'".concat(t.tag,"'"));var s=t.inlineTemplate?null:nc(t,e,!0);n="_c(".concat(i).concat(r?",".concat(r):"").concat(s?",".concat(s):"",")")}for(var c=0;c<e.transforms.length;c++)n=e.transforms[c](t,n);return n}return nc(t,e)||"void 0"}function Ws(t,e){t.staticProcessed=!0;var n=e.pre;return t.pre&&(e.pre=t.pre),e.staticRenderFns.push("with(this){return ".concat(qs(t,e),"}")),e.pre=n,"_m(".concat(e.staticRenderFns.length-1).concat(t.staticInFor?",true":"",")")}function Zs(t,e){if(t.onceProcessed=!0,t.if&&!t.ifProcessed)return Gs(t,e);if(t.staticInFor){for(var n="",r=t.parent;r;){if(r.for){n=r.key;break}r=r.parent}return n?"_o(".concat(qs(t,e),",").concat(e.onceId++,",").concat(n,")"):qs(t,e)}return Ws(t,e)}function Gs(t,e,n,r){return t.ifProcessed=!0,Xs(t.ifConditions.slice(),e,n,r)}function Xs(t,e,n,r){if(!t.length)return r||"_e()";var o=t.shift();return o.exp?"(".concat(o.exp,")?").concat(i(o.block),":").concat(Xs(t,e,n,r)):"".concat(i(o.block));function i(t){return n?n(t,e):t.once?Zs(t,e):qs(t,e)}}function Ys(t,e,n,r){var o=t.for,i=t.alias,a=t.iterator1?",".concat(t.iterator1):"",s=t.iterator2?",".concat(t.iterator2):"";return t.forProcessed=!0,"".concat(r||"_l","((").concat(o,"),")+"function(".concat(i).concat(a).concat(s,"){")+"return ".concat((n||qs)(t,e))+"})"}function Qs(t,e){var n="{",r=function(t,e){var n=t.directives;if(!n)return;var r,o,i,a,s="directives:[",c=!1;for(r=0,o=n.length;r<o;r++){i=n[r],a=!0;var u=e.directives[i.name];u&&(a=!!u(t,i,e.warn)),a&&(c=!0,s+='{name:"'.concat(i.name,'",rawName:"').concat(i.rawName,'"').concat(i.value?",value:(".concat(i.value,"),expression:").concat(JSON.stringify(i.value)):"").concat(i.arg?",arg:".concat(i.isDynamicArg?i.arg:'"'.concat(i.arg,'"')):"").concat(i.modifiers?",modifiers:".concat(JSON.stringify(i.modifiers)):"","},"))}if(c)return s.slice(0,-1)+"]"}(t,e);r&&(n+=r+","),t.key&&(n+="key:".concat(t.key,",")),t.ref&&(n+="ref:".concat(t.ref,",")),t.refInFor&&(n+="refInFor:true,"),t.pre&&(n+="pre:true,"),t.component&&(n+='tag:"'.concat(t.tag,'",'));for(var o=0;o<e.dataGenFns.length;o++)n+=e.dataGenFns[o](t);if(t.attrs&&(n+="attrs:".concat(ic(t.attrs),",")),t.props&&(n+="domProps:".concat(ic(t.props),",")),t.events&&(n+="".concat(Bs(t.events,!1),",")),t.nativeEvents&&(n+="".concat(Bs(t.nativeEvents,!0),",")),t.slotTarget&&!t.slotScope&&(n+="slot:".concat(t.slotTarget,",")),t.scopedSlots&&(n+="".concat(function(t,e,n){var r=t.for||Object.keys(e).some((function(t){var n=e[t];return n.slotTargetDynamic||n.if||n.for||tc(n)})),o=!!t.if;if(!r)for(var i=t.parent;i;){if(i.slotScope&&i.slotScope!==ps||i.for){r=!0;break}i.if&&(o=!0),i=i.parent}var a=Object.keys(e).map((function(t){return ec(e[t],n)})).join(",");return"scopedSlots:_u([".concat(a,"]").concat(r?",null,true":"").concat(!r&&o?",null,false,".concat(function(t){var e=5381,n=t.length;for(;n;)e=33*e^t.charCodeAt(--n);return e>>>0}(a)):"",")")}(t,t.scopedSlots,e),",")),t.model&&(n+="model:{value:".concat(t.model.value,",callback:").concat(t.model.callback,",expression:").concat(t.model.expression,"},")),t.inlineTemplate){var i=function(t,e){var n=t.children[0];if(n&&1===n.type){var r=Js(n,e.options);return"inlineTemplate:{render:function(){".concat(r.render,"},staticRenderFns:[").concat(r.staticRenderFns.map((function(t){return"function(){".concat(t,"}")})).join(","),"]}")}}(t,e);i&&(n+="".concat(i,","))}return n=n.replace(/,$/,"")+"}",t.dynamicAttrs&&(n="_b(".concat(n,',"').concat(t.tag,'",').concat(ic(t.dynamicAttrs),")")),t.wrapData&&(n=t.wrapData(n)),t.wrapListeners&&(n=t.wrapListeners(n)),n}function tc(t){return 1===t.type&&("slot"===t.tag||t.children.some(tc))}function ec(t,e){var n=t.attrsMap["slot-scope"];if(t.if&&!t.ifProcessed&&!n)return Gs(t,e,ec,"null");if(t.for&&!t.forProcessed)return Ys(t,e,ec);var r=t.slotScope===ps?"":String(t.slotScope),o="function(".concat(r,"){")+"return ".concat("template"===t.tag?t.if&&n?"(".concat(t.if,")?").concat(nc(t,e)||"undefined",":undefined"):nc(t,e)||"undefined":qs(t,e),"}"),i=r?"":",proxy:true";return"{key:".concat(t.slotTarget||'"default"',",fn:").concat(o).concat(i,"}")}function nc(t,e,n,r,o){var i=t.children;if(i.length){var a=i[0];if(1===i.length&&a.for&&"template"!==a.tag&&"slot"!==a.tag){var s=n?e.maybeComponent(a)?",1":",0":"";return"".concat((r||qs)(a,e)).concat(s)}var c=n?function(t,e){for(var n=0,r=0;r<t.length;r++){var o=t[r];if(1===o.type){if(rc(o)||o.ifConditions&&o.ifConditions.some((function(t){return rc(t.block)}))){n=2;break}(e(o)||o.ifConditions&&o.ifConditions.some((function(t){return e(t.block)})))&&(n=1)}}return n}(i,e.maybeComponent):0,u=o||oc;return"[".concat(i.map((function(t){return u(t,e)})).join(","),"]").concat(c?",".concat(c):"")}}function rc(t){return void 0!==t.for||"template"===t.tag||"slot"===t.tag}function oc(t,e){return 1===t.type?qs(t,e):3===t.type&&t.isComment?function(t){return"_e(".concat(JSON.stringify(t.text),")")}(t):function(t){return"_v(".concat(2===t.type?t.expression:ac(JSON.stringify(t.text)),")")}(t)}function ic(t){for(var e="",n="",r=0;r<t.length;r++){var o=t[r],i=ac(o.value);o.dynamic?n+="".concat(o.name,",").concat(i,","):e+='"'.concat(o.name,'":').concat(i,",")}return e="{".concat(e.slice(0,-1),"}"),n?"_d(".concat(e,",[").concat(n.slice(0,-1),"])"):e}function ac(t){return t.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}function sc(t,e){try{return new Function(t)}catch(n){return e.push({err:n,code:t}),j}}function cc(t){var e=Object.create(null);return function(n,r,o){(r=T({},r)).warn,delete r.warn;var i=r.delimiters?String(r.delimiters)+n:n;if(e[i])return e[i];var a=t(n,r),s={},c=[];return s.render=sc(a.render,c),s.staticRenderFns=a.staticRenderFns.map((function(t){return sc(t,c)})),e[i]=s}}new RegExp("\\b"+"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b")+"\\b"),new RegExp("\\b"+"delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b")+"\\s*\\([^\\)]*\\)");var uc,lc,fc=(uc=function(t,e){var n=hs(t.trim(),e);!1!==e.optimize&&Es(n,e);var r=Js(n,e);return{ast:n,render:r.render,staticRenderFns:r.staticRenderFns}},function(t){function e(e,n){var r=Object.create(t),o=[],i=[];if(n)for(var a in n.modules&&(r.modules=(t.modules||[]).concat(n.modules)),n.directives&&(r.directives=T(Object.create(t.directives||null),n.directives)),n)"modules"!==a&&"directives"!==a&&(r[a]=n[a]);r.warn=function(t,e,n){(n?i:o).push(t)};var s=uc(e.trim(),r);return s.errors=o,s.tips=i,s}return{compile:e,compileToFunctions:cc(e)}}),dc=fc(As).compileToFunctions;function pc(t){return(lc=lc||document.createElement("div")).innerHTML=t?'<a href="\n"/>':'<div a="\n"/>',lc.innerHTML.indexOf("&#10;")>0}var vc=!!J&&pc(!1),hc=!!J&&pc(!0),mc=b((function(t){var e=to(t);return e&&e.innerHTML})),gc=Cr.prototype.$mount;return Cr.prototype.$mount=function(t,e){if((t=t&&to(t))===document.body||t===document.documentElement)return this;var n=this.$options;if(!n.render){var r=n.template;if(r)if("string"==typeof r)"#"===r.charAt(0)&&(r=mc(r));else{if(!r.nodeType)return this;r=r.innerHTML}else t&&(r=function(t){if(t.outerHTML)return t.outerHTML;var e=document.createElement("div");return e.appendChild(t.cloneNode(!0)),e.innerHTML}(t));if(r){var o=dc(r,{outputSourceRange:!1,shouldDecodeNewlines:vc,shouldDecodeNewlinesForHref:hc,delimiters:n.delimiters,comments:n.comments},this),i=o.render,a=o.staticRenderFns;n.render=i,n.staticRenderFns=a}}return gc.call(this,t,e)},Cr.compile=dc,T(Cr,Fn),Cr.effect=function(t,e){var n=new Vn(ct,t,j,{sync:!0});e&&(n.update=function(){e((function(){return n.run()}))})},Cr}));
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"timers":5}],8:[function(require,module,exports){
(function (global,setImmediate){
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
'use strict';

const emptyObject = Object.freeze({});
const isArray = Array.isArray;
// These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.
function isUndef(v) {
    return v === undefined || v === null;
}
function isDef(v) {
    return v !== undefined && v !== null;
}
function isTrue(v) {
    return v === true;
}
function isFalse(v) {
    return v === false;
}
/**
 * Check if value is primitive.
 */
function isPrimitive(value) {
    return (typeof value === 'string' ||
        typeof value === 'number' ||
        // $flow-disable-line
        typeof value === 'symbol' ||
        typeof value === 'boolean');
}
function isFunction(value) {
    return typeof value === 'function';
}
/**
 * Quick object check - this is primarily used to tell
 * objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject(obj) {
    return obj !== null && typeof obj === 'object';
}
/**
 * Get the raw type string of a value, e.g., [object Object].
 */
const _toString = Object.prototype.toString;
function toRawType(value) {
    return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject(obj) {
    return _toString.call(obj) === '[object Object]';
}
function isRegExp(v) {
    return _toString.call(v) === '[object RegExp]';
}
/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex(val) {
    const n = parseFloat(String(val));
    return n >= 0 && Math.floor(n) === n && isFinite(val);
}
function isPromise(val) {
    return (isDef(val) &&
        typeof val.then === 'function' &&
        typeof val.catch === 'function');
}
/**
 * Convert a value to a string that is actually rendered.
 */
function toString(val) {
    return val == null
        ? ''
        : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
            ? JSON.stringify(val, null, 2)
            : String(val);
}
/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber(val) {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
}
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(',');
    for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? val => map[val.toLowerCase()] : val => map[val];
}
/**
 * Check if a tag is a built-in tag.
 */
const isBuiltInTag = makeMap('slot,component', true);
/**
 * Check if an attribute is a reserved attribute.
 */
const isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
/**
 * Remove an item from an array.
 */
function remove$2(arr, item) {
    const len = arr.length;
    if (len) {
        // fast path for the only / last item
        if (item === arr[len - 1]) {
            arr.length = len - 1;
            return;
        }
        const index = arr.indexOf(item);
        if (index > -1) {
            return arr.splice(index, 1);
        }
    }
}
/**
 * Check whether an object has the property.
 */
const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
    return hasOwnProperty.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */
function cached(fn) {
    const cache = Object.create(null);
    return function cachedFn(str) {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    };
}
/**
 * Camelize a hyphen-delimited string.
 */
const camelizeRE = /-(\w)/g;
const camelize = cached((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});
/**
 * Capitalize a string.
 */
const capitalize = cached((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * Hyphenate a camelCase string.
 */
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cached((str) => {
    return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */
/* istanbul ignore next */
function polyfillBind(fn, ctx) {
    function boundFn(a) {
        const l = arguments.length;
        return l
            ? l > 1
                ? fn.apply(ctx, arguments)
                : fn.call(ctx, a)
            : fn.call(ctx);
    }
    boundFn._length = fn.length;
    return boundFn;
}
function nativeBind(fn, ctx) {
    return fn.bind(ctx);
}
// @ts-expect-error bind cannot be `undefined`
const bind = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */
function toArray(list, start) {
    start = start || 0;
    let i = list.length - start;
    const ret = new Array(i);
    while (i--) {
        ret[i] = list[i + start];
    }
    return ret;
}
/**
 * Mix properties into target object.
 */
function extend(to, _from) {
    for (const key in _from) {
        to[key] = _from[key];
    }
    return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */
function toObject(arr) {
    const res = {};
    for (let i = 0; i < arr.length; i++) {
        if (arr[i]) {
            extend(res, arr[i]);
        }
    }
    return res;
}
/* eslint-disable no-unused-vars */
/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */
function noop(a, b, c) { }
/**
 * Always return false.
 */
const no = (a, b, c) => false;
/* eslint-enable no-unused-vars */
/**
 * Return the same value.
 */
const identity = (_) => _;
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual(a, b) {
    if (a === b)
        return true;
    const isObjectA = isObject(a);
    const isObjectB = isObject(b);
    if (isObjectA && isObjectB) {
        try {
            const isArrayA = Array.isArray(a);
            const isArrayB = Array.isArray(b);
            if (isArrayA && isArrayB) {
                return (a.length === b.length &&
                    a.every((e, i) => {
                        return looseEqual(e, b[i]);
                    }));
            }
            else if (a instanceof Date && b instanceof Date) {
                return a.getTime() === b.getTime();
            }
            else if (!isArrayA && !isArrayB) {
                const keysA = Object.keys(a);
                const keysB = Object.keys(b);
                return (keysA.length === keysB.length &&
                    keysA.every(key => {
                        return looseEqual(a[key], b[key]);
                    }));
            }
            else {
                /* istanbul ignore next */
                return false;
            }
        }
        catch (e) {
            /* istanbul ignore next */
            return false;
        }
    }
    else if (!isObjectA && !isObjectB) {
        return String(a) === String(b);
    }
    else {
        return false;
    }
}
/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */
function looseIndexOf(arr, val) {
    for (let i = 0; i < arr.length; i++) {
        if (looseEqual(arr[i], val))
            return i;
    }
    return -1;
}
/**
 * Ensure a function is called only once.
 */
function once(fn) {
    let called = false;
    return function () {
        if (!called) {
            called = true;
            fn.apply(this, arguments);
        }
    };
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#polyfill
function hasChanged(x, y) {
    if (x === y) {
        return x === 0 && 1 / x !== 1 / y;
    }
    else {
        return x === x || y === y;
    }
}

const SSR_ATTR = 'data-server-rendered';
const ASSET_TYPES = ['component', 'directive', 'filter'];
const LIFECYCLE_HOOKS = [
    'beforeCreate',
    'created',
    'beforeMount',
    'mounted',
    'beforeUpdate',
    'updated',
    'beforeDestroy',
    'destroyed',
    'activated',
    'deactivated',
    'errorCaptured',
    'serverPrefetch',
    'renderTracked',
    'renderTriggered'
];

var config = {
    /**
     * Option merge strategies (used in core/util/options)
     */
    // $flow-disable-line
    optionMergeStrategies: Object.create(null),
    /**
     * Whether to suppress warnings.
     */
    silent: false,
    /**
     * Show production mode tip message on boot?
     */
    productionTip: true,
    /**
     * Whether to enable devtools
     */
    devtools: true,
    /**
     * Whether to record perf
     */
    performance: false,
    /**
     * Error handler for watcher errors
     */
    errorHandler: null,
    /**
     * Warn handler for watcher warns
     */
    warnHandler: null,
    /**
     * Ignore certain custom elements
     */
    ignoredElements: [],
    /**
     * Custom user key aliases for v-on
     */
    // $flow-disable-line
    keyCodes: Object.create(null),
    /**
     * Check if a tag is reserved so that it cannot be registered as a
     * component. This is platform-dependent and may be overwritten.
     */
    isReservedTag: no,
    /**
     * Check if an attribute is reserved so that it cannot be used as a component
     * prop. This is platform-dependent and may be overwritten.
     */
    isReservedAttr: no,
    /**
     * Check if a tag is an unknown element.
     * Platform-dependent.
     */
    isUnknownElement: no,
    /**
     * Get the namespace of an element
     */
    getTagNamespace: noop,
    /**
     * Parse the real tag name for the specific platform.
     */
    parsePlatformTagName: identity,
    /**
     * Check if an attribute must be bound using property, e.g. value
     * Platform-dependent.
     */
    mustUseProp: no,
    /**
     * Perform updates asynchronously. Intended to be used by Vue Test Utils
     * This will significantly reduce performance if set to false.
     */
    async: true,
    /**
     * Exposed for legacy reasons
     */
    _lifecycleHooks: LIFECYCLE_HOOKS
};

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */
const unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
/**
 * Check if a string starts with $ or _
 */
function isReserved(str) {
    const c = (str + '').charCodeAt(0);
    return c === 0x24 || c === 0x5f;
}
/**
 * Define a property.
 */
function def(obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
        value: val,
        enumerable: !!enumerable,
        writable: true,
        configurable: true
    });
}
/**
 * Parse simple path.
 */
const bailRE = new RegExp(`[^${unicodeRegExp.source}.$_\\d]`);
function parsePath(path) {
    if (bailRE.test(path)) {
        return;
    }
    const segments = path.split('.');
    return function (obj) {
        for (let i = 0; i < segments.length; i++) {
            if (!obj)
                return;
            obj = obj[segments[i]];
        }
        return obj;
    };
}

// can we use __proto__?
const hasProto = '__proto__' in {};
// Browser environment sniffing
const inBrowser = typeof window !== 'undefined';
const UA = inBrowser && window.navigator.userAgent.toLowerCase();
const isIE = UA && /msie|trident/.test(UA);
const isIE9 = UA && UA.indexOf('msie 9.0') > 0;
const isEdge = UA && UA.indexOf('edge/') > 0;
UA && UA.indexOf('android') > 0;
const isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
UA && /chrome\/\d+/.test(UA) && !isEdge;
UA && /phantomjs/.test(UA);
const isFF = UA && UA.match(/firefox\/(\d+)/);
// Firefox has a "watch" function on Object.prototype...
// @ts-expect-error firebox support
const nativeWatch = {}.watch;
let supportsPassive = false;
if (inBrowser) {
    try {
        const opts = {};
        Object.defineProperty(opts, 'passive', {
            get() {
                /* istanbul ignore next */
                supportsPassive = true;
            }
        }); // https://github.com/facebook/flow/issues/285
        window.addEventListener('test-passive', null, opts);
    }
    catch (e) { }
}
// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
let _isServer;
const isServerRendering = () => {
    if (_isServer === undefined) {
        /* istanbul ignore if */
        if (!inBrowser && typeof global !== 'undefined') {
            // detect presence of vue-server-renderer and avoid
            // Webpack shimming the process
            _isServer =
                global['process'] && global['process'].env.VUE_ENV === 'server';
        }
        else {
            _isServer = false;
        }
    }
    return _isServer;
};
// detect devtools
const devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
/* istanbul ignore next */
function isNative(Ctor) {
    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}
const hasSymbol = typeof Symbol !== 'undefined' &&
    isNative(Symbol) &&
    typeof Reflect !== 'undefined' &&
    isNative(Reflect.ownKeys);
let _Set; // $flow-disable-line
/* istanbul ignore if */ if (typeof Set !== 'undefined' && isNative(Set)) {
    // use native Set when available.
    _Set = Set;
}
else {
    // a non-standard Set polyfill that only works with primitive keys.
    _Set = class Set {
        constructor() {
            this.set = Object.create(null);
        }
        has(key) {
            return this.set[key] === true;
        }
        add(key) {
            this.set[key] = true;
        }
        clear() {
            this.set = Object.create(null);
        }
    };
}

let currentInstance = null;
/**
 * This is exposed for compatibility with v3 (e.g. some functions in VueUse
 * relies on it). Do not use this internally, just use `currentInstance`.
 *
 * @internal this function needs manual type declaration because it relies
 * on previously manually authored types from Vue 2
 */
function getCurrentInstance() {
    return currentInstance && { proxy: currentInstance };
}
/**
 * @internal
 */
function setCurrentInstance(vm = null) {
    if (!vm)
        currentInstance && currentInstance._scope.off();
    currentInstance = vm;
    vm && vm._scope.on();
}

/**
 * @internal
 */
class VNode {
    constructor(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
        this.tag = tag;
        this.data = data;
        this.children = children;
        this.text = text;
        this.elm = elm;
        this.ns = undefined;
        this.context = context;
        this.fnContext = undefined;
        this.fnOptions = undefined;
        this.fnScopeId = undefined;
        this.key = data && data.key;
        this.componentOptions = componentOptions;
        this.componentInstance = undefined;
        this.parent = undefined;
        this.raw = false;
        this.isStatic = false;
        this.isRootInsert = true;
        this.isComment = false;
        this.isCloned = false;
        this.isOnce = false;
        this.asyncFactory = asyncFactory;
        this.asyncMeta = undefined;
        this.isAsyncPlaceholder = false;
    }
    // DEPRECATED: alias for componentInstance for backwards compat.
    /* istanbul ignore next */
    get child() {
        return this.componentInstance;
    }
}
const createEmptyVNode = (text = '') => {
    const node = new VNode();
    node.text = text;
    node.isComment = true;
    return node;
};
function createTextVNode(val) {
    return new VNode(undefined, undefined, undefined, String(val));
}
// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode(vnode) {
    const cloned = new VNode(vnode.tag, vnode.data, 
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
    cloned.ns = vnode.ns;
    cloned.isStatic = vnode.isStatic;
    cloned.key = vnode.key;
    cloned.isComment = vnode.isComment;
    cloned.fnContext = vnode.fnContext;
    cloned.fnOptions = vnode.fnOptions;
    cloned.fnScopeId = vnode.fnScopeId;
    cloned.asyncMeta = vnode.asyncMeta;
    cloned.isCloned = true;
    return cloned;
}

let uid$2 = 0;
const pendingCleanupDeps = [];
const cleanupDeps = () => {
    for (let i = 0; i < pendingCleanupDeps.length; i++) {
        const dep = pendingCleanupDeps[i];
        dep.subs = dep.subs.filter(s => s);
        dep._pending = false;
    }
    pendingCleanupDeps.length = 0;
};
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 * @internal
 */
class Dep {
    constructor() {
        // pending subs cleanup
        this._pending = false;
        this.id = uid$2++;
        this.subs = [];
    }
    addSub(sub) {
        this.subs.push(sub);
    }
    removeSub(sub) {
        // #12696 deps with massive amount of subscribers are extremely slow to
        // clean up in Chromium
        // to workaround this, we unset the sub for now, and clear them on
        // next scheduler flush.
        this.subs[this.subs.indexOf(sub)] = null;
        if (!this._pending) {
            this._pending = true;
            pendingCleanupDeps.push(this);
        }
    }
    depend(info) {
        if (Dep.target) {
            Dep.target.addDep(this);
            if (info && Dep.target.onTrack) {
                Dep.target.onTrack(Object.assign({ effect: Dep.target }, info));
            }
        }
    }
    notify(info) {
        // stabilize the subscriber list first
        const subs = this.subs.filter(s => s);
        if (!config.async) {
            // subs aren't sorted in scheduler if not running async
            // we need to sort them now to make sure they fire in correct
            // order
            subs.sort((a, b) => a.id - b.id);
        }
        for (let i = 0, l = subs.length; i < l; i++) {
            const sub = subs[i];
            if (info) {
                sub.onTrigger &&
                    sub.onTrigger(Object.assign({ effect: subs[i] }, info));
            }
            sub.update();
        }
    }
}
// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
Dep.target = null;
const targetStack = [];
function pushTarget(target) {
    targetStack.push(target);
    Dep.target = target;
}
function popTarget() {
    targetStack.pop();
    Dep.target = targetStack[targetStack.length - 1];
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */
const arrayProto = Array.prototype;
const arrayMethods = Object.create(arrayProto);
const methodsToPatch = [
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
];
/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
    // cache original method
    const original = arrayProto[method];
    def(arrayMethods, method, function mutator(...args) {
        const result = original.apply(this, args);
        const ob = this.__ob__;
        let inserted;
        switch (method) {
            case 'push':
            case 'unshift':
                inserted = args;
                break;
            case 'splice':
                inserted = args.slice(2);
                break;
        }
        if (inserted)
            ob.observeArray(inserted);
        // notify change
        {
            ob.dep.notify({
                type: "array mutation" /* TriggerOpTypes.ARRAY_MUTATION */,
                target: this,
                key: method
            });
        }
        return result;
    });
});

const arrayKeys = Object.getOwnPropertyNames(arrayMethods);
const NO_INIITIAL_VALUE = {};
/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
let shouldObserve = true;
function toggleObserving(value) {
    shouldObserve = value;
}
// ssr mock dep
const mockDep = {
    notify: noop,
    depend: noop,
    addSub: noop,
    removeSub: noop
};
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
class Observer {
    constructor(value, shallow = false, mock = false) {
        this.value = value;
        this.shallow = shallow;
        this.mock = mock;
        // this.value = value
        this.dep = mock ? mockDep : new Dep();
        this.vmCount = 0;
        def(value, '__ob__', this);
        if (isArray(value)) {
            if (!mock) {
                if (hasProto) {
                    value.__proto__ = arrayMethods;
                    /* eslint-enable no-proto */
                }
                else {
                    for (let i = 0, l = arrayKeys.length; i < l; i++) {
                        const key = arrayKeys[i];
                        def(value, key, arrayMethods[key]);
                    }
                }
            }
            if (!shallow) {
                this.observeArray(value);
            }
        }
        else {
            /**
             * Walk through all properties and convert them into
             * getter/setters. This method should only be called when
             * value type is Object.
             */
            const keys = Object.keys(value);
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                defineReactive(value, key, NO_INIITIAL_VALUE, undefined, shallow, mock);
            }
        }
    }
    /**
     * Observe a list of Array items.
     */
    observeArray(value) {
        for (let i = 0, l = value.length; i < l; i++) {
            observe(value[i], false, this.mock);
        }
    }
}
// helpers
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe(value, shallow, ssrMockReactivity) {
    if (value && hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
        return value.__ob__;
    }
    if (shouldObserve &&
        (ssrMockReactivity || !isServerRendering()) &&
        (isArray(value) || isPlainObject(value)) &&
        Object.isExtensible(value) &&
        !value.__v_skip /* ReactiveFlags.SKIP */ &&
        !isRef(value) &&
        !(value instanceof VNode)) {
        return new Observer(value, shallow, ssrMockReactivity);
    }
}
/**
 * Define a reactive property on an Object.
 */
function defineReactive(obj, key, val, customSetter, shallow, mock) {
    const dep = new Dep();
    const property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
        return;
    }
    // cater for pre-defined getter/setters
    const getter = property && property.get;
    const setter = property && property.set;
    if ((!getter || setter) &&
        (val === NO_INIITIAL_VALUE || arguments.length === 2)) {
        val = obj[key];
    }
    let childOb = !shallow && observe(val, false, mock);
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter() {
            const value = getter ? getter.call(obj) : val;
            if (Dep.target) {
                {
                    dep.depend({
                        target: obj,
                        type: "get" /* TrackOpTypes.GET */,
                        key
                    });
                }
                if (childOb) {
                    childOb.dep.depend();
                    if (isArray(value)) {
                        dependArray(value);
                    }
                }
            }
            return isRef(value) && !shallow ? value.value : value;
        },
        set: function reactiveSetter(newVal) {
            const value = getter ? getter.call(obj) : val;
            if (!hasChanged(value, newVal)) {
                return;
            }
            if (customSetter) {
                customSetter();
            }
            if (setter) {
                setter.call(obj, newVal);
            }
            else if (getter) {
                // #7981: for accessor properties without setter
                return;
            }
            else if (!shallow && isRef(value) && !isRef(newVal)) {
                value.value = newVal;
                return;
            }
            else {
                val = newVal;
            }
            childOb = !shallow && observe(newVal, false, mock);
            {
                dep.notify({
                    type: "set" /* TriggerOpTypes.SET */,
                    target: obj,
                    key,
                    newValue: newVal,
                    oldValue: value
                });
            }
        }
    });
    return dep;
}
function set(target, key, val) {
    if ((isUndef(target) || isPrimitive(target))) {
        warn(`Cannot set reactive property on undefined, null, or primitive value: ${target}`);
    }
    if (isReadonly(target)) {
        warn(`Set operation on key "${key}" failed: target is readonly.`);
        return;
    }
    const ob = target.__ob__;
    if (isArray(target) && isValidArrayIndex(key)) {
        target.length = Math.max(target.length, key);
        target.splice(key, 1, val);
        // when mocking for SSR, array methods are not hijacked
        if (ob && !ob.shallow && ob.mock) {
            observe(val, false, true);
        }
        return val;
    }
    if (key in target && !(key in Object.prototype)) {
        target[key] = val;
        return val;
    }
    if (target._isVue || (ob && ob.vmCount)) {
        warn('Avoid adding reactive properties to a Vue instance or its root $data ' +
                'at runtime - declare it upfront in the data option.');
        return val;
    }
    if (!ob) {
        target[key] = val;
        return val;
    }
    defineReactive(ob.value, key, val, undefined, ob.shallow, ob.mock);
    {
        ob.dep.notify({
            type: "add" /* TriggerOpTypes.ADD */,
            target: target,
            key,
            newValue: val,
            oldValue: undefined
        });
    }
    return val;
}
function del(target, key) {
    if ((isUndef(target) || isPrimitive(target))) {
        warn(`Cannot delete reactive property on undefined, null, or primitive value: ${target}`);
    }
    if (isArray(target) && isValidArrayIndex(key)) {
        target.splice(key, 1);
        return;
    }
    const ob = target.__ob__;
    if (target._isVue || (ob && ob.vmCount)) {
        warn('Avoid deleting properties on a Vue instance or its root $data ' +
                '- just set it to null.');
        return;
    }
    if (isReadonly(target)) {
        warn(`Delete operation on key "${key}" failed: target is readonly.`);
        return;
    }
    if (!hasOwn(target, key)) {
        return;
    }
    delete target[key];
    if (!ob) {
        return;
    }
    {
        ob.dep.notify({
            type: "delete" /* TriggerOpTypes.DELETE */,
            target: target,
            key
        });
    }
}
/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray(value) {
    for (let e, i = 0, l = value.length; i < l; i++) {
        e = value[i];
        if (e && e.__ob__) {
            e.__ob__.dep.depend();
        }
        if (isArray(e)) {
            dependArray(e);
        }
    }
}

function reactive(target) {
    makeReactive(target, false);
    return target;
}
/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */
function shallowReactive(target) {
    makeReactive(target, true);
    def(target, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, true);
    return target;
}
function makeReactive(target, shallow) {
    // if trying to observe a readonly proxy, return the readonly version.
    if (!isReadonly(target)) {
        {
            if (isArray(target)) {
                warn(`Avoid using Array as root value for ${shallow ? `shallowReactive()` : `reactive()`} as it cannot be tracked in watch() or watchEffect(). Use ${shallow ? `shallowRef()` : `ref()`} instead. This is a Vue-2-only limitation.`);
            }
            const existingOb = target && target.__ob__;
            if (existingOb && existingOb.shallow !== shallow) {
                warn(`Target is already a ${existingOb.shallow ? `` : `non-`}shallow reactive object, and cannot be converted to ${shallow ? `` : `non-`}shallow.`);
            }
        }
        const ob = observe(target, shallow, isServerRendering() /* ssr mock reactivity */);
        if (!ob) {
            if (target == null || isPrimitive(target)) {
                warn(`value cannot be made reactive: ${String(target)}`);
            }
            if (isCollectionType(target)) {
                warn(`Vue 2 does not support reactive collection types such as Map or Set.`);
            }
        }
    }
}
function isReactive(value) {
    if (isReadonly(value)) {
        return isReactive(value["__v_raw" /* ReactiveFlags.RAW */]);
    }
    return !!(value && value.__ob__);
}
function isShallow(value) {
    return !!(value && value.__v_isShallow);
}
function isReadonly(value) {
    return !!(value && value.__v_isReadonly);
}
function isProxy(value) {
    return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
    const raw = observed && observed["__v_raw" /* ReactiveFlags.RAW */];
    return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
    // non-extensible objects won't be observed anyway
    if (Object.isExtensible(value)) {
        def(value, "__v_skip" /* ReactiveFlags.SKIP */, true);
    }
    return value;
}
/**
 * @internal
 */
function isCollectionType(value) {
    const type = toRawType(value);
    return (type === 'Map' || type === 'WeakMap' || type === 'Set' || type === 'WeakSet');
}

/**
 * @internal
 */
const RefFlag = `__v_isRef`;
function isRef(r) {
    return !!(r && r.__v_isRef === true);
}
function ref$1(value) {
    return createRef(value, false);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
        return rawValue;
    }
    const ref = {};
    def(ref, RefFlag, true);
    def(ref, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, shallow);
    def(ref, 'dep', defineReactive(ref, 'value', rawValue, null, shallow, isServerRendering()));
    return ref;
}
function triggerRef(ref) {
    if (!ref.dep) {
        warn(`received object is not a triggerable ref.`);
    }
    {
        ref.dep &&
            ref.dep.notify({
                type: "set" /* TriggerOpTypes.SET */,
                target: ref,
                key: 'value'
            });
    }
}
function unref(ref) {
    return isRef(ref) ? ref.value : ref;
}
function proxyRefs(objectWithRefs) {
    if (isReactive(objectWithRefs)) {
        return objectWithRefs;
    }
    const proxy = {};
    const keys = Object.keys(objectWithRefs);
    for (let i = 0; i < keys.length; i++) {
        proxyWithRefUnwrap(proxy, objectWithRefs, keys[i]);
    }
    return proxy;
}
function proxyWithRefUnwrap(target, source, key) {
    Object.defineProperty(target, key, {
        enumerable: true,
        configurable: true,
        get: () => {
            const val = source[key];
            if (isRef(val)) {
                return val.value;
            }
            else {
                const ob = val && val.__ob__;
                if (ob)
                    ob.dep.depend();
                return val;
            }
        },
        set: value => {
            const oldValue = source[key];
            if (isRef(oldValue) && !isRef(value)) {
                oldValue.value = value;
            }
            else {
                source[key] = value;
            }
        }
    });
}
function customRef(factory) {
    const dep = new Dep();
    const { get, set } = factory(() => {
        {
            dep.depend({
                target: ref,
                type: "get" /* TrackOpTypes.GET */,
                key: 'value'
            });
        }
    }, () => {
        {
            dep.notify({
                target: ref,
                type: "set" /* TriggerOpTypes.SET */,
                key: 'value'
            });
        }
    });
    const ref = {
        get value() {
            return get();
        },
        set value(newVal) {
            set(newVal);
        }
    };
    def(ref, RefFlag, true);
    return ref;
}
function toRefs(object) {
    if (!isReactive(object)) {
        warn(`toRefs() expects a reactive object but received a plain one.`);
    }
    const ret = isArray(object) ? new Array(object.length) : {};
    for (const key in object) {
        ret[key] = toRef(object, key);
    }
    return ret;
}
function toRef(object, key, defaultValue) {
    const val = object[key];
    if (isRef(val)) {
        return val;
    }
    const ref = {
        get value() {
            const val = object[key];
            return val === undefined ? defaultValue : val;
        },
        set value(newVal) {
            object[key] = newVal;
        }
    };
    def(ref, RefFlag, true);
    return ref;
}

const rawToReadonlyFlag = `__v_rawToReadonly`;
const rawToShallowReadonlyFlag = `__v_rawToShallowReadonly`;
function readonly(target) {
    return createReadonly(target, false);
}
function createReadonly(target, shallow) {
    if (!isPlainObject(target)) {
        {
            if (isArray(target)) {
                warn(`Vue 2 does not support readonly arrays.`);
            }
            else if (isCollectionType(target)) {
                warn(`Vue 2 does not support readonly collection types such as Map or Set.`);
            }
            else {
                warn(`value cannot be made readonly: ${typeof target}`);
            }
        }
        return target;
    }
    if (!Object.isExtensible(target)) {
        warn(`Vue 2 does not support creating readonly proxy for non-extensible object.`);
    }
    // already a readonly object
    if (isReadonly(target)) {
        return target;
    }
    // already has a readonly proxy
    const existingFlag = shallow ? rawToShallowReadonlyFlag : rawToReadonlyFlag;
    const existingProxy = target[existingFlag];
    if (existingProxy) {
        return existingProxy;
    }
    const proxy = Object.create(Object.getPrototypeOf(target));
    def(target, existingFlag, proxy);
    def(proxy, "__v_isReadonly" /* ReactiveFlags.IS_READONLY */, true);
    def(proxy, "__v_raw" /* ReactiveFlags.RAW */, target);
    if (isRef(target)) {
        def(proxy, RefFlag, true);
    }
    if (shallow || isShallow(target)) {
        def(proxy, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, true);
    }
    const keys = Object.keys(target);
    for (let i = 0; i < keys.length; i++) {
        defineReadonlyProperty(proxy, target, keys[i], shallow);
    }
    return proxy;
}
function defineReadonlyProperty(proxy, target, key, shallow) {
    Object.defineProperty(proxy, key, {
        enumerable: true,
        configurable: true,
        get() {
            const val = target[key];
            return shallow || !isPlainObject(val) ? val : readonly(val);
        },
        set() {
            warn(`Set operation on key "${key}" failed: target is readonly.`);
        }
    });
}
/**
 * Returns a reactive-copy of the original object, where only the root level
 * properties are readonly, and does NOT unwrap refs nor recursively convert
 * returned properties.
 * This is used for creating the props proxy object for stateful components.
 */
function shallowReadonly(target) {
    return createReadonly(target, true);
}

function computed(getterOrOptions, debugOptions) {
    let getter;
    let setter;
    const onlyGetter = isFunction(getterOrOptions);
    if (onlyGetter) {
        getter = getterOrOptions;
        setter = () => {
                warn('Write operation failed: computed value is readonly');
            }
            ;
    }
    else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    const watcher = isServerRendering()
        ? null
        : new Watcher(currentInstance, getter, noop, { lazy: true });
    if (watcher && debugOptions) {
        watcher.onTrack = debugOptions.onTrack;
        watcher.onTrigger = debugOptions.onTrigger;
    }
    const ref = {
        // some libs rely on the presence effect for checking computed refs
        // from normal refs, but the implementation doesn't matter
        effect: watcher,
        get value() {
            if (watcher) {
                if (watcher.dirty) {
                    watcher.evaluate();
                }
                if (Dep.target) {
                    if (Dep.target.onTrack) {
                        Dep.target.onTrack({
                            effect: Dep.target,
                            target: ref,
                            type: "get" /* TrackOpTypes.GET */,
                            key: 'value'
                        });
                    }
                    watcher.depend();
                }
                return watcher.value;
            }
            else {
                return getter();
            }
        },
        set value(newVal) {
            setter(newVal);
        }
    };
    def(ref, RefFlag, true);
    def(ref, "__v_isReadonly" /* ReactiveFlags.IS_READONLY */, onlyGetter);
    return ref;
}

const WATCHER = `watcher`;
const WATCHER_CB = `${WATCHER} callback`;
const WATCHER_GETTER = `${WATCHER} getter`;
const WATCHER_CLEANUP = `${WATCHER} cleanup`;
// Simple effect.
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
    return doWatch(effect, null, (Object.assign(Object.assign({}, options), { flush: 'post' }) ));
}
function watchSyncEffect(effect, options) {
    return doWatch(effect, null, (Object.assign(Object.assign({}, options), { flush: 'sync' }) ));
}
// initial value for watchers to trigger on undefined initial values
const INITIAL_WATCHER_VALUE = {};
// implementation
function watch(source, cb, options) {
    if (typeof cb !== 'function') {
        warn(`\`watch(fn, options?)\` signature has been moved to a separate API. ` +
            `Use \`watchEffect(fn, options?)\` instead. \`watch\` now only ` +
            `supports \`watch(source, cb, options?) signature.`);
    }
    return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush = 'pre', onTrack, onTrigger } = emptyObject) {
    if (!cb) {
        if (immediate !== undefined) {
            warn(`watch() "immediate" option is only respected when using the ` +
                `watch(source, callback, options?) signature.`);
        }
        if (deep !== undefined) {
            warn(`watch() "deep" option is only respected when using the ` +
                `watch(source, callback, options?) signature.`);
        }
    }
    const warnInvalidSource = (s) => {
        warn(`Invalid watch source: ${s}. A watch source can only be a getter/effect ` +
            `function, a ref, a reactive object, or an array of these types.`);
    };
    const instance = currentInstance;
    const call = (fn, type, args = null) => invokeWithErrorHandling(fn, null, args, instance, type);
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
    }
    else if (isReactive(source)) {
        getter = () => {
            source.__ob__.dep.depend();
            return source;
        };
        deep = true;
    }
    else if (isArray(source)) {
        isMultiSource = true;
        forceTrigger = source.some(s => isReactive(s) || isShallow(s));
        getter = () => source.map(s => {
            if (isRef(s)) {
                return s.value;
            }
            else if (isReactive(s)) {
                return traverse(s);
            }
            else if (isFunction(s)) {
                return call(s, WATCHER_GETTER);
            }
            else {
                warnInvalidSource(s);
            }
        });
    }
    else if (isFunction(source)) {
        if (cb) {
            // getter with cb
            getter = () => call(source, WATCHER_GETTER);
        }
        else {
            // no cb -> simple effect
            getter = () => {
                if (instance && instance._isDestroyed) {
                    return;
                }
                if (cleanup) {
                    cleanup();
                }
                return call(source, WATCHER, [onCleanup]);
            };
        }
    }
    else {
        getter = noop;
        warnInvalidSource(source);
    }
    if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn) => {
        cleanup = watcher.onStop = () => {
            call(fn, WATCHER_CLEANUP);
        };
    };
    // in SSR there is no need to setup an actual effect, and it should be noop
    // unless it's eager
    if (isServerRendering()) {
        // we will also not call the invalidate callback (+ runner is not set up)
        onCleanup = noop;
        if (!cb) {
            getter();
        }
        else if (immediate) {
            call(cb, WATCHER_CB, [
                getter(),
                isMultiSource ? [] : undefined,
                onCleanup
            ]);
        }
        return noop;
    }
    const watcher = new Watcher(currentInstance, getter, noop, {
        lazy: true
    });
    watcher.noRecurse = !cb;
    let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
    // overwrite default run
    watcher.run = () => {
        if (!watcher.active) {
            return;
        }
        if (cb) {
            // watch(source, cb)
            const newValue = watcher.get();
            if (deep ||
                forceTrigger ||
                (isMultiSource
                    ? newValue.some((v, i) => hasChanged(v, oldValue[i]))
                    : hasChanged(newValue, oldValue))) {
                // cleanup before running cb again
                if (cleanup) {
                    cleanup();
                }
                call(cb, WATCHER_CB, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
                    onCleanup
                ]);
                oldValue = newValue;
            }
        }
        else {
            // watchEffect
            watcher.get();
        }
    };
    if (flush === 'sync') {
        watcher.update = watcher.run;
    }
    else if (flush === 'post') {
        watcher.post = true;
        watcher.update = () => queueWatcher(watcher);
    }
    else {
        // pre
        watcher.update = () => {
            if (instance && instance === currentInstance && !instance._isMounted) {
                // pre-watcher triggered before
                const buffer = instance._preWatchers || (instance._preWatchers = []);
                if (buffer.indexOf(watcher) < 0)
                    buffer.push(watcher);
            }
            else {
                queueWatcher(watcher);
            }
        };
    }
    {
        watcher.onTrack = onTrack;
        watcher.onTrigger = onTrigger;
    }
    // initial run
    if (cb) {
        if (immediate) {
            watcher.run();
        }
        else {
            oldValue = watcher.get();
        }
    }
    else if (flush === 'post' && instance) {
        instance.$once('hook:mounted', () => watcher.get());
    }
    else {
        watcher.get();
    }
    return () => {
        watcher.teardown();
    };
}

let activeEffectScope;
class EffectScope {
    constructor(detached = false) {
        this.detached = detached;
        /**
         * @internal
         */
        this.active = true;
        /**
         * @internal
         */
        this.effects = [];
        /**
         * @internal
         */
        this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
            this.index =
                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
        }
    }
    run(fn) {
        if (this.active) {
            const currentEffectScope = activeEffectScope;
            try {
                activeEffectScope = this;
                return fn();
            }
            finally {
                activeEffectScope = currentEffectScope;
            }
        }
        else {
            warn(`cannot run an inactive effect scope.`);
        }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
        activeEffectScope = this;
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
        activeEffectScope = this.parent;
    }
    stop(fromParent) {
        if (this.active) {
            let i, l;
            for (i = 0, l = this.effects.length; i < l; i++) {
                this.effects[i].teardown();
            }
            for (i = 0, l = this.cleanups.length; i < l; i++) {
                this.cleanups[i]();
            }
            if (this.scopes) {
                for (i = 0, l = this.scopes.length; i < l; i++) {
                    this.scopes[i].stop(true);
                }
            }
            // nested scope, dereference from parent to avoid memory leaks
            if (!this.detached && this.parent && !fromParent) {
                // optimized O(1) removal
                const last = this.parent.scopes.pop();
                if (last && last !== this) {
                    this.parent.scopes[this.index] = last;
                    last.index = this.index;
                }
            }
            this.parent = undefined;
            this.active = false;
        }
    }
}
function effectScope(detached) {
    return new EffectScope(detached);
}
/**
 * @internal
 */
function recordEffectScope(effect, scope = activeEffectScope) {
    if (scope && scope.active) {
        scope.effects.push(effect);
    }
}
function getCurrentScope() {
    return activeEffectScope;
}
function onScopeDispose(fn) {
    if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn);
    }
    else {
        warn(`onScopeDispose() is called when there is no active effect scope` +
            ` to be associated with.`);
    }
}

function provide(key, value) {
    if (!currentInstance) {
        {
            warn(`provide() can only be used inside setup().`);
        }
    }
    else {
        // TS doesn't allow symbol as index type
        resolveProvided(currentInstance)[key] = value;
    }
}
function resolveProvided(vm) {
    // by default an instance inherits its parent's provides object
    // but when it needs to provide values of its own, it creates its
    // own provides object using parent provides object as prototype.
    // this way in `inject` we can simply look up injections from direct
    // parent and let the prototype chain do the work.
    const existing = vm._provided;
    const parentProvides = vm.$parent && vm.$parent._provided;
    if (parentProvides === existing) {
        return (vm._provided = Object.create(parentProvides));
    }
    else {
        return existing;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
    // fallback to `currentRenderingInstance` so that this can be called in
    // a functional component
    const instance = currentInstance;
    if (instance) {
        // #2400
        // to support `app.use` plugins,
        // fallback to appContext's `provides` if the instance is at root
        const provides = instance.$parent && instance.$parent._provided;
        if (provides && key in provides) {
            // TS doesn't allow symbol as index type
            return provides[key];
        }
        else if (arguments.length > 1) {
            return treatDefaultAsFactory && isFunction(defaultValue)
                ? defaultValue.call(instance)
                : defaultValue;
        }
        else {
            warn(`injection "${String(key)}" not found.`);
        }
    }
    else {
        warn(`inject() can only be used inside setup() or functional components.`);
    }
}

const normalizeEvent = cached((name) => {
    const passive = name.charAt(0) === '&';
    name = passive ? name.slice(1) : name;
    const once = name.charAt(0) === '~'; // Prefixed last, checked first
    name = once ? name.slice(1) : name;
    const capture = name.charAt(0) === '!';
    name = capture ? name.slice(1) : name;
    return {
        name,
        once,
        capture,
        passive
    };
});
function createFnInvoker(fns, vm) {
    function invoker() {
        const fns = invoker.fns;
        if (isArray(fns)) {
            const cloned = fns.slice();
            for (let i = 0; i < cloned.length; i++) {
                invokeWithErrorHandling(cloned[i], null, arguments, vm, `v-on handler`);
            }
        }
        else {
            // return handler return value for single handlers
            return invokeWithErrorHandling(fns, null, arguments, vm, `v-on handler`);
        }
    }
    invoker.fns = fns;
    return invoker;
}
function updateListeners(on, oldOn, add, remove, createOnceHandler, vm) {
    let name, cur, old, event;
    for (name in on) {
        cur = on[name];
        old = oldOn[name];
        event = normalizeEvent(name);
        if (isUndef(cur)) {
            warn(`Invalid handler for event "${event.name}": got ` + String(cur), vm);
        }
        else if (isUndef(old)) {
            if (isUndef(cur.fns)) {
                cur = on[name] = createFnInvoker(cur, vm);
            }
            if (isTrue(event.once)) {
                cur = on[name] = createOnceHandler(event.name, cur, event.capture);
            }
            add(event.name, cur, event.capture, event.passive, event.params);
        }
        else if (cur !== old) {
            old.fns = cur;
            on[name] = old;
        }
    }
    for (name in oldOn) {
        if (isUndef(on[name])) {
            event = normalizeEvent(name);
            remove(event.name, oldOn[name], event.capture);
        }
    }
}

function mergeVNodeHook(def, hookKey, hook) {
    if (def instanceof VNode) {
        def = def.data.hook || (def.data.hook = {});
    }
    let invoker;
    const oldHook = def[hookKey];
    function wrappedHook() {
        hook.apply(this, arguments);
        // important: remove merged hook to ensure it's called only once
        // and prevent memory leak
        remove$2(invoker.fns, wrappedHook);
    }
    if (isUndef(oldHook)) {
        // no existing hook
        invoker = createFnInvoker([wrappedHook]);
    }
    else {
        /* istanbul ignore if */
        if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
            // already a merged invoker
            invoker = oldHook;
            invoker.fns.push(wrappedHook);
        }
        else {
            // existing plain hook
            invoker = createFnInvoker([oldHook, wrappedHook]);
        }
    }
    invoker.merged = true;
    def[hookKey] = invoker;
}

function extractPropsFromVNodeData(data, Ctor, tag) {
    // we are only extracting raw values here.
    // validation and default values are handled in the child
    // component itself.
    const propOptions = Ctor.options.props;
    if (isUndef(propOptions)) {
        return;
    }
    const res = {};
    const { attrs, props } = data;
    if (isDef(attrs) || isDef(props)) {
        for (const key in propOptions) {
            const altKey = hyphenate(key);
            {
                const keyInLowerCase = key.toLowerCase();
                if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
                    tip(`Prop "${keyInLowerCase}" is passed to component ` +
                        `${formatComponentName(
                        // @ts-expect-error tag is string
                        tag || Ctor)}, but the declared prop name is` +
                        ` "${key}". ` +
                        `Note that HTML attributes are case-insensitive and camelCased ` +
                        `props need to use their kebab-case equivalents when using in-DOM ` +
                        `templates. You should probably use "${altKey}" instead of "${key}".`);
                }
            }
            checkProp(res, props, key, altKey, true) ||
                checkProp(res, attrs, key, altKey, false);
        }
    }
    return res;
}
function checkProp(res, hash, key, altKey, preserve) {
    if (isDef(hash)) {
        if (hasOwn(hash, key)) {
            res[key] = hash[key];
            if (!preserve) {
                delete hash[key];
            }
            return true;
        }
        else if (hasOwn(hash, altKey)) {
            res[key] = hash[altKey];
            if (!preserve) {
                delete hash[altKey];
            }
            return true;
        }
    }
    return false;
}

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:
// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren(children) {
    for (let i = 0; i < children.length; i++) {
        if (isArray(children[i])) {
            return Array.prototype.concat.apply([], children);
        }
    }
    return children;
}
// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren(children) {
    return isPrimitive(children)
        ? [createTextVNode(children)]
        : isArray(children)
            ? normalizeArrayChildren(children)
            : undefined;
}
function isTextNode(node) {
    return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}
function normalizeArrayChildren(children, nestedIndex) {
    const res = [];
    let i, c, lastIndex, last;
    for (i = 0; i < children.length; i++) {
        c = children[i];
        if (isUndef(c) || typeof c === 'boolean')
            continue;
        lastIndex = res.length - 1;
        last = res[lastIndex];
        //  nested
        if (isArray(c)) {
            if (c.length > 0) {
                c = normalizeArrayChildren(c, `${nestedIndex || ''}_${i}`);
                // merge adjacent text nodes
                if (isTextNode(c[0]) && isTextNode(last)) {
                    res[lastIndex] = createTextVNode(last.text + c[0].text);
                    c.shift();
                }
                res.push.apply(res, c);
            }
        }
        else if (isPrimitive(c)) {
            if (isTextNode(last)) {
                // merge adjacent text nodes
                // this is necessary for SSR hydration because text nodes are
                // essentially merged when rendered to HTML strings
                res[lastIndex] = createTextVNode(last.text + c);
            }
            else if (c !== '') {
                // convert primitive to vnode
                res.push(createTextVNode(c));
            }
        }
        else {
            if (isTextNode(c) && isTextNode(last)) {
                // merge adjacent text nodes
                res[lastIndex] = createTextVNode(last.text + c.text);
            }
            else {
                // default key for nested array children (likely generated by v-for)
                if (isTrue(children._isVList) &&
                    isDef(c.tag) &&
                    isUndef(c.key) &&
                    isDef(nestedIndex)) {
                    c.key = `__vlist${nestedIndex}_${i}__`;
                }
                res.push(c);
            }
        }
    }
    return res;
}

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList(val, render) {
    let ret = null, i, l, keys, key;
    if (isArray(val) || typeof val === 'string') {
        ret = new Array(val.length);
        for (i = 0, l = val.length; i < l; i++) {
            ret[i] = render(val[i], i);
        }
    }
    else if (typeof val === 'number') {
        ret = new Array(val);
        for (i = 0; i < val; i++) {
            ret[i] = render(i + 1, i);
        }
    }
    else if (isObject(val)) {
        if (hasSymbol && val[Symbol.iterator]) {
            ret = [];
            const iterator = val[Symbol.iterator]();
            let result = iterator.next();
            while (!result.done) {
                ret.push(render(result.value, ret.length));
                result = iterator.next();
            }
        }
        else {
            keys = Object.keys(val);
            ret = new Array(keys.length);
            for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                ret[i] = render(val[key], key, i);
            }
        }
    }
    if (!isDef(ret)) {
        ret = [];
    }
    ret._isVList = true;
    return ret;
}

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot(name, fallbackRender, props, bindObject) {
    const scopedSlotFn = this.$scopedSlots[name];
    let nodes;
    if (scopedSlotFn) {
        // scoped slot
        props = props || {};
        if (bindObject) {
            if (!isObject(bindObject)) {
                warn('slot v-bind without argument expects an Object', this);
            }
            props = extend(extend({}, bindObject), props);
        }
        nodes =
            scopedSlotFn(props) ||
                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);
    }
    else {
        nodes =
            this.$slots[name] ||
                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);
    }
    const target = props && props.slot;
    if (target) {
        return this.$createElement('template', { slot: target }, nodes);
    }
    else {
        return nodes;
    }
}

/**
 * Runtime helper for resolving filters
 */
function resolveFilter(id) {
    return resolveAsset(this.$options, 'filters', id, true) || identity;
}

function isKeyNotMatch(expect, actual) {
    if (isArray(expect)) {
        return expect.indexOf(actual) === -1;
    }
    else {
        return expect !== actual;
    }
}
/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
    const mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
        return isKeyNotMatch(builtInKeyName, eventKeyName);
    }
    else if (mappedKeyCode) {
        return isKeyNotMatch(mappedKeyCode, eventKeyCode);
    }
    else if (eventKeyName) {
        return hyphenate(eventKeyName) !== key;
    }
    return eventKeyCode === undefined;
}

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps(data, tag, value, asProp, isSync) {
    if (value) {
        if (!isObject(value)) {
            warn('v-bind without argument expects an Object or Array value', this);
        }
        else {
            if (isArray(value)) {
                value = toObject(value);
            }
            let hash;
            for (const key in value) {
                if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
                    hash = data;
                }
                else {
                    const type = data.attrs && data.attrs.type;
                    hash =
                        asProp || config.mustUseProp(tag, type, key)
                            ? data.domProps || (data.domProps = {})
                            : data.attrs || (data.attrs = {});
                }
                const camelizedKey = camelize(key);
                const hyphenatedKey = hyphenate(key);
                if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
                    hash[key] = value[key];
                    if (isSync) {
                        const on = data.on || (data.on = {});
                        on[`update:${key}`] = function ($event) {
                            value[key] = $event;
                        };
                    }
                }
            }
        }
    }
    return data;
}

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic(index, isInFor) {
    const cached = this._staticTrees || (this._staticTrees = []);
    let tree = cached[index];
    // if has already-rendered static tree and not inside v-for,
    // we can reuse the same tree.
    if (tree && !isInFor) {
        return tree;
    }
    // otherwise, render a fresh tree.
    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, this._c, this // for render fns generated for functional component templates
    );
    markStatic(tree, `__static__${index}`, false);
    return tree;
}
/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce(tree, index, key) {
    markStatic(tree, `__once__${index}${key ? `_${key}` : ``}`, true);
    return tree;
}
function markStatic(tree, key, isOnce) {
    if (isArray(tree)) {
        for (let i = 0; i < tree.length; i++) {
            if (tree[i] && typeof tree[i] !== 'string') {
                markStaticNode(tree[i], `${key}_${i}`, isOnce);
            }
        }
    }
    else {
        markStaticNode(tree, key, isOnce);
    }
}
function markStaticNode(node, key, isOnce) {
    node.isStatic = true;
    node.key = key;
    node.isOnce = isOnce;
}

function bindObjectListeners(data, value) {
    if (value) {
        if (!isPlainObject(value)) {
            warn('v-on without argument expects an Object value', this);
        }
        else {
            const on = (data.on = data.on ? extend({}, data.on) : {});
            for (const key in value) {
                const existing = on[key];
                const ours = value[key];
                on[key] = existing ? [].concat(existing, ours) : ours;
            }
        }
    }
    return data;
}

function resolveScopedSlots(fns, res, 
// the following are added in 2.6
hasDynamicKeys, contentHashKey) {
    res = res || { $stable: !hasDynamicKeys };
    for (let i = 0; i < fns.length; i++) {
        const slot = fns[i];
        if (isArray(slot)) {
            resolveScopedSlots(slot, res, hasDynamicKeys);
        }
        else if (slot) {
            // marker for reverse proxying v-slot without scope on this.$slots
            // @ts-expect-error
            if (slot.proxy) {
                // @ts-expect-error
                slot.fn.proxy = true;
            }
            res[slot.key] = slot.fn;
        }
    }
    if (contentHashKey) {
        res.$key = contentHashKey;
    }
    return res;
}

// helper to process dynamic keys for dynamic arguments in v-bind and v-on.
function bindDynamicKeys(baseObj, values) {
    for (let i = 0; i < values.length; i += 2) {
        const key = values[i];
        if (typeof key === 'string' && key) {
            baseObj[values[i]] = values[i + 1];
        }
        else if (key !== '' && key !== null) {
            // null is a special value for explicitly removing a binding
            warn(`Invalid value for dynamic directive argument (expected string or null): ${key}`, this);
        }
    }
    return baseObj;
}
// helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.
function prependModifier(value, symbol) {
    return typeof value === 'string' ? symbol + value : value;
}

function installRenderHelpers(target) {
    target._o = markOnce;
    target._n = toNumber;
    target._s = toString;
    target._l = renderList;
    target._t = renderSlot;
    target._q = looseEqual;
    target._i = looseIndexOf;
    target._m = renderStatic;
    target._f = resolveFilter;
    target._k = checkKeyCodes;
    target._b = bindObjectProps;
    target._v = createTextVNode;
    target._e = createEmptyVNode;
    target._u = resolveScopedSlots;
    target._g = bindObjectListeners;
    target._d = bindDynamicKeys;
    target._p = prependModifier;
}

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots(children, context) {
    if (!children || !children.length) {
        return {};
    }
    const slots = {};
    for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];
        const data = child.data;
        // remove slot attribute if the node is resolved as a Vue slot node
        if (data && data.attrs && data.attrs.slot) {
            delete data.attrs.slot;
        }
        // named slots should only be respected if the vnode was rendered in the
        // same context.
        if ((child.context === context || child.fnContext === context) &&
            data &&
            data.slot != null) {
            const name = data.slot;
            const slot = slots[name] || (slots[name] = []);
            if (child.tag === 'template') {
                slot.push.apply(slot, child.children || []);
            }
            else {
                slot.push(child);
            }
        }
        else {
            (slots.default || (slots.default = [])).push(child);
        }
    }
    // ignore slots that contains only whitespace
    for (const name in slots) {
        if (slots[name].every(isWhitespace)) {
            delete slots[name];
        }
    }
    return slots;
}
function isWhitespace(node) {
    return (node.isComment && !node.asyncFactory) || node.text === ' ';
}

function isAsyncPlaceholder(node) {
    // @ts-expect-error not really boolean type
    return node.isComment && node.asyncFactory;
}

function normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {
    let res;
    const hasNormalSlots = Object.keys(normalSlots).length > 0;
    const isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;
    const key = scopedSlots && scopedSlots.$key;
    if (!scopedSlots) {
        res = {};
    }
    else if (scopedSlots._normalized) {
        // fast path 1: child component re-render only, parent did not change
        return scopedSlots._normalized;
    }
    else if (isStable &&
        prevScopedSlots &&
        prevScopedSlots !== emptyObject &&
        key === prevScopedSlots.$key &&
        !hasNormalSlots &&
        !prevScopedSlots.$hasNormal) {
        // fast path 2: stable scoped slots w/ no normal slots to proxy,
        // only need to normalize once
        return prevScopedSlots;
    }
    else {
        res = {};
        for (const key in scopedSlots) {
            if (scopedSlots[key] && key[0] !== '$') {
                res[key] = normalizeScopedSlot(ownerVm, normalSlots, key, scopedSlots[key]);
            }
        }
    }
    // expose normal slots on scopedSlots
    for (const key in normalSlots) {
        if (!(key in res)) {
            res[key] = proxyNormalSlot(normalSlots, key);
        }
    }
    // avoriaz seems to mock a non-extensible $scopedSlots object
    // and when that is passed down this would cause an error
    if (scopedSlots && Object.isExtensible(scopedSlots)) {
        scopedSlots._normalized = res;
    }
    def(res, '$stable', isStable);
    def(res, '$key', key);
    def(res, '$hasNormal', hasNormalSlots);
    return res;
}
function normalizeScopedSlot(vm, normalSlots, key, fn) {
    const normalized = function () {
        const cur = currentInstance;
        setCurrentInstance(vm);
        let res = arguments.length ? fn.apply(null, arguments) : fn({});
        res =
            res && typeof res === 'object' && !isArray(res)
                ? [res] // single vnode
                : normalizeChildren(res);
        const vnode = res && res[0];
        setCurrentInstance(cur);
        return res &&
            (!vnode ||
                (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode))) // #9658, #10391
            ? undefined
            : res;
    };
    // this is a slot using the new v-slot syntax without scope. although it is
    // compiled as a scoped slot, render fn users would expect it to be present
    // on this.$slots because the usage is semantically a normal slot.
    if (fn.proxy) {
        Object.defineProperty(normalSlots, key, {
            get: normalized,
            enumerable: true,
            configurable: true
        });
    }
    return normalized;
}
function proxyNormalSlot(slots, key) {
    return () => slots[key];
}

function initSetup(vm) {
    const options = vm.$options;
    const setup = options.setup;
    if (setup) {
        const ctx = (vm._setupContext = createSetupContext(vm));
        setCurrentInstance(vm);
        pushTarget();
        const setupResult = invokeWithErrorHandling(setup, null, [vm._props || shallowReactive({}), ctx], vm, `setup`);
        popTarget();
        setCurrentInstance();
        if (isFunction(setupResult)) {
            // render function
            // @ts-ignore
            options.render = setupResult;
        }
        else if (isObject(setupResult)) {
            // bindings
            if (setupResult instanceof VNode) {
                warn(`setup() should not return VNodes directly - ` +
                    `return a render function instead.`);
            }
            vm._setupState = setupResult;
            // __sfc indicates compiled bindings from <script setup>
            if (!setupResult.__sfc) {
                for (const key in setupResult) {
                    if (!isReserved(key)) {
                        proxyWithRefUnwrap(vm, setupResult, key);
                    }
                    else {
                        warn(`Avoid using variables that start with _ or $ in setup().`);
                    }
                }
            }
            else {
                // exposed for compiled render fn
                const proxy = (vm._setupProxy = {});
                for (const key in setupResult) {
                    if (key !== '__sfc') {
                        proxyWithRefUnwrap(proxy, setupResult, key);
                    }
                }
            }
        }
        else if (setupResult !== undefined) {
            warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);
        }
    }
}
function createSetupContext(vm) {
    let exposeCalled = false;
    return {
        get attrs() {
            if (!vm._attrsProxy) {
                const proxy = (vm._attrsProxy = {});
                def(proxy, '_v_attr_proxy', true);
                syncSetupProxy(proxy, vm.$attrs, emptyObject, vm, '$attrs');
            }
            return vm._attrsProxy;
        },
        get listeners() {
            if (!vm._listenersProxy) {
                const proxy = (vm._listenersProxy = {});
                syncSetupProxy(proxy, vm.$listeners, emptyObject, vm, '$listeners');
            }
            return vm._listenersProxy;
        },
        get slots() {
            return initSlotsProxy(vm);
        },
        emit: bind(vm.$emit, vm),
        expose(exposed) {
            {
                if (exposeCalled) {
                    warn(`expose() should be called only once per setup().`, vm);
                }
                exposeCalled = true;
            }
            if (exposed) {
                Object.keys(exposed).forEach(key => proxyWithRefUnwrap(vm, exposed, key));
            }
        }
    };
}
function syncSetupProxy(to, from, prev, instance, type) {
    let changed = false;
    for (const key in from) {
        if (!(key in to)) {
            changed = true;
            defineProxyAttr(to, key, instance, type);
        }
        else if (from[key] !== prev[key]) {
            changed = true;
        }
    }
    for (const key in to) {
        if (!(key in from)) {
            changed = true;
            delete to[key];
        }
    }
    return changed;
}
function defineProxyAttr(proxy, key, instance, type) {
    Object.defineProperty(proxy, key, {
        enumerable: true,
        configurable: true,
        get() {
            return instance[type][key];
        }
    });
}
function initSlotsProxy(vm) {
    if (!vm._slotsProxy) {
        syncSetupSlots((vm._slotsProxy = {}), vm.$scopedSlots);
    }
    return vm._slotsProxy;
}
function syncSetupSlots(to, from) {
    for (const key in from) {
        to[key] = from[key];
    }
    for (const key in to) {
        if (!(key in from)) {
            delete to[key];
        }
    }
}
/**
 * @internal use manual type def because public setup context type relies on
 * legacy VNode types
 */
function useSlots() {
    return getContext().slots;
}
/**
 * @internal use manual type def because public setup context type relies on
 * legacy VNode types
 */
function useAttrs() {
    return getContext().attrs;
}
/**
 * Vue 2 only
 * @internal use manual type def because public setup context type relies on
 * legacy VNode types
 */
function useListeners() {
    return getContext().listeners;
}
function getContext() {
    if (!currentInstance) {
        warn(`useContext() called without active instance.`);
    }
    const vm = currentInstance;
    return vm._setupContext || (vm._setupContext = createSetupContext(vm));
}
/**
 * Runtime helper for merging default declarations. Imported by compiled code
 * only.
 * @internal
 */
function mergeDefaults(raw, defaults) {
    const props = isArray(raw)
        ? raw.reduce((normalized, p) => ((normalized[p] = {}), normalized), {})
        : raw;
    for (const key in defaults) {
        const opt = props[key];
        if (opt) {
            if (isArray(opt) || isFunction(opt)) {
                props[key] = { type: opt, default: defaults[key] };
            }
            else {
                opt.default = defaults[key];
            }
        }
        else if (opt === null) {
            props[key] = { default: defaults[key] };
        }
        else {
            warn(`props default key "${key}" has no corresponding declaration.`);
        }
    }
    return props;
}

function initRender(vm) {
    vm._vnode = null; // the root of the child tree
    vm._staticTrees = null; // v-once cached trees
    const options = vm.$options;
    const parentVnode = (vm.$vnode = options._parentVnode); // the placeholder node in parent tree
    const renderContext = parentVnode && parentVnode.context;
    vm.$slots = resolveSlots(options._renderChildren, renderContext);
    vm.$scopedSlots = parentVnode
        ? normalizeScopedSlots(vm.$parent, parentVnode.data.scopedSlots, vm.$slots)
        : emptyObject;
    // bind the createElement fn to this instance
    // so that we get proper render context inside it.
    // args order: tag, data, children, normalizationType, alwaysNormalize
    // internal version is used by render functions compiled from templates
    // @ts-expect-error
    vm._c = (a, b, c, d) => createElement$1(vm, a, b, c, d, false);
    // normalization is always applied for the public version, used in
    // user-written render functions.
    // @ts-expect-error
    vm.$createElement = (a, b, c, d) => createElement$1(vm, a, b, c, d, true);
    // $attrs & $listeners are exposed for easier HOC creation.
    // they need to be reactive so that HOCs using them are always updated
    const parentData = parentVnode && parentVnode.data;
    /* istanbul ignore else */
    {
        defineReactive(vm, '$attrs', (parentData && parentData.attrs) || emptyObject, () => {
            !isUpdatingChildComponent && warn(`$attrs is readonly.`, vm);
        }, true);
        defineReactive(vm, '$listeners', options._parentListeners || emptyObject, () => {
            !isUpdatingChildComponent && warn(`$listeners is readonly.`, vm);
        }, true);
    }
}
let currentRenderingInstance = null;
function renderMixin(Vue) {
    // install runtime convenience helpers
    installRenderHelpers(Vue.prototype);
    Vue.prototype.$nextTick = function (fn) {
        return nextTick(fn, this);
    };
    Vue.prototype._render = function () {
        const vm = this;
        const { render, _parentVnode } = vm.$options;
        if (_parentVnode && vm._isMounted) {
            vm.$scopedSlots = normalizeScopedSlots(vm.$parent, _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
            if (vm._slotsProxy) {
                syncSetupSlots(vm._slotsProxy, vm.$scopedSlots);
            }
        }
        // set parent vnode. this allows render functions to have access
        // to the data on the placeholder node.
        vm.$vnode = _parentVnode;
        // render self
        let vnode;
        try {
            // There's no need to maintain a stack because all render fns are called
            // separately from one another. Nested component's render fns are called
            // when parent component is patched.
            setCurrentInstance(vm);
            currentRenderingInstance = vm;
            vnode = render.call(vm._renderProxy, vm.$createElement);
        }
        catch (e) {
            handleError(e, vm, `render`);
            // return error render result,
            // or previous vnode to prevent render error causing blank component
            /* istanbul ignore else */
            if (vm.$options.renderError) {
                try {
                    vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
                }
                catch (e) {
                    handleError(e, vm, `renderError`);
                    vnode = vm._vnode;
                }
            }
            else {
                vnode = vm._vnode;
            }
        }
        finally {
            currentRenderingInstance = null;
            setCurrentInstance();
        }
        // if the returned array contains only a single node, allow it
        if (isArray(vnode) && vnode.length === 1) {
            vnode = vnode[0];
        }
        // return empty vnode in case the render function errored out
        if (!(vnode instanceof VNode)) {
            if (isArray(vnode)) {
                warn('Multiple root nodes returned from render function. Render function ' +
                    'should return a single root node.', vm);
            }
            vnode = createEmptyVNode();
        }
        // set parent
        vnode.parent = _parentVnode;
        return vnode;
    };
}

function ensureCtor(comp, base) {
    if (comp.__esModule || (hasSymbol && comp[Symbol.toStringTag] === 'Module')) {
        comp = comp.default;
    }
    return isObject(comp) ? base.extend(comp) : comp;
}
function createAsyncPlaceholder(factory, data, context, children, tag) {
    const node = createEmptyVNode();
    node.asyncFactory = factory;
    node.asyncMeta = { data, context, children, tag };
    return node;
}
function resolveAsyncComponent(factory, baseCtor) {
    if (isTrue(factory.error) && isDef(factory.errorComp)) {
        return factory.errorComp;
    }
    if (isDef(factory.resolved)) {
        return factory.resolved;
    }
    const owner = currentRenderingInstance;
    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
        // already pending
        factory.owners.push(owner);
    }
    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
        return factory.loadingComp;
    }
    if (owner && !isDef(factory.owners)) {
        const owners = (factory.owners = [owner]);
        let sync = true;
        let timerLoading = null;
        let timerTimeout = null;
        owner.$on('hook:destroyed', () => remove$2(owners, owner));
        const forceRender = (renderCompleted) => {
            for (let i = 0, l = owners.length; i < l; i++) {
                owners[i].$forceUpdate();
            }
            if (renderCompleted) {
                owners.length = 0;
                if (timerLoading !== null) {
                    clearTimeout(timerLoading);
                    timerLoading = null;
                }
                if (timerTimeout !== null) {
                    clearTimeout(timerTimeout);
                    timerTimeout = null;
                }
            }
        };
        const resolve = once((res) => {
            // cache resolved
            factory.resolved = ensureCtor(res, baseCtor);
            // invoke callbacks only if this is not a synchronous resolve
            // (async resolves are shimmed as synchronous during SSR)
            if (!sync) {
                forceRender(true);
            }
            else {
                owners.length = 0;
            }
        });
        const reject = once(reason => {
            warn(`Failed to resolve async component: ${String(factory)}` +
                    (reason ? `\nReason: ${reason}` : ''));
            if (isDef(factory.errorComp)) {
                factory.error = true;
                forceRender(true);
            }
        });
        const res = factory(resolve, reject);
        if (isObject(res)) {
            if (isPromise(res)) {
                // () => Promise
                if (isUndef(factory.resolved)) {
                    res.then(resolve, reject);
                }
            }
            else if (isPromise(res.component)) {
                res.component.then(resolve, reject);
                if (isDef(res.error)) {
                    factory.errorComp = ensureCtor(res.error, baseCtor);
                }
                if (isDef(res.loading)) {
                    factory.loadingComp = ensureCtor(res.loading, baseCtor);
                    if (res.delay === 0) {
                        factory.loading = true;
                    }
                    else {
                        // @ts-expect-error NodeJS timeout type
                        timerLoading = setTimeout(() => {
                            timerLoading = null;
                            if (isUndef(factory.resolved) && isUndef(factory.error)) {
                                factory.loading = true;
                                forceRender(false);
                            }
                        }, res.delay || 200);
                    }
                }
                if (isDef(res.timeout)) {
                    // @ts-expect-error NodeJS timeout type
                    timerTimeout = setTimeout(() => {
                        timerTimeout = null;
                        if (isUndef(factory.resolved)) {
                            reject(`timeout (${res.timeout}ms)` );
                        }
                    }, res.timeout);
                }
            }
        }
        sync = false;
        // return in case resolved synchronously
        return factory.loading ? factory.loadingComp : factory.resolved;
    }
}

function getFirstComponentChild(children) {
    if (isArray(children)) {
        for (let i = 0; i < children.length; i++) {
            const c = children[i];
            if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
                return c;
            }
        }
    }
}

const SIMPLE_NORMALIZE = 1;
const ALWAYS_NORMALIZE = 2;
// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement$1(context, tag, data, children, normalizationType, alwaysNormalize) {
    if (isArray(data) || isPrimitive(data)) {
        normalizationType = children;
        children = data;
        data = undefined;
    }
    if (isTrue(alwaysNormalize)) {
        normalizationType = ALWAYS_NORMALIZE;
    }
    return _createElement(context, tag, data, children, normalizationType);
}
function _createElement(context, tag, data, children, normalizationType) {
    if (isDef(data) && isDef(data.__ob__)) {
        warn(`Avoid using observed data object as vnode data: ${JSON.stringify(data)}\n` + 'Always create fresh vnode data objects in each render!', context);
        return createEmptyVNode();
    }
    // object syntax in v-bind
    if (isDef(data) && isDef(data.is)) {
        tag = data.is;
    }
    if (!tag) {
        // in case of component :is set to falsy value
        return createEmptyVNode();
    }
    // warn against non-primitive key
    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
        warn('Avoid using non-primitive value as key, ' +
            'use string/number value instead.', context);
    }
    // support single function children as default scoped slot
    if (isArray(children) && isFunction(children[0])) {
        data = data || {};
        data.scopedSlots = { default: children[0] };
        children.length = 0;
    }
    if (normalizationType === ALWAYS_NORMALIZE) {
        children = normalizeChildren(children);
    }
    else if (normalizationType === SIMPLE_NORMALIZE) {
        children = simpleNormalizeChildren(children);
    }
    let vnode, ns;
    if (typeof tag === 'string') {
        let Ctor;
        ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
        if (config.isReservedTag(tag)) {
            // platform built-in elements
            if (isDef(data) &&
                isDef(data.nativeOn) &&
                data.tag !== 'component') {
                warn(`The .native modifier for v-on is only valid on components but it was used on <${tag}>.`, context);
            }
            vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
        }
        else if ((!data || !data.pre) &&
            isDef((Ctor = resolveAsset(context.$options, 'components', tag)))) {
            // component
            vnode = createComponent(Ctor, data, context, children, tag);
        }
        else {
            // unknown or unlisted namespaced elements
            // check at runtime because it may get assigned a namespace when its
            // parent normalizes children
            vnode = new VNode(tag, data, children, undefined, undefined, context);
        }
    }
    else {
        // direct component options / constructor
        vnode = createComponent(tag, data, context, children);
    }
    if (isArray(vnode)) {
        return vnode;
    }
    else if (isDef(vnode)) {
        if (isDef(ns))
            applyNS(vnode, ns);
        if (isDef(data))
            registerDeepBindings(data);
        return vnode;
    }
    else {
        return createEmptyVNode();
    }
}
function applyNS(vnode, ns, force) {
    vnode.ns = ns;
    if (vnode.tag === 'foreignObject') {
        // use default namespace inside foreignObject
        ns = undefined;
        force = true;
    }
    if (isDef(vnode.children)) {
        for (let i = 0, l = vnode.children.length; i < l; i++) {
            const child = vnode.children[i];
            if (isDef(child.tag) &&
                (isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
                applyNS(child, ns, force);
            }
        }
    }
}
// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings(data) {
    if (isObject(data.style)) {
        traverse(data.style);
    }
    if (isObject(data.class)) {
        traverse(data.class);
    }
}

/**
 * @internal this function needs manual public type declaration because it relies
 * on previously manually authored types from Vue 2
 */
function h(type, props, children) {
    if (!currentInstance) {
        warn(`globally imported h() can only be invoked when there is an active ` +
                `component instance, e.g. synchronously in a component's render or setup function.`);
    }
    return createElement$1(currentInstance, type, props, children, 2, true);
}

function handleError(err, vm, info) {
    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
    // See: https://github.com/vuejs/vuex/issues/1505
    pushTarget();
    try {
        if (vm) {
            let cur = vm;
            while ((cur = cur.$parent)) {
                const hooks = cur.$options.errorCaptured;
                if (hooks) {
                    for (let i = 0; i < hooks.length; i++) {
                        try {
                            const capture = hooks[i].call(cur, err, vm, info) === false;
                            if (capture)
                                return;
                        }
                        catch (e) {
                            globalHandleError(e, cur, 'errorCaptured hook');
                        }
                    }
                }
            }
        }
        globalHandleError(err, vm, info);
    }
    finally {
        popTarget();
    }
}
function invokeWithErrorHandling(handler, context, args, vm, info) {
    let res;
    try {
        res = args ? handler.apply(context, args) : handler.call(context);
        if (res && !res._isVue && isPromise(res) && !res._handled) {
            res.catch(e => handleError(e, vm, info + ` (Promise/async)`));
            res._handled = true;
        }
    }
    catch (e) {
        handleError(e, vm, info);
    }
    return res;
}
function globalHandleError(err, vm, info) {
    if (config.errorHandler) {
        try {
            return config.errorHandler.call(null, err, vm, info);
        }
        catch (e) {
            // if the user intentionally throws the original error in the handler,
            // do not log it twice
            if (e !== err) {
                logError(e, null, 'config.errorHandler');
            }
        }
    }
    logError(err, vm, info);
}
function logError(err, vm, info) {
    {
        warn(`Error in ${info}: "${err.toString()}"`, vm);
    }
    /* istanbul ignore else */
    if (inBrowser && typeof console !== 'undefined') {
        console.error(err);
    }
    else {
        throw err;
    }
}

/* globals MutationObserver */
let isUsingMicroTask = false;
const callbacks = [];
let pending = false;
function flushCallbacks() {
    pending = false;
    const copies = callbacks.slice(0);
    callbacks.length = 0;
    for (let i = 0; i < copies.length; i++) {
        copies[i]();
    }
}
// Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).
let timerFunc;
// The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
    const p = Promise.resolve();
    timerFunc = () => {
        p.then(flushCallbacks);
        // In problematic UIWebViews, Promise.then doesn't completely break, but
        // it can get stuck in a weird state where callbacks are pushed into the
        // microtask queue but the queue isn't being flushed, until the browser
        // needs to do some other work, e.g. handle a timer. Therefore we can
        // "force" the microtask queue to be flushed by adding an empty timer.
        if (isIOS)
            setTimeout(noop);
    };
    isUsingMicroTask = true;
}
else if (!isIE &&
    typeof MutationObserver !== 'undefined' &&
    (isNative(MutationObserver) ||
        // PhantomJS and iOS 7.x
        MutationObserver.toString() === '[object MutationObserverConstructor]')) {
    // Use MutationObserver where native Promise is not available,
    // e.g. PhantomJS, iOS7, Android 4.4
    // (#6466 MutationObserver is unreliable in IE11)
    let counter = 1;
    const observer = new MutationObserver(flushCallbacks);
    const textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
        characterData: true
    });
    timerFunc = () => {
        counter = (counter + 1) % 2;
        textNode.data = String(counter);
    };
    isUsingMicroTask = true;
}
else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    // Fallback to setImmediate.
    // Technically it leverages the (macro) task queue,
    // but it is still a better choice than setTimeout.
    timerFunc = () => {
        setImmediate(flushCallbacks);
    };
}
else {
    // Fallback to setTimeout.
    timerFunc = () => {
        setTimeout(flushCallbacks, 0);
    };
}
/**
 * @internal
 */
function nextTick(cb, ctx) {
    let _resolve;
    callbacks.push(() => {
        if (cb) {
            try {
                cb.call(ctx);
            }
            catch (e) {
                handleError(e, ctx, 'nextTick');
            }
        }
        else if (_resolve) {
            _resolve(ctx);
        }
    });
    if (!pending) {
        pending = true;
        timerFunc();
    }
    // $flow-disable-line
    if (!cb && typeof Promise !== 'undefined') {
        return new Promise(resolve => {
            _resolve = resolve;
        });
    }
}

function useCssModule(name = '$style') {
    /* istanbul ignore else */
    {
        if (!currentInstance) {
            warn(`useCssModule must be called inside setup()`);
            return emptyObject;
        }
        const mod = currentInstance[name];
        if (!mod) {
            warn(`Current instance does not have CSS module named "${name}".`);
            return emptyObject;
        }
        return mod;
    }
}

/**
 * Runtime helper for SFC's CSS variable injection feature.
 * @private
 */
function useCssVars(getter) {
    if (!inBrowser && !false)
        return;
    const instance = currentInstance;
    if (!instance) {
        warn(`useCssVars is called without current active component instance.`);
        return;
    }
    watchPostEffect(() => {
        const el = instance.$el;
        const vars = getter(instance, instance._setupProxy);
        if (el && el.nodeType === 1) {
            const style = el.style;
            for (const key in vars) {
                style.setProperty(`--${key}`, vars[key]);
            }
        }
    });
}

/**
 * v3-compatible async component API.
 * @internal the type is manually declared in <root>/types/v3-define-async-component.d.ts
 * because it relies on existing manual types
 */
function defineAsyncComponent(source) {
    if (isFunction(source)) {
        source = { loader: source };
    }
    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out
    suspensible = false, // in Vue 3 default is true
    onError: userOnError } = source;
    if (suspensible) {
        warn(`The suspensiblbe option for async components is not supported in Vue2. It is ignored.`);
    }
    let pendingRequest = null;
    let retries = 0;
    const retry = () => {
        retries++;
        pendingRequest = null;
        return load();
    };
    const load = () => {
        let thisRequest;
        return (pendingRequest ||
            (thisRequest = pendingRequest =
                loader()
                    .catch(err => {
                    err = err instanceof Error ? err : new Error(String(err));
                    if (userOnError) {
                        return new Promise((resolve, reject) => {
                            const userRetry = () => resolve(retry());
                            const userFail = () => reject(err);
                            userOnError(err, userRetry, userFail, retries + 1);
                        });
                    }
                    else {
                        throw err;
                    }
                })
                    .then((comp) => {
                    if (thisRequest !== pendingRequest && pendingRequest) {
                        return pendingRequest;
                    }
                    if (!comp) {
                        warn(`Async component loader resolved to undefined. ` +
                            `If you are using retry(), make sure to return its return value.`);
                    }
                    // interop module default
                    if (comp &&
                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
                        comp = comp.default;
                    }
                    if (comp && !isObject(comp) && !isFunction(comp)) {
                        throw new Error(`Invalid async component load result: ${comp}`);
                    }
                    return comp;
                })));
    };
    return () => {
        const component = load();
        return {
            component,
            delay,
            timeout,
            error: errorComponent,
            loading: loadingComponent
        };
    };
}

function createLifeCycle(hookName) {
    return (fn, target = currentInstance) => {
        if (!target) {
            warn(`${formatName(hookName)} is called when there is no active component instance to be ` +
                    `associated with. ` +
                    `Lifecycle injection APIs can only be used during execution of setup().`);
            return;
        }
        return injectHook(target, hookName, fn);
    };
}
function formatName(name) {
    if (name === 'beforeDestroy') {
        name = 'beforeUnmount';
    }
    else if (name === 'destroyed') {
        name = 'unmounted';
    }
    return `on${name[0].toUpperCase() + name.slice(1)}`;
}
function injectHook(instance, hookName, fn) {
    const options = instance.$options;
    options[hookName] = mergeLifecycleHook(options[hookName], fn);
}
const onBeforeMount = createLifeCycle('beforeMount');
const onMounted = createLifeCycle('mounted');
const onBeforeUpdate = createLifeCycle('beforeUpdate');
const onUpdated = createLifeCycle('updated');
const onBeforeUnmount = createLifeCycle('beforeDestroy');
const onUnmounted = createLifeCycle('destroyed');
const onActivated = createLifeCycle('activated');
const onDeactivated = createLifeCycle('deactivated');
const onServerPrefetch = createLifeCycle('serverPrefetch');
const onRenderTracked = createLifeCycle('renderTracked');
const onRenderTriggered = createLifeCycle('renderTriggered');
const injectErrorCapturedHook = createLifeCycle('errorCaptured');
function onErrorCaptured(hook, target = currentInstance) {
    injectErrorCapturedHook(hook, target);
}

/**
 * Note: also update dist/vue.runtime.mjs when adding new exports to this file.
 */
const version = '2.7.14';
/**
 * @internal type is manually declared in <root>/types/v3-define-component.d.ts
 */
function defineComponent(options) {
    return options;
}

var vca = /*#__PURE__*/Object.freeze({
  __proto__: null,
  version: version,
  defineComponent: defineComponent,
  ref: ref$1,
  shallowRef: shallowRef,
  isRef: isRef,
  toRef: toRef,
  toRefs: toRefs,
  unref: unref,
  proxyRefs: proxyRefs,
  customRef: customRef,
  triggerRef: triggerRef,
  reactive: reactive,
  isReactive: isReactive,
  isReadonly: isReadonly,
  isShallow: isShallow,
  isProxy: isProxy,
  shallowReactive: shallowReactive,
  markRaw: markRaw,
  toRaw: toRaw,
  readonly: readonly,
  shallowReadonly: shallowReadonly,
  computed: computed,
  watch: watch,
  watchEffect: watchEffect,
  watchPostEffect: watchPostEffect,
  watchSyncEffect: watchSyncEffect,
  EffectScope: EffectScope,
  effectScope: effectScope,
  onScopeDispose: onScopeDispose,
  getCurrentScope: getCurrentScope,
  provide: provide,
  inject: inject,
  h: h,
  getCurrentInstance: getCurrentInstance,
  useSlots: useSlots,
  useAttrs: useAttrs,
  useListeners: useListeners,
  mergeDefaults: mergeDefaults,
  nextTick: nextTick,
  set: set,
  del: del,
  useCssModule: useCssModule,
  useCssVars: useCssVars,
  defineAsyncComponent: defineAsyncComponent,
  onBeforeMount: onBeforeMount,
  onMounted: onMounted,
  onBeforeUpdate: onBeforeUpdate,
  onUpdated: onUpdated,
  onBeforeUnmount: onBeforeUnmount,
  onUnmounted: onUnmounted,
  onActivated: onActivated,
  onDeactivated: onDeactivated,
  onServerPrefetch: onServerPrefetch,
  onRenderTracked: onRenderTracked,
  onRenderTriggered: onRenderTriggered,
  onErrorCaptured: onErrorCaptured
});

const seenObjects = new _Set();
/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse(val) {
    _traverse(val, seenObjects);
    seenObjects.clear();
    return val;
}
function _traverse(val, seen) {
    let i, keys;
    const isA = isArray(val);
    if ((!isA && !isObject(val)) ||
        val.__v_skip /* ReactiveFlags.SKIP */ ||
        Object.isFrozen(val) ||
        val instanceof VNode) {
        return;
    }
    if (val.__ob__) {
        const depId = val.__ob__.dep.id;
        if (seen.has(depId)) {
            return;
        }
        seen.add(depId);
    }
    if (isA) {
        i = val.length;
        while (i--)
            _traverse(val[i], seen);
    }
    else if (isRef(val)) {
        _traverse(val.value, seen);
    }
    else {
        keys = Object.keys(val);
        i = keys.length;
        while (i--)
            _traverse(val[keys[i]], seen);
    }
}

let uid$1 = 0;
/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 * @internal
 */
class Watcher {
    constructor(vm, expOrFn, cb, options, isRenderWatcher) {
        recordEffectScope(this, 
        // if the active effect scope is manually created (not a component scope),
        // prioritize it
        activeEffectScope && !activeEffectScope._vm
            ? activeEffectScope
            : vm
                ? vm._scope
                : undefined);
        if ((this.vm = vm) && isRenderWatcher) {
            vm._watcher = this;
        }
        // options
        if (options) {
            this.deep = !!options.deep;
            this.user = !!options.user;
            this.lazy = !!options.lazy;
            this.sync = !!options.sync;
            this.before = options.before;
            {
                this.onTrack = options.onTrack;
                this.onTrigger = options.onTrigger;
            }
        }
        else {
            this.deep = this.user = this.lazy = this.sync = false;
        }
        this.cb = cb;
        this.id = ++uid$1; // uid for batching
        this.active = true;
        this.post = false;
        this.dirty = this.lazy; // for lazy watchers
        this.deps = [];
        this.newDeps = [];
        this.depIds = new _Set();
        this.newDepIds = new _Set();
        this.expression = expOrFn.toString() ;
        // parse expression for getter
        if (isFunction(expOrFn)) {
            this.getter = expOrFn;
        }
        else {
            this.getter = parsePath(expOrFn);
            if (!this.getter) {
                this.getter = noop;
                warn(`Failed watching path: "${expOrFn}" ` +
                        'Watcher only accepts simple dot-delimited paths. ' +
                        'For full control, use a function instead.', vm);
            }
        }
        this.value = this.lazy ? undefined : this.get();
    }
    /**
     * Evaluate the getter, and re-collect dependencies.
     */
    get() {
        pushTarget(this);
        let value;
        const vm = this.vm;
        try {
            value = this.getter.call(vm, vm);
        }
        catch (e) {
            if (this.user) {
                handleError(e, vm, `getter for watcher "${this.expression}"`);
            }
            else {
                throw e;
            }
        }
        finally {
            // "touch" every property so they are all tracked as
            // dependencies for deep watching
            if (this.deep) {
                traverse(value);
            }
            popTarget();
            this.cleanupDeps();
        }
        return value;
    }
    /**
     * Add a dependency to this directive.
     */
    addDep(dep) {
        const id = dep.id;
        if (!this.newDepIds.has(id)) {
            this.newDepIds.add(id);
            this.newDeps.push(dep);
            if (!this.depIds.has(id)) {
                dep.addSub(this);
            }
        }
    }
    /**
     * Clean up for dependency collection.
     */
    cleanupDeps() {
        let i = this.deps.length;
        while (i--) {
            const dep = this.deps[i];
            if (!this.newDepIds.has(dep.id)) {
                dep.removeSub(this);
            }
        }
        let tmp = this.depIds;
        this.depIds = this.newDepIds;
        this.newDepIds = tmp;
        this.newDepIds.clear();
        tmp = this.deps;
        this.deps = this.newDeps;
        this.newDeps = tmp;
        this.newDeps.length = 0;
    }
    /**
     * Subscriber interface.
     * Will be called when a dependency changes.
     */
    update() {
        /* istanbul ignore else */
        if (this.lazy) {
            this.dirty = true;
        }
        else if (this.sync) {
            this.run();
        }
        else {
            queueWatcher(this);
        }
    }
    /**
     * Scheduler job interface.
     * Will be called by the scheduler.
     */
    run() {
        if (this.active) {
            const value = this.get();
            if (value !== this.value ||
                // Deep watchers and watchers on Object/Arrays should fire even
                // when the value is the same, because the value may
                // have mutated.
                isObject(value) ||
                this.deep) {
                // set new value
                const oldValue = this.value;
                this.value = value;
                if (this.user) {
                    const info = `callback for watcher "${this.expression}"`;
                    invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
                }
                else {
                    this.cb.call(this.vm, value, oldValue);
                }
            }
        }
    }
    /**
     * Evaluate the value of the watcher.
     * This only gets called for lazy watchers.
     */
    evaluate() {
        this.value = this.get();
        this.dirty = false;
    }
    /**
     * Depend on all deps collected by this watcher.
     */
    depend() {
        let i = this.deps.length;
        while (i--) {
            this.deps[i].depend();
        }
    }
    /**
     * Remove self from all dependencies' subscriber list.
     */
    teardown() {
        if (this.vm && !this.vm._isBeingDestroyed) {
            remove$2(this.vm._scope.effects, this);
        }
        if (this.active) {
            let i = this.deps.length;
            while (i--) {
                this.deps[i].removeSub(this);
            }
            this.active = false;
            if (this.onStop) {
                this.onStop();
            }
        }
    }
}

let mark;
let measure;
{
    const perf = inBrowser && window.performance;
    /* istanbul ignore if */
    if (perf &&
        // @ts-ignore
        perf.mark &&
        // @ts-ignore
        perf.measure &&
        // @ts-ignore
        perf.clearMarks &&
        // @ts-ignore
        perf.clearMeasures) {
        mark = tag => perf.mark(tag);
        measure = (name, startTag, endTag) => {
            perf.measure(name, startTag, endTag);
            perf.clearMarks(startTag);
            perf.clearMarks(endTag);
            // perf.clearMeasures(name)
        };
    }
}

function initEvents(vm) {
    vm._events = Object.create(null);
    vm._hasHookEvent = false;
    // init parent attached events
    const listeners = vm.$options._parentListeners;
    if (listeners) {
        updateComponentListeners(vm, listeners);
    }
}
let target$1;
function add$1(event, fn) {
    target$1.$on(event, fn);
}
function remove$1(event, fn) {
    target$1.$off(event, fn);
}
function createOnceHandler$1(event, fn) {
    const _target = target$1;
    return function onceHandler() {
        const res = fn.apply(null, arguments);
        if (res !== null) {
            _target.$off(event, onceHandler);
        }
    };
}
function updateComponentListeners(vm, listeners, oldListeners) {
    target$1 = vm;
    updateListeners(listeners, oldListeners || {}, add$1, remove$1, createOnceHandler$1, vm);
    target$1 = undefined;
}
function eventsMixin(Vue) {
    const hookRE = /^hook:/;
    Vue.prototype.$on = function (event, fn) {
        const vm = this;
        if (isArray(event)) {
            for (let i = 0, l = event.length; i < l; i++) {
                vm.$on(event[i], fn);
            }
        }
        else {
            (vm._events[event] || (vm._events[event] = [])).push(fn);
            // optimize hook:event cost by using a boolean flag marked at registration
            // instead of a hash lookup
            if (hookRE.test(event)) {
                vm._hasHookEvent = true;
            }
        }
        return vm;
    };
    Vue.prototype.$once = function (event, fn) {
        const vm = this;
        function on() {
            vm.$off(event, on);
            fn.apply(vm, arguments);
        }
        on.fn = fn;
        vm.$on(event, on);
        return vm;
    };
    Vue.prototype.$off = function (event, fn) {
        const vm = this;
        // all
        if (!arguments.length) {
            vm._events = Object.create(null);
            return vm;
        }
        // array of events
        if (isArray(event)) {
            for (let i = 0, l = event.length; i < l; i++) {
                vm.$off(event[i], fn);
            }
            return vm;
        }
        // specific event
        const cbs = vm._events[event];
        if (!cbs) {
            return vm;
        }
        if (!fn) {
            vm._events[event] = null;
            return vm;
        }
        // specific handler
        let cb;
        let i = cbs.length;
        while (i--) {
            cb = cbs[i];
            if (cb === fn || cb.fn === fn) {
                cbs.splice(i, 1);
                break;
            }
        }
        return vm;
    };
    Vue.prototype.$emit = function (event) {
        const vm = this;
        {
            const lowerCaseEvent = event.toLowerCase();
            if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
                tip(`Event "${lowerCaseEvent}" is emitted in component ` +
                    `${formatComponentName(vm)} but the handler is registered for "${event}". ` +
                    `Note that HTML attributes are case-insensitive and you cannot use ` +
                    `v-on to listen to camelCase events when using in-DOM templates. ` +
                    `You should probably use "${hyphenate(event)}" instead of "${event}".`);
            }
        }
        let cbs = vm._events[event];
        if (cbs) {
            cbs = cbs.length > 1 ? toArray(cbs) : cbs;
            const args = toArray(arguments, 1);
            const info = `event handler for "${event}"`;
            for (let i = 0, l = cbs.length; i < l; i++) {
                invokeWithErrorHandling(cbs[i], vm, args, vm, info);
            }
        }
        return vm;
    };
}

let activeInstance = null;
let isUpdatingChildComponent = false;
function setActiveInstance(vm) {
    const prevActiveInstance = activeInstance;
    activeInstance = vm;
    return () => {
        activeInstance = prevActiveInstance;
    };
}
function initLifecycle(vm) {
    const options = vm.$options;
    // locate first non-abstract parent
    let parent = options.parent;
    if (parent && !options.abstract) {
        while (parent.$options.abstract && parent.$parent) {
            parent = parent.$parent;
        }
        parent.$children.push(vm);
    }
    vm.$parent = parent;
    vm.$root = parent ? parent.$root : vm;
    vm.$children = [];
    vm.$refs = {};
    vm._provided = parent ? parent._provided : Object.create(null);
    vm._watcher = null;
    vm._inactive = null;
    vm._directInactive = false;
    vm._isMounted = false;
    vm._isDestroyed = false;
    vm._isBeingDestroyed = false;
}
function lifecycleMixin(Vue) {
    Vue.prototype._update = function (vnode, hydrating) {
        const vm = this;
        const prevEl = vm.$el;
        const prevVnode = vm._vnode;
        const restoreActiveInstance = setActiveInstance(vm);
        vm._vnode = vnode;
        // Vue.prototype.__patch__ is injected in entry points
        // based on the rendering backend used.
        if (!prevVnode) {
            // initial render
            vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
        }
        else {
            // updates
            vm.$el = vm.__patch__(prevVnode, vnode);
        }
        restoreActiveInstance();
        // update __vue__ reference
        if (prevEl) {
            prevEl.__vue__ = null;
        }
        if (vm.$el) {
            vm.$el.__vue__ = vm;
        }
        // if parent is an HOC, update its $el as well
        let wrapper = vm;
        while (wrapper &&
            wrapper.$vnode &&
            wrapper.$parent &&
            wrapper.$vnode === wrapper.$parent._vnode) {
            wrapper.$parent.$el = wrapper.$el;
            wrapper = wrapper.$parent;
        }
        // updated hook is called by the scheduler to ensure that children are
        // updated in a parent's updated hook.
    };
    Vue.prototype.$forceUpdate = function () {
        const vm = this;
        if (vm._watcher) {
            vm._watcher.update();
        }
    };
    Vue.prototype.$destroy = function () {
        const vm = this;
        if (vm._isBeingDestroyed) {
            return;
        }
        callHook$1(vm, 'beforeDestroy');
        vm._isBeingDestroyed = true;
        // remove self from parent
        const parent = vm.$parent;
        if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
            remove$2(parent.$children, vm);
        }
        // teardown scope. this includes both the render watcher and other
        // watchers created
        vm._scope.stop();
        // remove reference from data ob
        // frozen object may not have observer.
        if (vm._data.__ob__) {
            vm._data.__ob__.vmCount--;
        }
        // call the last hook...
        vm._isDestroyed = true;
        // invoke destroy hooks on current rendered tree
        vm.__patch__(vm._vnode, null);
        // fire destroyed hook
        callHook$1(vm, 'destroyed');
        // turn off all instance listeners.
        vm.$off();
        // remove __vue__ reference
        if (vm.$el) {
            vm.$el.__vue__ = null;
        }
        // release circular reference (#6759)
        if (vm.$vnode) {
            vm.$vnode.parent = null;
        }
    };
}
function mountComponent(vm, el, hydrating) {
    vm.$el = el;
    if (!vm.$options.render) {
        // @ts-expect-error invalid type
        vm.$options.render = createEmptyVNode;
        {
            /* istanbul ignore if */
            if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
                vm.$options.el ||
                el) {
                warn('You are using the runtime-only build of Vue where the template ' +
                    'compiler is not available. Either pre-compile the templates into ' +
                    'render functions, or use the compiler-included build.', vm);
            }
            else {
                warn('Failed to mount component: template or render function not defined.', vm);
            }
        }
    }
    callHook$1(vm, 'beforeMount');
    let updateComponent;
    /* istanbul ignore if */
    if (config.performance && mark) {
        updateComponent = () => {
            const name = vm._name;
            const id = vm._uid;
            const startTag = `vue-perf-start:${id}`;
            const endTag = `vue-perf-end:${id}`;
            mark(startTag);
            const vnode = vm._render();
            mark(endTag);
            measure(`vue ${name} render`, startTag, endTag);
            mark(startTag);
            vm._update(vnode, hydrating);
            mark(endTag);
            measure(`vue ${name} patch`, startTag, endTag);
        };
    }
    else {
        updateComponent = () => {
            vm._update(vm._render(), hydrating);
        };
    }
    const watcherOptions = {
        before() {
            if (vm._isMounted && !vm._isDestroyed) {
                callHook$1(vm, 'beforeUpdate');
            }
        }
    };
    {
        watcherOptions.onTrack = e => callHook$1(vm, 'renderTracked', [e]);
        watcherOptions.onTrigger = e => callHook$1(vm, 'renderTriggered', [e]);
    }
    // we set this to vm._watcher inside the watcher's constructor
    // since the watcher's initial patch may call $forceUpdate (e.g. inside child
    // component's mounted hook), which relies on vm._watcher being already defined
    new Watcher(vm, updateComponent, noop, watcherOptions, true /* isRenderWatcher */);
    hydrating = false;
    // flush buffer for flush: "pre" watchers queued in setup()
    const preWatchers = vm._preWatchers;
    if (preWatchers) {
        for (let i = 0; i < preWatchers.length; i++) {
            preWatchers[i].run();
        }
    }
    // manually mounted instance, call mounted on self
    // mounted is called for render-created child components in its inserted hook
    if (vm.$vnode == null) {
        vm._isMounted = true;
        callHook$1(vm, 'mounted');
    }
    return vm;
}
function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
    {
        isUpdatingChildComponent = true;
    }
    // determine whether component has slot children
    // we need to do this before overwriting $options._renderChildren.
    // check if there are dynamic scopedSlots (hand-written or compiled but with
    // dynamic slot names). Static scoped slots compiled from template has the
    // "$stable" marker.
    const newScopedSlots = parentVnode.data.scopedSlots;
    const oldScopedSlots = vm.$scopedSlots;
    const hasDynamicScopedSlot = !!((newScopedSlots && !newScopedSlots.$stable) ||
        (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
        (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||
        (!newScopedSlots && vm.$scopedSlots.$key));
    // Any static slot children from the parent may have changed during parent's
    // update. Dynamic scoped slots may also have changed. In such cases, a forced
    // update is necessary to ensure correctness.
    let needsForceUpdate = !!(renderChildren || // has new static slots
        vm.$options._renderChildren || // has old static slots
        hasDynamicScopedSlot);
    const prevVNode = vm.$vnode;
    vm.$options._parentVnode = parentVnode;
    vm.$vnode = parentVnode; // update vm's placeholder node without re-render
    if (vm._vnode) {
        // update child tree's parent
        vm._vnode.parent = parentVnode;
    }
    vm.$options._renderChildren = renderChildren;
    // update $attrs and $listeners hash
    // these are also reactive so they may trigger child update if the child
    // used them during render
    const attrs = parentVnode.data.attrs || emptyObject;
    if (vm._attrsProxy) {
        // force update if attrs are accessed and has changed since it may be
        // passed to a child component.
        if (syncSetupProxy(vm._attrsProxy, attrs, (prevVNode.data && prevVNode.data.attrs) || emptyObject, vm, '$attrs')) {
            needsForceUpdate = true;
        }
    }
    vm.$attrs = attrs;
    // update listeners
    listeners = listeners || emptyObject;
    const prevListeners = vm.$options._parentListeners;
    if (vm._listenersProxy) {
        syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, '$listeners');
    }
    vm.$listeners = vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, prevListeners);
    // update props
    if (propsData && vm.$options.props) {
        toggleObserving(false);
        const props = vm._props;
        const propKeys = vm.$options._propKeys || [];
        for (let i = 0; i < propKeys.length; i++) {
            const key = propKeys[i];
            const propOptions = vm.$options.props; // wtf flow?
            props[key] = validateProp(key, propOptions, propsData, vm);
        }
        toggleObserving(true);
        // keep a copy of raw propsData
        vm.$options.propsData = propsData;
    }
    // resolve slots + force update if has children
    if (needsForceUpdate) {
        vm.$slots = resolveSlots(renderChildren, parentVnode.context);
        vm.$forceUpdate();
    }
    {
        isUpdatingChildComponent = false;
    }
}
function isInInactiveTree(vm) {
    while (vm && (vm = vm.$parent)) {
        if (vm._inactive)
            return true;
    }
    return false;
}
function activateChildComponent(vm, direct) {
    if (direct) {
        vm._directInactive = false;
        if (isInInactiveTree(vm)) {
            return;
        }
    }
    else if (vm._directInactive) {
        return;
    }
    if (vm._inactive || vm._inactive === null) {
        vm._inactive = false;
        for (let i = 0; i < vm.$children.length; i++) {
            activateChildComponent(vm.$children[i]);
        }
        callHook$1(vm, 'activated');
    }
}
function deactivateChildComponent(vm, direct) {
    if (direct) {
        vm._directInactive = true;
        if (isInInactiveTree(vm)) {
            return;
        }
    }
    if (!vm._inactive) {
        vm._inactive = true;
        for (let i = 0; i < vm.$children.length; i++) {
            deactivateChildComponent(vm.$children[i]);
        }
        callHook$1(vm, 'deactivated');
    }
}
function callHook$1(vm, hook, args, setContext = true) {
    // #7573 disable dep collection when invoking lifecycle hooks
    pushTarget();
    const prev = currentInstance;
    setContext && setCurrentInstance(vm);
    const handlers = vm.$options[hook];
    const info = `${hook} hook`;
    if (handlers) {
        for (let i = 0, j = handlers.length; i < j; i++) {
            invokeWithErrorHandling(handlers[i], vm, args || null, vm, info);
        }
    }
    if (vm._hasHookEvent) {
        vm.$emit('hook:' + hook);
    }
    setContext && setCurrentInstance(prev);
    popTarget();
}

const MAX_UPDATE_COUNT = 100;
const queue = [];
const activatedChildren = [];
let has = {};
let circular = {};
let waiting = false;
let flushing = false;
let index = 0;
/**
 * Reset the scheduler's state.
 */
function resetSchedulerState() {
    index = queue.length = activatedChildren.length = 0;
    has = {};
    {
        circular = {};
    }
    waiting = flushing = false;
}
// Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.
let currentFlushTimestamp = 0;
// Async edge case fix requires storing an event listener's attach timestamp.
let getNow = Date.now;
// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)
if (inBrowser && !isIE) {
    const performance = window.performance;
    if (performance &&
        typeof performance.now === 'function' &&
        getNow() > document.createEvent('Event').timeStamp) {
        // if the event timestamp, although evaluated AFTER the Date.now(), is
        // smaller than it, it means the event is using a hi-res timestamp,
        // and we need to use the hi-res version for event listener timestamps as
        // well.
        getNow = () => performance.now();
    }
}
const sortCompareFn = (a, b) => {
    if (a.post) {
        if (!b.post)
            return 1;
    }
    else if (b.post) {
        return -1;
    }
    return a.id - b.id;
};
/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue() {
    currentFlushTimestamp = getNow();
    flushing = true;
    let watcher, id;
    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child)
    // 2. A component's user watchers are run before its render watcher (because
    //    user watchers are created before the render watcher)
    // 3. If a component is destroyed during a parent component's watcher run,
    //    its watchers can be skipped.
    queue.sort(sortCompareFn);
    // do not cache length because more watchers might be pushed
    // as we run existing watchers
    for (index = 0; index < queue.length; index++) {
        watcher = queue[index];
        if (watcher.before) {
            watcher.before();
        }
        id = watcher.id;
        has[id] = null;
        watcher.run();
        // in dev build, check and stop circular updates.
        if (has[id] != null) {
            circular[id] = (circular[id] || 0) + 1;
            if (circular[id] > MAX_UPDATE_COUNT) {
                warn('You may have an infinite update loop ' +
                    (watcher.user
                        ? `in watcher with expression "${watcher.expression}"`
                        : `in a component render function.`), watcher.vm);
                break;
            }
        }
    }
    // keep copies of post queues before resetting state
    const activatedQueue = activatedChildren.slice();
    const updatedQueue = queue.slice();
    resetSchedulerState();
    // call component updated and activated hooks
    callActivatedHooks(activatedQueue);
    callUpdatedHooks(updatedQueue);
    cleanupDeps();
    // devtool hook
    /* istanbul ignore if */
    if (devtools && config.devtools) {
        devtools.emit('flush');
    }
}
function callUpdatedHooks(queue) {
    let i = queue.length;
    while (i--) {
        const watcher = queue[i];
        const vm = watcher.vm;
        if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
            callHook$1(vm, 'updated');
        }
    }
}
/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent(vm) {
    // setting _inactive to false here so that a render function can
    // rely on checking whether it's in an inactive tree (e.g. router-view)
    vm._inactive = false;
    activatedChildren.push(vm);
}
function callActivatedHooks(queue) {
    for (let i = 0; i < queue.length; i++) {
        queue[i]._inactive = true;
        activateChildComponent(queue[i], true /* true */);
    }
}
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher(watcher) {
    const id = watcher.id;
    if (has[id] != null) {
        return;
    }
    if (watcher === Dep.target && watcher.noRecurse) {
        return;
    }
    has[id] = true;
    if (!flushing) {
        queue.push(watcher);
    }
    else {
        // if already flushing, splice the watcher based on its id
        // if already past its id, it will be run next immediately.
        let i = queue.length - 1;
        while (i > index && queue[i].id > watcher.id) {
            i--;
        }
        queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
        waiting = true;
        if (!config.async) {
            flushSchedulerQueue();
            return;
        }
        nextTick(flushSchedulerQueue);
    }
}

function initProvide(vm) {
    const provideOption = vm.$options.provide;
    if (provideOption) {
        const provided = isFunction(provideOption)
            ? provideOption.call(vm)
            : provideOption;
        if (!isObject(provided)) {
            return;
        }
        const source = resolveProvided(vm);
        // IE9 doesn't support Object.getOwnPropertyDescriptors so we have to
        // iterate the keys ourselves.
        const keys = hasSymbol ? Reflect.ownKeys(provided) : Object.keys(provided);
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            Object.defineProperty(source, key, Object.getOwnPropertyDescriptor(provided, key));
        }
    }
}
function initInjections(vm) {
    const result = resolveInject(vm.$options.inject, vm);
    if (result) {
        toggleObserving(false);
        Object.keys(result).forEach(key => {
            /* istanbul ignore else */
            {
                defineReactive(vm, key, result[key], () => {
                    warn(`Avoid mutating an injected value directly since the changes will be ` +
                        `overwritten whenever the provided component re-renders. ` +
                        `injection being mutated: "${key}"`, vm);
                });
            }
        });
        toggleObserving(true);
    }
}
function resolveInject(inject, vm) {
    if (inject) {
        // inject is :any because flow is not smart enough to figure out cached
        const result = Object.create(null);
        const keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            // #6574 in case the inject object is observed...
            if (key === '__ob__')
                continue;
            const provideKey = inject[key].from;
            if (provideKey in vm._provided) {
                result[key] = vm._provided[provideKey];
            }
            else if ('default' in inject[key]) {
                const provideDefault = inject[key].default;
                result[key] = isFunction(provideDefault)
                    ? provideDefault.call(vm)
                    : provideDefault;
            }
            else {
                warn(`Injection "${key}" not found`, vm);
            }
        }
        return result;
    }
}

function FunctionalRenderContext(data, props, children, parent, Ctor) {
    const options = Ctor.options;
    // ensure the createElement function in functional components
    // gets a unique context - this is necessary for correct named slot check
    let contextVm;
    if (hasOwn(parent, '_uid')) {
        contextVm = Object.create(parent);
        contextVm._original = parent;
    }
    else {
        // the context vm passed in is a functional context as well.
        // in this case we want to make sure we are able to get a hold to the
        // real context instance.
        contextVm = parent;
        // @ts-ignore
        parent = parent._original;
    }
    const isCompiled = isTrue(options._compiled);
    const needNormalization = !isCompiled;
    this.data = data;
    this.props = props;
    this.children = children;
    this.parent = parent;
    this.listeners = data.on || emptyObject;
    this.injections = resolveInject(options.inject, parent);
    this.slots = () => {
        if (!this.$slots) {
            normalizeScopedSlots(parent, data.scopedSlots, (this.$slots = resolveSlots(children, parent)));
        }
        return this.$slots;
    };
    Object.defineProperty(this, 'scopedSlots', {
        enumerable: true,
        get() {
            return normalizeScopedSlots(parent, data.scopedSlots, this.slots());
        }
    });
    // support for compiled functional template
    if (isCompiled) {
        // exposing $options for renderStatic()
        this.$options = options;
        // pre-resolve slots for renderSlot()
        this.$slots = this.slots();
        this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);
    }
    if (options._scopeId) {
        this._c = (a, b, c, d) => {
            const vnode = createElement$1(contextVm, a, b, c, d, needNormalization);
            if (vnode && !isArray(vnode)) {
                vnode.fnScopeId = options._scopeId;
                vnode.fnContext = parent;
            }
            return vnode;
        };
    }
    else {
        this._c = (a, b, c, d) => createElement$1(contextVm, a, b, c, d, needNormalization);
    }
}
installRenderHelpers(FunctionalRenderContext.prototype);
function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
    const options = Ctor.options;
    const props = {};
    const propOptions = options.props;
    if (isDef(propOptions)) {
        for (const key in propOptions) {
            props[key] = validateProp(key, propOptions, propsData || emptyObject);
        }
    }
    else {
        if (isDef(data.attrs))
            mergeProps(props, data.attrs);
        if (isDef(data.props))
            mergeProps(props, data.props);
    }
    const renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
    const vnode = options.render.call(null, renderContext._c, renderContext);
    if (vnode instanceof VNode) {
        return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
    }
    else if (isArray(vnode)) {
        const vnodes = normalizeChildren(vnode) || [];
        const res = new Array(vnodes.length);
        for (let i = 0; i < vnodes.length; i++) {
            res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
        }
        return res;
    }
}
function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
    // #7817 clone node before setting fnContext, otherwise if the node is reused
    // (e.g. it was from a cached normal slot) the fnContext causes named slots
    // that should not be matched to match.
    const clone = cloneVNode(vnode);
    clone.fnContext = contextVm;
    clone.fnOptions = options;
    {
        (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext =
            renderContext;
    }
    if (data.slot) {
        (clone.data || (clone.data = {})).slot = data.slot;
    }
    return clone;
}
function mergeProps(to, from) {
    for (const key in from) {
        to[camelize(key)] = from[key];
    }
}

function getComponentName(options) {
    return options.name || options.__name || options._componentTag;
}
// inline hooks to be invoked on component VNodes during patch
const componentVNodeHooks = {
    init(vnode, hydrating) {
        if (vnode.componentInstance &&
            !vnode.componentInstance._isDestroyed &&
            vnode.data.keepAlive) {
            // kept-alive components, treat as a patch
            const mountedNode = vnode; // work around flow
            componentVNodeHooks.prepatch(mountedNode, mountedNode);
        }
        else {
            const child = (vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance));
            child.$mount(hydrating ? vnode.elm : undefined, hydrating);
        }
    },
    prepatch(oldVnode, vnode) {
        const options = vnode.componentOptions;
        const child = (vnode.componentInstance = oldVnode.componentInstance);
        updateChildComponent(child, options.propsData, // updated props
        options.listeners, // updated listeners
        vnode, // new parent vnode
        options.children // new children
        );
    },
    insert(vnode) {
        const { context, componentInstance } = vnode;
        if (!componentInstance._isMounted) {
            componentInstance._isMounted = true;
            callHook$1(componentInstance, 'mounted');
        }
        if (vnode.data.keepAlive) {
            if (context._isMounted) {
                // vue-router#1212
                // During updates, a kept-alive component's child components may
                // change, so directly walking the tree here may call activated hooks
                // on incorrect children. Instead we push them into a queue which will
                // be processed after the whole patch process ended.
                queueActivatedComponent(componentInstance);
            }
            else {
                activateChildComponent(componentInstance, true /* direct */);
            }
        }
    },
    destroy(vnode) {
        const { componentInstance } = vnode;
        if (!componentInstance._isDestroyed) {
            if (!vnode.data.keepAlive) {
                componentInstance.$destroy();
            }
            else {
                deactivateChildComponent(componentInstance, true /* direct */);
            }
        }
    }
};
const hooksToMerge = Object.keys(componentVNodeHooks);
function createComponent(Ctor, data, context, children, tag) {
    if (isUndef(Ctor)) {
        return;
    }
    const baseCtor = context.$options._base;
    // plain options object: turn it into a constructor
    if (isObject(Ctor)) {
        Ctor = baseCtor.extend(Ctor);
    }
    // if at this stage it's not a constructor or an async component factory,
    // reject.
    if (typeof Ctor !== 'function') {
        {
            warn(`Invalid Component definition: ${String(Ctor)}`, context);
        }
        return;
    }
    // async component
    let asyncFactory;
    // @ts-expect-error
    if (isUndef(Ctor.cid)) {
        asyncFactory = Ctor;
        Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
        if (Ctor === undefined) {
            // return a placeholder node for async component, which is rendered
            // as a comment node but preserves all the raw information for the node.
            // the information will be used for async server-rendering and hydration.
            return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
        }
    }
    data = data || {};
    // resolve constructor options in case global mixins are applied after
    // component constructor creation
    resolveConstructorOptions(Ctor);
    // transform component v-model data into props & events
    if (isDef(data.model)) {
        // @ts-expect-error
        transformModel(Ctor.options, data);
    }
    // extract props
    // @ts-expect-error
    const propsData = extractPropsFromVNodeData(data, Ctor, tag);
    // functional component
    // @ts-expect-error
    if (isTrue(Ctor.options.functional)) {
        return createFunctionalComponent(Ctor, propsData, data, context, children);
    }
    // extract listeners, since these needs to be treated as
    // child component listeners instead of DOM listeners
    const listeners = data.on;
    // replace with listeners with .native modifier
    // so it gets processed during parent component patch.
    data.on = data.nativeOn;
    // @ts-expect-error
    if (isTrue(Ctor.options.abstract)) {
        // abstract components do not keep anything
        // other than props & listeners & slot
        // work around flow
        const slot = data.slot;
        data = {};
        if (slot) {
            data.slot = slot;
        }
    }
    // install component management hooks onto the placeholder node
    installComponentHooks(data);
    // return a placeholder vnode
    // @ts-expect-error
    const name = getComponentName(Ctor.options) || tag;
    const vnode = new VNode(
    // @ts-expect-error
    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`, data, undefined, undefined, undefined, context, 
    // @ts-expect-error
    { Ctor, propsData, listeners, tag, children }, asyncFactory);
    return vnode;
}
function createComponentInstanceForVnode(
// we know it's MountedComponentVNode but flow doesn't
vnode, 
// activeInstance in lifecycle state
parent) {
    const options = {
        _isComponent: true,
        _parentVnode: vnode,
        parent
    };
    // check inline-template render functions
    const inlineTemplate = vnode.data.inlineTemplate;
    if (isDef(inlineTemplate)) {
        options.render = inlineTemplate.render;
        options.staticRenderFns = inlineTemplate.staticRenderFns;
    }
    return new vnode.componentOptions.Ctor(options);
}
function installComponentHooks(data) {
    const hooks = data.hook || (data.hook = {});
    for (let i = 0; i < hooksToMerge.length; i++) {
        const key = hooksToMerge[i];
        const existing = hooks[key];
        const toMerge = componentVNodeHooks[key];
        // @ts-expect-error
        if (existing !== toMerge && !(existing && existing._merged)) {
            hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge;
        }
    }
}
function mergeHook(f1, f2) {
    const merged = (a, b) => {
        // flow complains about extra args which is why we use any
        f1(a, b);
        f2(a, b);
    };
    merged._merged = true;
    return merged;
}
// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel(options, data) {
    const prop = (options.model && options.model.prop) || 'value';
    const event = (options.model && options.model.event) || 'input';
    (data.attrs || (data.attrs = {}))[prop] = data.model.value;
    const on = data.on || (data.on = {});
    const existing = on[event];
    const callback = data.model.callback;
    if (isDef(existing)) {
        if (isArray(existing)
            ? existing.indexOf(callback) === -1
            : existing !== callback) {
            on[event] = [callback].concat(existing);
        }
    }
    else {
        on[event] = callback;
    }
}

let warn = noop;
let tip = noop;
let generateComponentTrace; // work around flow check
let formatComponentName;
{
    const hasConsole = typeof console !== 'undefined';
    const classifyRE = /(?:^|[-_])(\w)/g;
    const classify = str => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');
    warn = (msg, vm = currentInstance) => {
        const trace = vm ? generateComponentTrace(vm) : '';
        if (config.warnHandler) {
            config.warnHandler.call(null, msg, vm, trace);
        }
        else if (hasConsole && !config.silent) {
            console.error(`[Vue warn]: ${msg}${trace}`);
        }
    };
    tip = (msg, vm) => {
        if (hasConsole && !config.silent) {
            console.warn(`[Vue tip]: ${msg}` + (vm ? generateComponentTrace(vm) : ''));
        }
    };
    formatComponentName = (vm, includeFile) => {
        if (vm.$root === vm) {
            return '<Root>';
        }
        const options = isFunction(vm) && vm.cid != null
            ? vm.options
            : vm._isVue
                ? vm.$options || vm.constructor.options
                : vm;
        let name = getComponentName(options);
        const file = options.__file;
        if (!name && file) {
            const match = file.match(/([^/\\]+)\.vue$/);
            name = match && match[1];
        }
        return ((name ? `<${classify(name)}>` : `<Anonymous>`) +
            (file && includeFile !== false ? ` at ${file}` : ''));
    };
    const repeat = (str, n) => {
        let res = '';
        while (n) {
            if (n % 2 === 1)
                res += str;
            if (n > 1)
                str += str;
            n >>= 1;
        }
        return res;
    };
    generateComponentTrace = (vm) => {
        if (vm._isVue && vm.$parent) {
            const tree = [];
            let currentRecursiveSequence = 0;
            while (vm) {
                if (tree.length > 0) {
                    const last = tree[tree.length - 1];
                    if (last.constructor === vm.constructor) {
                        currentRecursiveSequence++;
                        vm = vm.$parent;
                        continue;
                    }
                    else if (currentRecursiveSequence > 0) {
                        tree[tree.length - 1] = [last, currentRecursiveSequence];
                        currentRecursiveSequence = 0;
                    }
                }
                tree.push(vm);
                vm = vm.$parent;
            }
            return ('\n\nfound in\n\n' +
                tree
                    .map((vm, i) => `${i === 0 ? '---> ' : repeat(' ', 5 + i * 2)}${isArray(vm)
                    ? `${formatComponentName(vm[0])}... (${vm[1]} recursive calls)`
                    : formatComponentName(vm)}`)
                    .join('\n'));
        }
        else {
            return `\n\n(found in ${formatComponentName(vm)})`;
        }
    };
}

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
const strats = config.optionMergeStrategies;
/**
 * Options with restrictions
 */
{
    strats.el = strats.propsData = function (parent, child, vm, key) {
        if (!vm) {
            warn(`option "${key}" can only be used during instance ` +
                'creation with the `new` keyword.');
        }
        return defaultStrat(parent, child);
    };
}
/**
 * Helper that recursively merges two data objects together.
 */
function mergeData(to, from, recursive = true) {
    if (!from)
        return to;
    let key, toVal, fromVal;
    const keys = hasSymbol
        ? Reflect.ownKeys(from)
        : Object.keys(from);
    for (let i = 0; i < keys.length; i++) {
        key = keys[i];
        // in case the object is already observed...
        if (key === '__ob__')
            continue;
        toVal = to[key];
        fromVal = from[key];
        if (!recursive || !hasOwn(to, key)) {
            set(to, key, fromVal);
        }
        else if (toVal !== fromVal &&
            isPlainObject(toVal) &&
            isPlainObject(fromVal)) {
            mergeData(toVal, fromVal);
        }
    }
    return to;
}
/**
 * Data
 */
function mergeDataOrFn(parentVal, childVal, vm) {
    if (!vm) {
        // in a Vue.extend merge, both should be functions
        if (!childVal) {
            return parentVal;
        }
        if (!parentVal) {
            return childVal;
        }
        // when parentVal & childVal are both present,
        // we need to return a function that returns the
        // merged result of both functions... no need to
        // check if parentVal is a function here because
        // it has to be a function to pass previous merges.
        return function mergedDataFn() {
            return mergeData(isFunction(childVal) ? childVal.call(this, this) : childVal, isFunction(parentVal) ? parentVal.call(this, this) : parentVal);
        };
    }
    else {
        return function mergedInstanceDataFn() {
            // instance merge
            const instanceData = isFunction(childVal)
                ? childVal.call(vm, vm)
                : childVal;
            const defaultData = isFunction(parentVal)
                ? parentVal.call(vm, vm)
                : parentVal;
            if (instanceData) {
                return mergeData(instanceData, defaultData);
            }
            else {
                return defaultData;
            }
        };
    }
}
strats.data = function (parentVal, childVal, vm) {
    if (!vm) {
        if (childVal && typeof childVal !== 'function') {
            warn('The "data" option should be a function ' +
                    'that returns a per-instance value in component ' +
                    'definitions.', vm);
            return parentVal;
        }
        return mergeDataOrFn(parentVal, childVal);
    }
    return mergeDataOrFn(parentVal, childVal, vm);
};
/**
 * Hooks and props are merged as arrays.
 */
function mergeLifecycleHook(parentVal, childVal) {
    const res = childVal
        ? parentVal
            ? parentVal.concat(childVal)
            : isArray(childVal)
                ? childVal
                : [childVal]
        : parentVal;
    return res ? dedupeHooks(res) : res;
}
function dedupeHooks(hooks) {
    const res = [];
    for (let i = 0; i < hooks.length; i++) {
        if (res.indexOf(hooks[i]) === -1) {
            res.push(hooks[i]);
        }
    }
    return res;
}
LIFECYCLE_HOOKS.forEach(hook => {
    strats[hook] = mergeLifecycleHook;
});
/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets(parentVal, childVal, vm, key) {
    const res = Object.create(parentVal || null);
    if (childVal) {
        assertObjectType(key, childVal, vm);
        return extend(res, childVal);
    }
    else {
        return res;
    }
}
ASSET_TYPES.forEach(function (type) {
    strats[type + 's'] = mergeAssets;
});
/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal, vm, key) {
    // work around Firefox's Object.prototype.watch...
    //@ts-expect-error work around
    if (parentVal === nativeWatch)
        parentVal = undefined;
    //@ts-expect-error work around
    if (childVal === nativeWatch)
        childVal = undefined;
    /* istanbul ignore if */
    if (!childVal)
        return Object.create(parentVal || null);
    {
        assertObjectType(key, childVal, vm);
    }
    if (!parentVal)
        return childVal;
    const ret = {};
    extend(ret, parentVal);
    for (const key in childVal) {
        let parent = ret[key];
        const child = childVal[key];
        if (parent && !isArray(parent)) {
            parent = [parent];
        }
        ret[key] = parent ? parent.concat(child) : isArray(child) ? child : [child];
    }
    return ret;
};
/**
 * Other object hashes.
 */
strats.props =
    strats.methods =
        strats.inject =
            strats.computed =
                function (parentVal, childVal, vm, key) {
                    if (childVal && true) {
                        assertObjectType(key, childVal, vm);
                    }
                    if (!parentVal)
                        return childVal;
                    const ret = Object.create(null);
                    extend(ret, parentVal);
                    if (childVal)
                        extend(ret, childVal);
                    return ret;
                };
strats.provide = function (parentVal, childVal) {
    if (!parentVal)
        return childVal;
    return function () {
        const ret = Object.create(null);
        mergeData(ret, isFunction(parentVal) ? parentVal.call(this) : parentVal);
        if (childVal) {
            mergeData(ret, isFunction(childVal) ? childVal.call(this) : childVal, false // non-recursive
            );
        }
        return ret;
    };
};
/**
 * Default strategy.
 */
const defaultStrat = function (parentVal, childVal) {
    return childVal === undefined ? parentVal : childVal;
};
/**
 * Validate component names
 */
function checkComponents(options) {
    for (const key in options.components) {
        validateComponentName(key);
    }
}
function validateComponentName(name) {
    if (!new RegExp(`^[a-zA-Z][\\-\\.0-9_${unicodeRegExp.source}]*$`).test(name)) {
        warn('Invalid component name: "' +
            name +
            '". Component names ' +
            'should conform to valid custom element name in html5 specification.');
    }
    if (isBuiltInTag(name) || config.isReservedTag(name)) {
        warn('Do not use built-in or reserved HTML elements as component ' +
            'id: ' +
            name);
    }
}
/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps(options, vm) {
    const props = options.props;
    if (!props)
        return;
    const res = {};
    let i, val, name;
    if (isArray(props)) {
        i = props.length;
        while (i--) {
            val = props[i];
            if (typeof val === 'string') {
                name = camelize(val);
                res[name] = { type: null };
            }
            else {
                warn('props must be strings when using array syntax.');
            }
        }
    }
    else if (isPlainObject(props)) {
        for (const key in props) {
            val = props[key];
            name = camelize(key);
            res[name] = isPlainObject(val) ? val : { type: val };
        }
    }
    else {
        warn(`Invalid value for option "props": expected an Array or an Object, ` +
            `but got ${toRawType(props)}.`, vm);
    }
    options.props = res;
}
/**
 * Normalize all injections into Object-based format
 */
function normalizeInject(options, vm) {
    const inject = options.inject;
    if (!inject)
        return;
    const normalized = (options.inject = {});
    if (isArray(inject)) {
        for (let i = 0; i < inject.length; i++) {
            normalized[inject[i]] = { from: inject[i] };
        }
    }
    else if (isPlainObject(inject)) {
        for (const key in inject) {
            const val = inject[key];
            normalized[key] = isPlainObject(val)
                ? extend({ from: key }, val)
                : { from: val };
        }
    }
    else {
        warn(`Invalid value for option "inject": expected an Array or an Object, ` +
            `but got ${toRawType(inject)}.`, vm);
    }
}
/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives$1(options) {
    const dirs = options.directives;
    if (dirs) {
        for (const key in dirs) {
            const def = dirs[key];
            if (isFunction(def)) {
                dirs[key] = { bind: def, update: def };
            }
        }
    }
}
function assertObjectType(name, value, vm) {
    if (!isPlainObject(value)) {
        warn(`Invalid value for option "${name}": expected an Object, ` +
            `but got ${toRawType(value)}.`, vm);
    }
}
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions(parent, child, vm) {
    {
        checkComponents(child);
    }
    if (isFunction(child)) {
        // @ts-expect-error
        child = child.options;
    }
    normalizeProps(child, vm);
    normalizeInject(child, vm);
    normalizeDirectives$1(child);
    // Apply extends and mixins on the child options,
    // but only if it is a raw options object that isn't
    // the result of another mergeOptions call.
    // Only merged options has the _base property.
    if (!child._base) {
        if (child.extends) {
            parent = mergeOptions(parent, child.extends, vm);
        }
        if (child.mixins) {
            for (let i = 0, l = child.mixins.length; i < l; i++) {
                parent = mergeOptions(parent, child.mixins[i], vm);
            }
        }
    }
    const options = {};
    let key;
    for (key in parent) {
        mergeField(key);
    }
    for (key in child) {
        if (!hasOwn(parent, key)) {
            mergeField(key);
        }
    }
    function mergeField(key) {
        const strat = strats[key] || defaultStrat;
        options[key] = strat(parent[key], child[key], vm, key);
    }
    return options;
}
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset(options, type, id, warnMissing) {
    /* istanbul ignore if */
    if (typeof id !== 'string') {
        return;
    }
    const assets = options[type];
    // check local registration variations first
    if (hasOwn(assets, id))
        return assets[id];
    const camelizedId = camelize(id);
    if (hasOwn(assets, camelizedId))
        return assets[camelizedId];
    const PascalCaseId = capitalize(camelizedId);
    if (hasOwn(assets, PascalCaseId))
        return assets[PascalCaseId];
    // fallback to prototype chain
    const res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
    if (warnMissing && !res) {
        warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id);
    }
    return res;
}

function validateProp(key, propOptions, propsData, vm) {
    const prop = propOptions[key];
    const absent = !hasOwn(propsData, key);
    let value = propsData[key];
    // boolean casting
    const booleanIndex = getTypeIndex(Boolean, prop.type);
    if (booleanIndex > -1) {
        if (absent && !hasOwn(prop, 'default')) {
            value = false;
        }
        else if (value === '' || value === hyphenate(key)) {
            // only cast empty string / same name to boolean if
            // boolean has higher priority
            const stringIndex = getTypeIndex(String, prop.type);
            if (stringIndex < 0 || booleanIndex < stringIndex) {
                value = true;
            }
        }
    }
    // check default value
    if (value === undefined) {
        value = getPropDefaultValue(vm, prop, key);
        // since the default value is a fresh copy,
        // make sure to observe it.
        const prevShouldObserve = shouldObserve;
        toggleObserving(true);
        observe(value);
        toggleObserving(prevShouldObserve);
    }
    {
        assertProp(prop, key, value, vm, absent);
    }
    return value;
}
/**
 * Get the default value of a prop.
 */
function getPropDefaultValue(vm, prop, key) {
    // no default, return undefined
    if (!hasOwn(prop, 'default')) {
        return undefined;
    }
    const def = prop.default;
    // warn against non-factory defaults for Object & Array
    if (isObject(def)) {
        warn('Invalid default value for prop "' +
            key +
            '": ' +
            'Props with type Object/Array must use a factory function ' +
            'to return the default value.', vm);
    }
    // the raw prop value was also undefined from previous render,
    // return previous default value to avoid unnecessary watcher trigger
    if (vm &&
        vm.$options.propsData &&
        vm.$options.propsData[key] === undefined &&
        vm._props[key] !== undefined) {
        return vm._props[key];
    }
    // call factory function for non-Function types
    // a value is Function if its prototype is function even across different execution context
    return isFunction(def) && getType(prop.type) !== 'Function'
        ? def.call(vm)
        : def;
}
/**
 * Assert whether a prop is valid.
 */
function assertProp(prop, name, value, vm, absent) {
    if (prop.required && absent) {
        warn('Missing required prop: "' + name + '"', vm);
        return;
    }
    if (value == null && !prop.required) {
        return;
    }
    let type = prop.type;
    let valid = !type || type === true;
    const expectedTypes = [];
    if (type) {
        if (!isArray(type)) {
            type = [type];
        }
        for (let i = 0; i < type.length && !valid; i++) {
            const assertedType = assertType(value, type[i], vm);
            expectedTypes.push(assertedType.expectedType || '');
            valid = assertedType.valid;
        }
    }
    const haveExpectedTypes = expectedTypes.some(t => t);
    if (!valid && haveExpectedTypes) {
        warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
        return;
    }
    const validator = prop.validator;
    if (validator) {
        if (!validator(value)) {
            warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
        }
    }
}
const simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;
function assertType(value, type, vm) {
    let valid;
    const expectedType = getType(type);
    if (simpleCheckRE.test(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        // for primitive wrapper objects
        if (!valid && t === 'object') {
            valid = value instanceof type;
        }
    }
    else if (expectedType === 'Object') {
        valid = isPlainObject(value);
    }
    else if (expectedType === 'Array') {
        valid = isArray(value);
    }
    else {
        try {
            valid = value instanceof type;
        }
        catch (e) {
            warn('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
            valid = false;
        }
    }
    return {
        valid,
        expectedType
    };
}
const functionTypeCheckRE = /^\s*function (\w+)/;
/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType(fn) {
    const match = fn && fn.toString().match(functionTypeCheckRE);
    return match ? match[1] : '';
}
function isSameType(a, b) {
    return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if (!isArray(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
    }
    for (let i = 0, len = expectedTypes.length; i < len; i++) {
        if (isSameType(expectedTypes[i], type)) {
            return i;
        }
    }
    return -1;
}
function getInvalidTypeMessage(name, value, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name}".` +
        ` Expected ${expectedTypes.map(capitalize).join(', ')}`;
    const expectedType = expectedTypes[0];
    const receivedType = toRawType(value);
    // check if we need to specify expected value
    if (expectedTypes.length === 1 &&
        isExplicable(expectedType) &&
        isExplicable(typeof value) &&
        !isBoolean(expectedType, receivedType)) {
        message += ` with value ${styleValue(value, expectedType)}`;
    }
    message += `, got ${receivedType} `;
    // check if we need to specify received value
    if (isExplicable(receivedType)) {
        message += `with value ${styleValue(value, receivedType)}.`;
    }
    return message;
}
function styleValue(value, type) {
    if (type === 'String') {
        return `"${value}"`;
    }
    else if (type === 'Number') {
        return `${Number(value)}`;
    }
    else {
        return `${value}`;
    }
}
const EXPLICABLE_TYPES = ['string', 'number', 'boolean'];
function isExplicable(value) {
    return EXPLICABLE_TYPES.some(elem => value.toLowerCase() === elem);
}
function isBoolean(...args) {
    return args.some(elem => elem.toLowerCase() === 'boolean');
}

/* not type checking this file because flow doesn't play well with Proxy */
let initProxy;
{
    const allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' +
        'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
        'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +
        'require' // for Webpack/Browserify
    );
    const warnNonPresent = (target, key) => {
        warn(`Property or method "${key}" is not defined on the instance but ` +
            'referenced during render. Make sure that this property is reactive, ' +
            'either in the data option, or for class-based components, by ' +
            'initializing the property. ' +
            'See: https://v2.vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
    };
    const warnReservedPrefix = (target, key) => {
        warn(`Property "${key}" must be accessed with "$data.${key}" because ` +
            'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
            'prevent conflicts with Vue internals. ' +
            'See: https://v2.vuejs.org/v2/api/#data', target);
    };
    const hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);
    if (hasProxy) {
        const isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
        config.keyCodes = new Proxy(config.keyCodes, {
            set(target, key, value) {
                if (isBuiltInModifier(key)) {
                    warn(`Avoid overwriting built-in modifier in config.keyCodes: .${key}`);
                    return false;
                }
                else {
                    target[key] = value;
                    return true;
                }
            }
        });
    }
    const hasHandler = {
        has(target, key) {
            const has = key in target;
            const isAllowed = allowedGlobals(key) ||
                (typeof key === 'string' &&
                    key.charAt(0) === '_' &&
                    !(key in target.$data));
            if (!has && !isAllowed) {
                if (key in target.$data)
                    warnReservedPrefix(target, key);
                else
                    warnNonPresent(target, key);
            }
            return has || !isAllowed;
        }
    };
    const getHandler = {
        get(target, key) {
            if (typeof key === 'string' && !(key in target)) {
                if (key in target.$data)
                    warnReservedPrefix(target, key);
                else
                    warnNonPresent(target, key);
            }
            return target[key];
        }
    };
    initProxy = function initProxy(vm) {
        if (hasProxy) {
            // determine which proxy handler to use
            const options = vm.$options;
            const handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
            vm._renderProxy = new Proxy(vm, handlers);
        }
        else {
            vm._renderProxy = vm;
        }
    };
}

const sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop,
    set: noop
};
function proxy(target, sourceKey, key) {
    sharedPropertyDefinition.get = function proxyGetter() {
        return this[sourceKey][key];
    };
    sharedPropertyDefinition.set = function proxySetter(val) {
        this[sourceKey][key] = val;
    };
    Object.defineProperty(target, key, sharedPropertyDefinition);
}
function initState(vm) {
    const opts = vm.$options;
    if (opts.props)
        initProps$1(vm, opts.props);
    // Composition API
    initSetup(vm);
    if (opts.methods)
        initMethods(vm, opts.methods);
    if (opts.data) {
        initData(vm);
    }
    else {
        const ob = observe((vm._data = {}));
        ob && ob.vmCount++;
    }
    if (opts.computed)
        initComputed$1(vm, opts.computed);
    if (opts.watch && opts.watch !== nativeWatch) {
        initWatch(vm, opts.watch);
    }
}
function initProps$1(vm, propsOptions) {
    const propsData = vm.$options.propsData || {};
    const props = (vm._props = shallowReactive({}));
    // cache prop keys so that future props updates can iterate using Array
    // instead of dynamic object key enumeration.
    const keys = (vm.$options._propKeys = []);
    const isRoot = !vm.$parent;
    // root instance props should be converted
    if (!isRoot) {
        toggleObserving(false);
    }
    for (const key in propsOptions) {
        keys.push(key);
        const value = validateProp(key, propsOptions, propsData, vm);
        /* istanbul ignore else */
        {
            const hyphenatedKey = hyphenate(key);
            if (isReservedAttribute(hyphenatedKey) ||
                config.isReservedAttr(hyphenatedKey)) {
                warn(`"${hyphenatedKey}" is a reserved attribute and cannot be used as component prop.`, vm);
            }
            defineReactive(props, key, value, () => {
                if (!isRoot && !isUpdatingChildComponent) {
                    warn(`Avoid mutating a prop directly since the value will be ` +
                        `overwritten whenever the parent component re-renders. ` +
                        `Instead, use a data or computed property based on the prop's ` +
                        `value. Prop being mutated: "${key}"`, vm);
                }
            });
        }
        // static props are already proxied on the component's prototype
        // during Vue.extend(). We only need to proxy props defined at
        // instantiation here.
        if (!(key in vm)) {
            proxy(vm, `_props`, key);
        }
    }
    toggleObserving(true);
}
function initData(vm) {
    let data = vm.$options.data;
    data = vm._data = isFunction(data) ? getData(data, vm) : data || {};
    if (!isPlainObject(data)) {
        data = {};
        warn('data functions should return an object:\n' +
                'https://v2.vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
    }
    // proxy data on instance
    const keys = Object.keys(data);
    const props = vm.$options.props;
    const methods = vm.$options.methods;
    let i = keys.length;
    while (i--) {
        const key = keys[i];
        {
            if (methods && hasOwn(methods, key)) {
                warn(`Method "${key}" has already been defined as a data property.`, vm);
            }
        }
        if (props && hasOwn(props, key)) {
            warn(`The data property "${key}" is already declared as a prop. ` +
                    `Use prop default value instead.`, vm);
        }
        else if (!isReserved(key)) {
            proxy(vm, `_data`, key);
        }
    }
    // observe data
    const ob = observe(data);
    ob && ob.vmCount++;
}
function getData(data, vm) {
    // #7573 disable dep collection when invoking data getters
    pushTarget();
    try {
        return data.call(vm, vm);
    }
    catch (e) {
        handleError(e, vm, `data()`);
        return {};
    }
    finally {
        popTarget();
    }
}
const computedWatcherOptions = { lazy: true };
function initComputed$1(vm, computed) {
    // $flow-disable-line
    const watchers = (vm._computedWatchers = Object.create(null));
    // computed properties are just getters during SSR
    const isSSR = isServerRendering();
    for (const key in computed) {
        const userDef = computed[key];
        const getter = isFunction(userDef) ? userDef : userDef.get;
        if (getter == null) {
            warn(`Getter is missing for computed property "${key}".`, vm);
        }
        if (!isSSR) {
            // create internal watcher for the computed property.
            watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
        }
        // component-defined computed properties are already defined on the
        // component prototype. We only need to define computed properties defined
        // at instantiation here.
        if (!(key in vm)) {
            defineComputed(vm, key, userDef);
        }
        else {
            if (key in vm.$data) {
                warn(`The computed property "${key}" is already defined in data.`, vm);
            }
            else if (vm.$options.props && key in vm.$options.props) {
                warn(`The computed property "${key}" is already defined as a prop.`, vm);
            }
            else if (vm.$options.methods && key in vm.$options.methods) {
                warn(`The computed property "${key}" is already defined as a method.`, vm);
            }
        }
    }
}
function defineComputed(target, key, userDef) {
    const shouldCache = !isServerRendering();
    if (isFunction(userDef)) {
        sharedPropertyDefinition.get = shouldCache
            ? createComputedGetter(key)
            : createGetterInvoker(userDef);
        sharedPropertyDefinition.set = noop;
    }
    else {
        sharedPropertyDefinition.get = userDef.get
            ? shouldCache && userDef.cache !== false
                ? createComputedGetter(key)
                : createGetterInvoker(userDef.get)
            : noop;
        sharedPropertyDefinition.set = userDef.set || noop;
    }
    if (sharedPropertyDefinition.set === noop) {
        sharedPropertyDefinition.set = function () {
            warn(`Computed property "${key}" was assigned to but it has no setter.`, this);
        };
    }
    Object.defineProperty(target, key, sharedPropertyDefinition);
}
function createComputedGetter(key) {
    return function computedGetter() {
        const watcher = this._computedWatchers && this._computedWatchers[key];
        if (watcher) {
            if (watcher.dirty) {
                watcher.evaluate();
            }
            if (Dep.target) {
                if (Dep.target.onTrack) {
                    Dep.target.onTrack({
                        effect: Dep.target,
                        target: this,
                        type: "get" /* TrackOpTypes.GET */,
                        key
                    });
                }
                watcher.depend();
            }
            return watcher.value;
        }
    };
}
function createGetterInvoker(fn) {
    return function computedGetter() {
        return fn.call(this, this);
    };
}
function initMethods(vm, methods) {
    const props = vm.$options.props;
    for (const key in methods) {
        {
            if (typeof methods[key] !== 'function') {
                warn(`Method "${key}" has type "${typeof methods[key]}" in the component definition. ` +
                    `Did you reference the function correctly?`, vm);
            }
            if (props && hasOwn(props, key)) {
                warn(`Method "${key}" has already been defined as a prop.`, vm);
            }
            if (key in vm && isReserved(key)) {
                warn(`Method "${key}" conflicts with an existing Vue instance method. ` +
                    `Avoid defining component methods that start with _ or $.`);
            }
        }
        vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
    }
}
function initWatch(vm, watch) {
    for (const key in watch) {
        const handler = watch[key];
        if (isArray(handler)) {
            for (let i = 0; i < handler.length; i++) {
                createWatcher(vm, key, handler[i]);
            }
        }
        else {
            createWatcher(vm, key, handler);
        }
    }
}
function createWatcher(vm, expOrFn, handler, options) {
    if (isPlainObject(handler)) {
        options = handler;
        handler = handler.handler;
    }
    if (typeof handler === 'string') {
        handler = vm[handler];
    }
    return vm.$watch(expOrFn, handler, options);
}
function stateMixin(Vue) {
    // flow somehow has problems with directly declared definition object
    // when using Object.defineProperty, so we have to procedurally build up
    // the object here.
    const dataDef = {};
    dataDef.get = function () {
        return this._data;
    };
    const propsDef = {};
    propsDef.get = function () {
        return this._props;
    };
    {
        dataDef.set = function () {
            warn('Avoid replacing instance root $data. ' +
                'Use nested data properties instead.', this);
        };
        propsDef.set = function () {
            warn(`$props is readonly.`, this);
        };
    }
    Object.defineProperty(Vue.prototype, '$data', dataDef);
    Object.defineProperty(Vue.prototype, '$props', propsDef);
    Vue.prototype.$set = set;
    Vue.prototype.$delete = del;
    Vue.prototype.$watch = function (expOrFn, cb, options) {
        const vm = this;
        if (isPlainObject(cb)) {
            return createWatcher(vm, expOrFn, cb, options);
        }
        options = options || {};
        options.user = true;
        const watcher = new Watcher(vm, expOrFn, cb, options);
        if (options.immediate) {
            const info = `callback for immediate watcher "${watcher.expression}"`;
            pushTarget();
            invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
            popTarget();
        }
        return function unwatchFn() {
            watcher.teardown();
        };
    };
}

let uid = 0;
function initMixin$1(Vue) {
    Vue.prototype._init = function (options) {
        const vm = this;
        // a uid
        vm._uid = uid++;
        let startTag, endTag;
        /* istanbul ignore if */
        if (config.performance && mark) {
            startTag = `vue-perf-start:${vm._uid}`;
            endTag = `vue-perf-end:${vm._uid}`;
            mark(startTag);
        }
        // a flag to mark this as a Vue instance without having to do instanceof
        // check
        vm._isVue = true;
        // avoid instances from being observed
        vm.__v_skip = true;
        // effect scope
        vm._scope = new EffectScope(true /* detached */);
        vm._scope._vm = true;
        // merge options
        if (options && options._isComponent) {
            // optimize internal component instantiation
            // since dynamic options merging is pretty slow, and none of the
            // internal component options needs special treatment.
            initInternalComponent(vm, options);
        }
        else {
            vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
        }
        /* istanbul ignore else */
        {
            initProxy(vm);
        }
        // expose real self
        vm._self = vm;
        initLifecycle(vm);
        initEvents(vm);
        initRender(vm);
        callHook$1(vm, 'beforeCreate', undefined, false /* setContext */);
        initInjections(vm); // resolve injections before data/props
        initState(vm);
        initProvide(vm); // resolve provide after data/props
        callHook$1(vm, 'created');
        /* istanbul ignore if */
        if (config.performance && mark) {
            vm._name = formatComponentName(vm, false);
            mark(endTag);
            measure(`vue ${vm._name} init`, startTag, endTag);
        }
        if (vm.$options.el) {
            vm.$mount(vm.$options.el);
        }
    };
}
function initInternalComponent(vm, options) {
    const opts = (vm.$options = Object.create(vm.constructor.options));
    // doing this because it's faster than dynamic enumeration.
    const parentVnode = options._parentVnode;
    opts.parent = options.parent;
    opts._parentVnode = parentVnode;
    const vnodeComponentOptions = parentVnode.componentOptions;
    opts.propsData = vnodeComponentOptions.propsData;
    opts._parentListeners = vnodeComponentOptions.listeners;
    opts._renderChildren = vnodeComponentOptions.children;
    opts._componentTag = vnodeComponentOptions.tag;
    if (options.render) {
        opts.render = options.render;
        opts.staticRenderFns = options.staticRenderFns;
    }
}
function resolveConstructorOptions(Ctor) {
    let options = Ctor.options;
    if (Ctor.super) {
        const superOptions = resolveConstructorOptions(Ctor.super);
        const cachedSuperOptions = Ctor.superOptions;
        if (superOptions !== cachedSuperOptions) {
            // super option changed,
            // need to resolve new options.
            Ctor.superOptions = superOptions;
            // check if there are any late-modified/attached options (#4976)
            const modifiedOptions = resolveModifiedOptions(Ctor);
            // update base extend options
            if (modifiedOptions) {
                extend(Ctor.extendOptions, modifiedOptions);
            }
            options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
            if (options.name) {
                options.components[options.name] = Ctor;
            }
        }
    }
    return options;
}
function resolveModifiedOptions(Ctor) {
    let modified;
    const latest = Ctor.options;
    const sealed = Ctor.sealedOptions;
    for (const key in latest) {
        if (latest[key] !== sealed[key]) {
            if (!modified)
                modified = {};
            modified[key] = latest[key];
        }
    }
    return modified;
}

function Vue(options) {
    if (!(this instanceof Vue)) {
        warn('Vue is a constructor and should be called with the `new` keyword');
    }
    this._init(options);
}
//@ts-expect-error Vue has function type
initMixin$1(Vue);
//@ts-expect-error Vue has function type
stateMixin(Vue);
//@ts-expect-error Vue has function type
eventsMixin(Vue);
//@ts-expect-error Vue has function type
lifecycleMixin(Vue);
//@ts-expect-error Vue has function type
renderMixin(Vue);

function initUse(Vue) {
    Vue.use = function (plugin) {
        const installedPlugins = this._installedPlugins || (this._installedPlugins = []);
        if (installedPlugins.indexOf(plugin) > -1) {
            return this;
        }
        // additional parameters
        const args = toArray(arguments, 1);
        args.unshift(this);
        if (isFunction(plugin.install)) {
            plugin.install.apply(plugin, args);
        }
        else if (isFunction(plugin)) {
            plugin.apply(null, args);
        }
        installedPlugins.push(plugin);
        return this;
    };
}

function initMixin(Vue) {
    Vue.mixin = function (mixin) {
        this.options = mergeOptions(this.options, mixin);
        return this;
    };
}

function initExtend(Vue) {
    /**
     * Each instance constructor, including Vue, has a unique
     * cid. This enables us to create wrapped "child
     * constructors" for prototypal inheritance and cache them.
     */
    Vue.cid = 0;
    let cid = 1;
    /**
     * Class inheritance
     */
    Vue.extend = function (extendOptions) {
        extendOptions = extendOptions || {};
        const Super = this;
        const SuperId = Super.cid;
        const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
        if (cachedCtors[SuperId]) {
            return cachedCtors[SuperId];
        }
        const name = getComponentName(extendOptions) || getComponentName(Super.options);
        if (name) {
            validateComponentName(name);
        }
        const Sub = function VueComponent(options) {
            this._init(options);
        };
        Sub.prototype = Object.create(Super.prototype);
        Sub.prototype.constructor = Sub;
        Sub.cid = cid++;
        Sub.options = mergeOptions(Super.options, extendOptions);
        Sub['super'] = Super;
        // For props and computed properties, we define the proxy getters on
        // the Vue instances at extension time, on the extended prototype. This
        // avoids Object.defineProperty calls for each instance created.
        if (Sub.options.props) {
            initProps(Sub);
        }
        if (Sub.options.computed) {
            initComputed(Sub);
        }
        // allow further extension/mixin/plugin usage
        Sub.extend = Super.extend;
        Sub.mixin = Super.mixin;
        Sub.use = Super.use;
        // create asset registers, so extended classes
        // can have their private assets too.
        ASSET_TYPES.forEach(function (type) {
            Sub[type] = Super[type];
        });
        // enable recursive self-lookup
        if (name) {
            Sub.options.components[name] = Sub;
        }
        // keep a reference to the super options at extension time.
        // later at instantiation we can check if Super's options have
        // been updated.
        Sub.superOptions = Super.options;
        Sub.extendOptions = extendOptions;
        Sub.sealedOptions = extend({}, Sub.options);
        // cache constructor
        cachedCtors[SuperId] = Sub;
        return Sub;
    };
}
function initProps(Comp) {
    const props = Comp.options.props;
    for (const key in props) {
        proxy(Comp.prototype, `_props`, key);
    }
}
function initComputed(Comp) {
    const computed = Comp.options.computed;
    for (const key in computed) {
        defineComputed(Comp.prototype, key, computed[key]);
    }
}

function initAssetRegisters(Vue) {
    /**
     * Create asset registration methods.
     */
    ASSET_TYPES.forEach(type => {
        // @ts-expect-error function is not exact same type
        Vue[type] = function (id, definition) {
            if (!definition) {
                return this.options[type + 's'][id];
            }
            else {
                /* istanbul ignore if */
                if (type === 'component') {
                    validateComponentName(id);
                }
                if (type === 'component' && isPlainObject(definition)) {
                    // @ts-expect-error
                    definition.name = definition.name || id;
                    definition = this.options._base.extend(definition);
                }
                if (type === 'directive' && isFunction(definition)) {
                    definition = { bind: definition, update: definition };
                }
                this.options[type + 's'][id] = definition;
                return definition;
            }
        };
    });
}

function _getComponentName(opts) {
    return opts && (getComponentName(opts.Ctor.options) || opts.tag);
}
function matches(pattern, name) {
    if (isArray(pattern)) {
        return pattern.indexOf(name) > -1;
    }
    else if (typeof pattern === 'string') {
        return pattern.split(',').indexOf(name) > -1;
    }
    else if (isRegExp(pattern)) {
        return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
}
function pruneCache(keepAliveInstance, filter) {
    const { cache, keys, _vnode } = keepAliveInstance;
    for (const key in cache) {
        const entry = cache[key];
        if (entry) {
            const name = entry.name;
            if (name && !filter(name)) {
                pruneCacheEntry(cache, key, keys, _vnode);
            }
        }
    }
}
function pruneCacheEntry(cache, key, keys, current) {
    const entry = cache[key];
    if (entry && (!current || entry.tag !== current.tag)) {
        // @ts-expect-error can be undefined
        entry.componentInstance.$destroy();
    }
    cache[key] = null;
    remove$2(keys, key);
}
const patternTypes = [String, RegExp, Array];
// TODO defineComponent
var KeepAlive = {
    name: 'keep-alive',
    abstract: true,
    props: {
        include: patternTypes,
        exclude: patternTypes,
        max: [String, Number]
    },
    methods: {
        cacheVNode() {
            const { cache, keys, vnodeToCache, keyToCache } = this;
            if (vnodeToCache) {
                const { tag, componentInstance, componentOptions } = vnodeToCache;
                cache[keyToCache] = {
                    name: _getComponentName(componentOptions),
                    tag,
                    componentInstance
                };
                keys.push(keyToCache);
                // prune oldest entry
                if (this.max && keys.length > parseInt(this.max)) {
                    pruneCacheEntry(cache, keys[0], keys, this._vnode);
                }
                this.vnodeToCache = null;
            }
        }
    },
    created() {
        this.cache = Object.create(null);
        this.keys = [];
    },
    destroyed() {
        for (const key in this.cache) {
            pruneCacheEntry(this.cache, key, this.keys);
        }
    },
    mounted() {
        this.cacheVNode();
        this.$watch('include', val => {
            pruneCache(this, name => matches(val, name));
        });
        this.$watch('exclude', val => {
            pruneCache(this, name => !matches(val, name));
        });
    },
    updated() {
        this.cacheVNode();
    },
    render() {
        const slot = this.$slots.default;
        const vnode = getFirstComponentChild(slot);
        const componentOptions = vnode && vnode.componentOptions;
        if (componentOptions) {
            // check pattern
            const name = _getComponentName(componentOptions);
            const { include, exclude } = this;
            if (
            // not included
            (include && (!name || !matches(include, name))) ||
                // excluded
                (exclude && name && matches(exclude, name))) {
                return vnode;
            }
            const { cache, keys } = this;
            const key = vnode.key == null
                ? // same constructor may get registered as different local components
                    // so cid alone is not enough (#3269)
                    componentOptions.Ctor.cid +
                        (componentOptions.tag ? `::${componentOptions.tag}` : '')
                : vnode.key;
            if (cache[key]) {
                vnode.componentInstance = cache[key].componentInstance;
                // make current key freshest
                remove$2(keys, key);
                keys.push(key);
            }
            else {
                // delay setting the cache until update
                this.vnodeToCache = vnode;
                this.keyToCache = key;
            }
            // @ts-expect-error can vnode.data can be undefined
            vnode.data.keepAlive = true;
        }
        return vnode || (slot && slot[0]);
    }
};

var builtInComponents = {
    KeepAlive
};

function initGlobalAPI(Vue) {
    // config
    const configDef = {};
    configDef.get = () => config;
    {
        configDef.set = () => {
            warn('Do not replace the Vue.config object, set individual fields instead.');
        };
    }
    Object.defineProperty(Vue, 'config', configDef);
    // exposed util methods.
    // NOTE: these are not considered part of the public API - avoid relying on
    // them unless you are aware of the risk.
    Vue.util = {
        warn,
        extend,
        mergeOptions,
        defineReactive
    };
    Vue.set = set;
    Vue.delete = del;
    Vue.nextTick = nextTick;
    // 2.6 explicit observable API
    Vue.observable = (obj) => {
        observe(obj);
        return obj;
    };
    Vue.options = Object.create(null);
    ASSET_TYPES.forEach(type => {
        Vue.options[type + 's'] = Object.create(null);
    });
    // this is used to identify the "base" constructor to extend all plain-object
    // components with in Weex's multi-instance scenarios.
    Vue.options._base = Vue;
    extend(Vue.options.components, builtInComponents);
    initUse(Vue);
    initMixin(Vue);
    initExtend(Vue);
    initAssetRegisters(Vue);
}

initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, '$isServer', {
    get: isServerRendering
});
Object.defineProperty(Vue.prototype, '$ssrContext', {
    get() {
        /* istanbul ignore next */
        return this.$vnode && this.$vnode.ssrContext;
    }
});
// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
    value: FunctionalRenderContext
});
Vue.version = version;

// these are reserved for web because they are directly compiled away
// during template compilation
const isReservedAttr = makeMap('style,class');
// attributes that should be using props for binding
const acceptValue = makeMap('input,textarea,option,select,progress');
const mustUseProp = (tag, type, attr) => {
    return ((attr === 'value' && acceptValue(tag) && type !== 'button') ||
        (attr === 'selected' && tag === 'option') ||
        (attr === 'checked' && tag === 'input') ||
        (attr === 'muted' && tag === 'video'));
};
const isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
const isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');
const convertEnumeratedValue = (key, value) => {
    return isFalsyAttrValue(value) || value === 'false'
        ? 'false'
        : // allow arbitrary string value for contenteditable
            key === 'contenteditable' && isValidContentEditableValue(value)
                ? value
                : 'true';
};
const isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
    'required,reversed,scoped,seamless,selected,sortable,' +
    'truespeed,typemustmatch,visible');
const xlinkNS = 'http://www.w3.org/1999/xlink';
const isXlink = (name) => {
    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};
const getXlinkProp = (name) => {
    return isXlink(name) ? name.slice(6, name.length) : '';
};
const isFalsyAttrValue = (val) => {
    return val == null || val === false;
};

function genClassForVnode(vnode) {
    let data = vnode.data;
    let parentNode = vnode;
    let childNode = vnode;
    while (isDef(childNode.componentInstance)) {
        childNode = childNode.componentInstance._vnode;
        if (childNode && childNode.data) {
            data = mergeClassData(childNode.data, data);
        }
    }
    // @ts-expect-error parentNode.parent not VNodeWithData
    while (isDef((parentNode = parentNode.parent))) {
        if (parentNode && parentNode.data) {
            data = mergeClassData(data, parentNode.data);
        }
    }
    return renderClass(data.staticClass, data.class);
}
function mergeClassData(child, parent) {
    return {
        staticClass: concat(child.staticClass, parent.staticClass),
        class: isDef(child.class) ? [child.class, parent.class] : parent.class
    };
}
function renderClass(staticClass, dynamicClass) {
    if (isDef(staticClass) || isDef(dynamicClass)) {
        return concat(staticClass, stringifyClass(dynamicClass));
    }
    /* istanbul ignore next */
    return '';
}
function concat(a, b) {
    return a ? (b ? a + ' ' + b : a) : b || '';
}
function stringifyClass(value) {
    if (Array.isArray(value)) {
        return stringifyArray(value);
    }
    if (isObject(value)) {
        return stringifyObject(value);
    }
    if (typeof value === 'string') {
        return value;
    }
    /* istanbul ignore next */
    return '';
}
function stringifyArray(value) {
    let res = '';
    let stringified;
    for (let i = 0, l = value.length; i < l; i++) {
        if (isDef((stringified = stringifyClass(value[i]))) && stringified !== '') {
            if (res)
                res += ' ';
            res += stringified;
        }
    }
    return res;
}
function stringifyObject(value) {
    let res = '';
    for (const key in value) {
        if (value[key]) {
            if (res)
                res += ' ';
            res += key;
        }
    }
    return res;
}

const namespaceMap = {
    svg: 'http://www.w3.org/2000/svg',
    math: 'http://www.w3.org/1998/Math/MathML'
};
const isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' +
    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
    'embed,object,param,source,canvas,script,noscript,del,ins,' +
    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
    'output,progress,select,textarea,' +
    'details,dialog,menu,menuitem,summary,' +
    'content,element,shadow,template,blockquote,iframe,tfoot');
// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
const isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
    'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);
const isReservedTag = (tag) => {
    return isHTMLTag(tag) || isSVG(tag);
};
function getTagNamespace(tag) {
    if (isSVG(tag)) {
        return 'svg';
    }
    // basic support for MathML
    // note it doesn't support other MathML elements being component roots
    if (tag === 'math') {
        return 'math';
    }
}
const unknownElementCache = Object.create(null);
function isUnknownElement(tag) {
    /* istanbul ignore if */
    if (!inBrowser) {
        return true;
    }
    if (isReservedTag(tag)) {
        return false;
    }
    tag = tag.toLowerCase();
    /* istanbul ignore if */
    if (unknownElementCache[tag] != null) {
        return unknownElementCache[tag];
    }
    const el = document.createElement(tag);
    if (tag.indexOf('-') > -1) {
        // http://stackoverflow.com/a/28210364/1070244
        return (unknownElementCache[tag] =
            el.constructor === window.HTMLUnknownElement ||
                el.constructor === window.HTMLElement);
    }
    else {
        return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()));
    }
}
const isTextInputType = makeMap('text,number,password,search,email,tel,url');

/**
 * Query an element selector if it's not an element already.
 */
function query(el) {
    if (typeof el === 'string') {
        const selected = document.querySelector(el);
        if (!selected) {
            warn('Cannot find element: ' + el);
            return document.createElement('div');
        }
        return selected;
    }
    else {
        return el;
    }
}

function createElement(tagName, vnode) {
    const elm = document.createElement(tagName);
    if (tagName !== 'select') {
        return elm;
    }
    // false or null will remove the attribute but undefined will not
    if (vnode.data &&
        vnode.data.attrs &&
        vnode.data.attrs.multiple !== undefined) {
        elm.setAttribute('multiple', 'multiple');
    }
    return elm;
}
function createElementNS(namespace, tagName) {
    return document.createElementNS(namespaceMap[namespace], tagName);
}
function createTextNode(text) {
    return document.createTextNode(text);
}
function createComment(text) {
    return document.createComment(text);
}
function insertBefore(parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
    node.removeChild(child);
}
function appendChild(node, child) {
    node.appendChild(child);
}
function parentNode(node) {
    return node.parentNode;
}
function nextSibling(node) {
    return node.nextSibling;
}
function tagName(node) {
    return node.tagName;
}
function setTextContent(node, text) {
    node.textContent = text;
}
function setStyleScope(node, scopeId) {
    node.setAttribute(scopeId, '');
}

var nodeOps = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createElement: createElement,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});

var ref = {
    create(_, vnode) {
        registerRef(vnode);
    },
    update(oldVnode, vnode) {
        if (oldVnode.data.ref !== vnode.data.ref) {
            registerRef(oldVnode, true);
            registerRef(vnode);
        }
    },
    destroy(vnode) {
        registerRef(vnode, true);
    }
};
function registerRef(vnode, isRemoval) {
    const ref = vnode.data.ref;
    if (!isDef(ref))
        return;
    const vm = vnode.context;
    const refValue = vnode.componentInstance || vnode.elm;
    const value = isRemoval ? null : refValue;
    const $refsValue = isRemoval ? undefined : refValue;
    if (isFunction(ref)) {
        invokeWithErrorHandling(ref, vm, [value], vm, `template ref function`);
        return;
    }
    const isFor = vnode.data.refInFor;
    const _isString = typeof ref === 'string' || typeof ref === 'number';
    const _isRef = isRef(ref);
    const refs = vm.$refs;
    if (_isString || _isRef) {
        if (isFor) {
            const existing = _isString ? refs[ref] : ref.value;
            if (isRemoval) {
                isArray(existing) && remove$2(existing, refValue);
            }
            else {
                if (!isArray(existing)) {
                    if (_isString) {
                        refs[ref] = [refValue];
                        setSetupRef(vm, ref, refs[ref]);
                    }
                    else {
                        ref.value = [refValue];
                    }
                }
                else if (!existing.includes(refValue)) {
                    existing.push(refValue);
                }
            }
        }
        else if (_isString) {
            if (isRemoval && refs[ref] !== refValue) {
                return;
            }
            refs[ref] = $refsValue;
            setSetupRef(vm, ref, value);
        }
        else if (_isRef) {
            if (isRemoval && ref.value !== refValue) {
                return;
            }
            ref.value = value;
        }
        else {
            warn(`Invalid template ref type: ${typeof ref}`);
        }
    }
}
function setSetupRef({ _setupState }, key, val) {
    if (_setupState && hasOwn(_setupState, key)) {
        if (isRef(_setupState[key])) {
            _setupState[key].value = val;
        }
        else {
            _setupState[key] = val;
        }
    }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */
const emptyNode = new VNode('', {}, []);
const hooks = ['create', 'activate', 'update', 'remove', 'destroy'];
function sameVnode(a, b) {
    return (a.key === b.key &&
        a.asyncFactory === b.asyncFactory &&
        ((a.tag === b.tag &&
            a.isComment === b.isComment &&
            isDef(a.data) === isDef(b.data) &&
            sameInputType(a, b)) ||
            (isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error))));
}
function sameInputType(a, b) {
    if (a.tag !== 'input')
        return true;
    let i;
    const typeA = isDef((i = a.data)) && isDef((i = i.attrs)) && i.type;
    const typeB = isDef((i = b.data)) && isDef((i = i.attrs)) && i.type;
    return typeA === typeB || (isTextInputType(typeA) && isTextInputType(typeB));
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
    let i, key;
    const map = {};
    for (i = beginIdx; i <= endIdx; ++i) {
        key = children[i].key;
        if (isDef(key))
            map[key] = i;
    }
    return map;
}
function createPatchFunction(backend) {
    let i, j;
    const cbs = {};
    const { modules, nodeOps } = backend;
    for (i = 0; i < hooks.length; ++i) {
        cbs[hooks[i]] = [];
        for (j = 0; j < modules.length; ++j) {
            if (isDef(modules[j][hooks[i]])) {
                cbs[hooks[i]].push(modules[j][hooks[i]]);
            }
        }
    }
    function emptyNodeAt(elm) {
        return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
    }
    function createRmCb(childElm, listeners) {
        function remove() {
            if (--remove.listeners === 0) {
                removeNode(childElm);
            }
        }
        remove.listeners = listeners;
        return remove;
    }
    function removeNode(el) {
        const parent = nodeOps.parentNode(el);
        // element may have already been removed due to v-html / v-text
        if (isDef(parent)) {
            nodeOps.removeChild(parent, el);
        }
    }
    function isUnknownElement(vnode, inVPre) {
        return (!inVPre &&
            !vnode.ns &&
            !(config.ignoredElements.length &&
                config.ignoredElements.some(ignore => {
                    return isRegExp(ignore)
                        ? ignore.test(vnode.tag)
                        : ignore === vnode.tag;
                })) &&
            config.isUnknownElement(vnode.tag));
    }
    let creatingElmInVPre = 0;
    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
        if (isDef(vnode.elm) && isDef(ownerArray)) {
            // This vnode was used in a previous render!
            // now it's used as a new node, overwriting its elm would cause
            // potential patch errors down the road when it's used as an insertion
            // reference node. Instead, we clone the node on-demand before creating
            // associated DOM element for it.
            vnode = ownerArray[index] = cloneVNode(vnode);
        }
        vnode.isRootInsert = !nested; // for transition enter check
        if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
            return;
        }
        const data = vnode.data;
        const children = vnode.children;
        const tag = vnode.tag;
        if (isDef(tag)) {
            {
                if (data && data.pre) {
                    creatingElmInVPre++;
                }
                if (isUnknownElement(vnode, creatingElmInVPre)) {
                    warn('Unknown custom element: <' +
                        tag +
                        '> - did you ' +
                        'register the component correctly? For recursive components, ' +
                        'make sure to provide the "name" option.', vnode.context);
                }
            }
            vnode.elm = vnode.ns
                ? nodeOps.createElementNS(vnode.ns, tag)
                : nodeOps.createElement(tag, vnode);
            setScope(vnode);
            createChildren(vnode, children, insertedVnodeQueue);
            if (isDef(data)) {
                invokeCreateHooks(vnode, insertedVnodeQueue);
            }
            insert(parentElm, vnode.elm, refElm);
            if (data && data.pre) {
                creatingElmInVPre--;
            }
        }
        else if (isTrue(vnode.isComment)) {
            vnode.elm = nodeOps.createComment(vnode.text);
            insert(parentElm, vnode.elm, refElm);
        }
        else {
            vnode.elm = nodeOps.createTextNode(vnode.text);
            insert(parentElm, vnode.elm, refElm);
        }
    }
    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
        let i = vnode.data;
        if (isDef(i)) {
            const isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
            if (isDef((i = i.hook)) && isDef((i = i.init))) {
                i(vnode, false /* hydrating */);
            }
            // after calling the init hook, if the vnode is a child component
            // it should've created a child instance and mounted it. the child
            // component also has set the placeholder vnode's elm.
            // in that case we can just return the element and be done.
            if (isDef(vnode.componentInstance)) {
                initComponent(vnode, insertedVnodeQueue);
                insert(parentElm, vnode.elm, refElm);
                if (isTrue(isReactivated)) {
                    reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
                }
                return true;
            }
        }
    }
    function initComponent(vnode, insertedVnodeQueue) {
        if (isDef(vnode.data.pendingInsert)) {
            insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
            vnode.data.pendingInsert = null;
        }
        vnode.elm = vnode.componentInstance.$el;
        if (isPatchable(vnode)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            setScope(vnode);
        }
        else {
            // empty component root.
            // skip all element-related modules except for ref (#3455)
            registerRef(vnode);
            // make sure to invoke the insert hook
            insertedVnodeQueue.push(vnode);
        }
    }
    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
        let i;
        // hack for #4339: a reactivated component with inner transition
        // does not trigger because the inner node's created hooks are not called
        // again. It's not ideal to involve module-specific logic in here but
        // there doesn't seem to be a better way to do it.
        let innerNode = vnode;
        while (innerNode.componentInstance) {
            innerNode = innerNode.componentInstance._vnode;
            if (isDef((i = innerNode.data)) && isDef((i = i.transition))) {
                for (i = 0; i < cbs.activate.length; ++i) {
                    cbs.activate[i](emptyNode, innerNode);
                }
                insertedVnodeQueue.push(innerNode);
                break;
            }
        }
        // unlike a newly created component,
        // a reactivated keep-alive component doesn't insert itself
        insert(parentElm, vnode.elm, refElm);
    }
    function insert(parent, elm, ref) {
        if (isDef(parent)) {
            if (isDef(ref)) {
                if (nodeOps.parentNode(ref) === parent) {
                    nodeOps.insertBefore(parent, elm, ref);
                }
            }
            else {
                nodeOps.appendChild(parent, elm);
            }
        }
    }
    function createChildren(vnode, children, insertedVnodeQueue) {
        if (isArray(children)) {
            {
                checkDuplicateKeys(children);
            }
            for (let i = 0; i < children.length; ++i) {
                createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
            }
        }
        else if (isPrimitive(vnode.text)) {
            nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
        }
    }
    function isPatchable(vnode) {
        while (vnode.componentInstance) {
            vnode = vnode.componentInstance._vnode;
        }
        return isDef(vnode.tag);
    }
    function invokeCreateHooks(vnode, insertedVnodeQueue) {
        for (let i = 0; i < cbs.create.length; ++i) {
            cbs.create[i](emptyNode, vnode);
        }
        i = vnode.data.hook; // Reuse variable
        if (isDef(i)) {
            if (isDef(i.create))
                i.create(emptyNode, vnode);
            if (isDef(i.insert))
                insertedVnodeQueue.push(vnode);
        }
    }
    // set scope id attribute for scoped CSS.
    // this is implemented as a special case to avoid the overhead
    // of going through the normal attribute patching process.
    function setScope(vnode) {
        let i;
        if (isDef((i = vnode.fnScopeId))) {
            nodeOps.setStyleScope(vnode.elm, i);
        }
        else {
            let ancestor = vnode;
            while (ancestor) {
                if (isDef((i = ancestor.context)) && isDef((i = i.$options._scopeId))) {
                    nodeOps.setStyleScope(vnode.elm, i);
                }
                ancestor = ancestor.parent;
            }
        }
        // for slot content they should also get the scopeId from the host instance.
        if (isDef((i = activeInstance)) &&
            i !== vnode.context &&
            i !== vnode.fnContext &&
            isDef((i = i.$options._scopeId))) {
            nodeOps.setStyleScope(vnode.elm, i);
        }
    }
    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for (; startIdx <= endIdx; ++startIdx) {
            createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
        }
    }
    function invokeDestroyHook(vnode) {
        let i, j;
        const data = vnode.data;
        if (isDef(data)) {
            if (isDef((i = data.hook)) && isDef((i = i.destroy)))
                i(vnode);
            for (i = 0; i < cbs.destroy.length; ++i)
                cbs.destroy[i](vnode);
        }
        if (isDef((i = vnode.children))) {
            for (j = 0; j < vnode.children.length; ++j) {
                invokeDestroyHook(vnode.children[j]);
            }
        }
    }
    function removeVnodes(vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            const ch = vnodes[startIdx];
            if (isDef(ch)) {
                if (isDef(ch.tag)) {
                    removeAndInvokeRemoveHook(ch);
                    invokeDestroyHook(ch);
                }
                else {
                    // Text node
                    removeNode(ch.elm);
                }
            }
        }
    }
    function removeAndInvokeRemoveHook(vnode, rm) {
        if (isDef(rm) || isDef(vnode.data)) {
            let i;
            const listeners = cbs.remove.length + 1;
            if (isDef(rm)) {
                // we have a recursively passed down rm callback
                // increase the listeners count
                rm.listeners += listeners;
            }
            else {
                // directly removing
                rm = createRmCb(vnode.elm, listeners);
            }
            // recursively invoke hooks on child component root node
            if (isDef((i = vnode.componentInstance)) &&
                isDef((i = i._vnode)) &&
                isDef(i.data)) {
                removeAndInvokeRemoveHook(i, rm);
            }
            for (i = 0; i < cbs.remove.length; ++i) {
                cbs.remove[i](vnode, rm);
            }
            if (isDef((i = vnode.data.hook)) && isDef((i = i.remove))) {
                i(vnode, rm);
            }
            else {
                rm();
            }
        }
        else {
            removeNode(vnode.elm);
        }
    }
    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
        let oldStartIdx = 0;
        let newStartIdx = 0;
        let oldEndIdx = oldCh.length - 1;
        let oldStartVnode = oldCh[0];
        let oldEndVnode = oldCh[oldEndIdx];
        let newEndIdx = newCh.length - 1;
        let newStartVnode = newCh[0];
        let newEndVnode = newCh[newEndIdx];
        let oldKeyToIdx, idxInOld, vnodeToMove, refElm;
        // removeOnly is a special flag used only by <transition-group>
        // to ensure removed elements stay in correct relative positions
        // during leaving transitions
        const canMove = !removeOnly;
        {
            checkDuplicateKeys(newCh);
        }
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (isUndef(oldStartVnode)) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
            }
            else if (isUndef(oldEndVnode)) {
                oldEndVnode = oldCh[--oldEndIdx];
            }
            else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newEndVnode)) {
                // Vnode moved right
                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
                canMove &&
                    nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldEndVnode, newStartVnode)) {
                // Vnode moved left
                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                canMove &&
                    nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                if (isUndef(oldKeyToIdx))
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                idxInOld = isDef(newStartVnode.key)
                    ? oldKeyToIdx[newStartVnode.key]
                    : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
                if (isUndef(idxInOld)) {
                    // New element
                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                }
                else {
                    vnodeToMove = oldCh[idxInOld];
                    if (sameVnode(vnodeToMove, newStartVnode)) {
                        patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                        oldCh[idxInOld] = undefined;
                        canMove &&
                            nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
                    }
                    else {
                        // same key but different element. treat as new element
                        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                    }
                }
                newStartVnode = newCh[++newStartIdx];
            }
        }
        if (oldStartIdx > oldEndIdx) {
            refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
            addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
        }
        else if (newStartIdx > newEndIdx) {
            removeVnodes(oldCh, oldStartIdx, oldEndIdx);
        }
    }
    function checkDuplicateKeys(children) {
        const seenKeys = {};
        for (let i = 0; i < children.length; i++) {
            const vnode = children[i];
            const key = vnode.key;
            if (isDef(key)) {
                if (seenKeys[key]) {
                    warn(`Duplicate keys detected: '${key}'. This may cause an update error.`, vnode.context);
                }
                else {
                    seenKeys[key] = true;
                }
            }
        }
    }
    function findIdxInOld(node, oldCh, start, end) {
        for (let i = start; i < end; i++) {
            const c = oldCh[i];
            if (isDef(c) && sameVnode(node, c))
                return i;
        }
    }
    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
        if (oldVnode === vnode) {
            return;
        }
        if (isDef(vnode.elm) && isDef(ownerArray)) {
            // clone reused vnode
            vnode = ownerArray[index] = cloneVNode(vnode);
        }
        const elm = (vnode.elm = oldVnode.elm);
        if (isTrue(oldVnode.isAsyncPlaceholder)) {
            if (isDef(vnode.asyncFactory.resolved)) {
                hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
            }
            else {
                vnode.isAsyncPlaceholder = true;
            }
            return;
        }
        // reuse element for static trees.
        // note we only do this if the vnode is cloned -
        // if the new node is not cloned it means the render functions have been
        // reset by the hot-reload-api and we need to do a proper re-render.
        if (isTrue(vnode.isStatic) &&
            isTrue(oldVnode.isStatic) &&
            vnode.key === oldVnode.key &&
            (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
            vnode.componentInstance = oldVnode.componentInstance;
            return;
        }
        let i;
        const data = vnode.data;
        if (isDef(data) && isDef((i = data.hook)) && isDef((i = i.prepatch))) {
            i(oldVnode, vnode);
        }
        const oldCh = oldVnode.children;
        const ch = vnode.children;
        if (isDef(data) && isPatchable(vnode)) {
            for (i = 0; i < cbs.update.length; ++i)
                cbs.update[i](oldVnode, vnode);
            if (isDef((i = data.hook)) && isDef((i = i.update)))
                i(oldVnode, vnode);
        }
        if (isUndef(vnode.text)) {
            if (isDef(oldCh) && isDef(ch)) {
                if (oldCh !== ch)
                    updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
            }
            else if (isDef(ch)) {
                {
                    checkDuplicateKeys(ch);
                }
                if (isDef(oldVnode.text))
                    nodeOps.setTextContent(elm, '');
                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
            }
            else if (isDef(oldCh)) {
                removeVnodes(oldCh, 0, oldCh.length - 1);
            }
            else if (isDef(oldVnode.text)) {
                nodeOps.setTextContent(elm, '');
            }
        }
        else if (oldVnode.text !== vnode.text) {
            nodeOps.setTextContent(elm, vnode.text);
        }
        if (isDef(data)) {
            if (isDef((i = data.hook)) && isDef((i = i.postpatch)))
                i(oldVnode, vnode);
        }
    }
    function invokeInsertHook(vnode, queue, initial) {
        // delay insert hooks for component root nodes, invoke them after the
        // element is really inserted
        if (isTrue(initial) && isDef(vnode.parent)) {
            vnode.parent.data.pendingInsert = queue;
        }
        else {
            for (let i = 0; i < queue.length; ++i) {
                queue[i].data.hook.insert(queue[i]);
            }
        }
    }
    let hydrationBailed = false;
    // list of modules that can skip create hook during hydration because they
    // are already rendered on the client or has no need for initialization
    // Note: style is excluded because it relies on initial clone for future
    // deep updates (#7063).
    const isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');
    // Note: this is a browser-only function so we can assume elms are DOM nodes.
    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
        let i;
        const { tag, data, children } = vnode;
        inVPre = inVPre || (data && data.pre);
        vnode.elm = elm;
        if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
            vnode.isAsyncPlaceholder = true;
            return true;
        }
        // assert node match
        {
            if (!assertNodeMatch(elm, vnode, inVPre)) {
                return false;
            }
        }
        if (isDef(data)) {
            if (isDef((i = data.hook)) && isDef((i = i.init)))
                i(vnode, true /* hydrating */);
            if (isDef((i = vnode.componentInstance))) {
                // child component. it should have hydrated its own tree.
                initComponent(vnode, insertedVnodeQueue);
                return true;
            }
        }
        if (isDef(tag)) {
            if (isDef(children)) {
                // empty element, allow client to pick up and populate children
                if (!elm.hasChildNodes()) {
                    createChildren(vnode, children, insertedVnodeQueue);
                }
                else {
                    // v-html and domProps: innerHTML
                    if (isDef((i = data)) &&
                        isDef((i = i.domProps)) &&
                        isDef((i = i.innerHTML))) {
                        if (i !== elm.innerHTML) {
                            /* istanbul ignore if */
                            if (typeof console !== 'undefined' &&
                                !hydrationBailed) {
                                hydrationBailed = true;
                                console.warn('Parent: ', elm);
                                console.warn('server innerHTML: ', i);
                                console.warn('client innerHTML: ', elm.innerHTML);
                            }
                            return false;
                        }
                    }
                    else {
                        // iterate and compare children lists
                        let childrenMatch = true;
                        let childNode = elm.firstChild;
                        for (let i = 0; i < children.length; i++) {
                            if (!childNode ||
                                !hydrate(childNode, children[i], insertedVnodeQueue, inVPre)) {
                                childrenMatch = false;
                                break;
                            }
                            childNode = childNode.nextSibling;
                        }
                        // if childNode is not null, it means the actual childNodes list is
                        // longer than the virtual children list.
                        if (!childrenMatch || childNode) {
                            /* istanbul ignore if */
                            if (typeof console !== 'undefined' &&
                                !hydrationBailed) {
                                hydrationBailed = true;
                                console.warn('Parent: ', elm);
                                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
                            }
                            return false;
                        }
                    }
                }
            }
            if (isDef(data)) {
                let fullInvoke = false;
                for (const key in data) {
                    if (!isRenderedModule(key)) {
                        fullInvoke = true;
                        invokeCreateHooks(vnode, insertedVnodeQueue);
                        break;
                    }
                }
                if (!fullInvoke && data['class']) {
                    // ensure collecting deps for deep class bindings for future updates
                    traverse(data['class']);
                }
            }
        }
        else if (elm.data !== vnode.text) {
            elm.data = vnode.text;
        }
        return true;
    }
    function assertNodeMatch(node, vnode, inVPre) {
        if (isDef(vnode.tag)) {
            return (vnode.tag.indexOf('vue-component') === 0 ||
                (!isUnknownElement(vnode, inVPre) &&
                    vnode.tag.toLowerCase() ===
                        (node.tagName && node.tagName.toLowerCase())));
        }
        else {
            return node.nodeType === (vnode.isComment ? 8 : 3);
        }
    }
    return function patch(oldVnode, vnode, hydrating, removeOnly) {
        if (isUndef(vnode)) {
            if (isDef(oldVnode))
                invokeDestroyHook(oldVnode);
            return;
        }
        let isInitialPatch = false;
        const insertedVnodeQueue = [];
        if (isUndef(oldVnode)) {
            // empty mount (likely as component), create new root element
            isInitialPatch = true;
            createElm(vnode, insertedVnodeQueue);
        }
        else {
            const isRealElement = isDef(oldVnode.nodeType);
            if (!isRealElement && sameVnode(oldVnode, vnode)) {
                // patch existing root node
                patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
            }
            else {
                if (isRealElement) {
                    // mounting to a real element
                    // check if this is server-rendered content and if we can perform
                    // a successful hydration.
                    if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
                        oldVnode.removeAttribute(SSR_ATTR);
                        hydrating = true;
                    }
                    if (isTrue(hydrating)) {
                        if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                            invokeInsertHook(vnode, insertedVnodeQueue, true);
                            return oldVnode;
                        }
                        else {
                            warn('The client-side rendered virtual DOM tree is not matching ' +
                                'server-rendered content. This is likely caused by incorrect ' +
                                'HTML markup, for example nesting block-level elements inside ' +
                                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                                'full client-side render.');
                        }
                    }
                    // either not server-rendered, or hydration failed.
                    // create an empty node and replace it
                    oldVnode = emptyNodeAt(oldVnode);
                }
                // replacing existing element
                const oldElm = oldVnode.elm;
                const parentElm = nodeOps.parentNode(oldElm);
                // create new node
                createElm(vnode, insertedVnodeQueue, 
                // extremely rare edge case: do not insert if old element is in a
                // leaving transition. Only happens when combining transition +
                // keep-alive + HOCs. (#4590)
                oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm));
                // update parent placeholder node element, recursively
                if (isDef(vnode.parent)) {
                    let ancestor = vnode.parent;
                    const patchable = isPatchable(vnode);
                    while (ancestor) {
                        for (let i = 0; i < cbs.destroy.length; ++i) {
                            cbs.destroy[i](ancestor);
                        }
                        ancestor.elm = vnode.elm;
                        if (patchable) {
                            for (let i = 0; i < cbs.create.length; ++i) {
                                cbs.create[i](emptyNode, ancestor);
                            }
                            // #6513
                            // invoke insert hooks that may have been merged by create hooks.
                            // e.g. for directives that uses the "inserted" hook.
                            const insert = ancestor.data.hook.insert;
                            if (insert.merged) {
                                // start at index 1 to avoid re-invoking component mounted hook
                                for (let i = 1; i < insert.fns.length; i++) {
                                    insert.fns[i]();
                                }
                            }
                        }
                        else {
                            registerRef(ancestor);
                        }
                        ancestor = ancestor.parent;
                    }
                }
                // destroy old node
                if (isDef(parentElm)) {
                    removeVnodes([oldVnode], 0, 0);
                }
                else if (isDef(oldVnode.tag)) {
                    invokeDestroyHook(oldVnode);
                }
            }
        }
        invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
        return vnode.elm;
    };
}

var directives = {
    create: updateDirectives,
    update: updateDirectives,
    destroy: function unbindDirectives(vnode) {
        // @ts-expect-error emptyNode is not VNodeWithData
        updateDirectives(vnode, emptyNode);
    }
};
function updateDirectives(oldVnode, vnode) {
    if (oldVnode.data.directives || vnode.data.directives) {
        _update(oldVnode, vnode);
    }
}
function _update(oldVnode, vnode) {
    const isCreate = oldVnode === emptyNode;
    const isDestroy = vnode === emptyNode;
    const oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);
    const newDirs = normalizeDirectives(vnode.data.directives, vnode.context);
    const dirsWithInsert = [];
    const dirsWithPostpatch = [];
    let key, oldDir, dir;
    for (key in newDirs) {
        oldDir = oldDirs[key];
        dir = newDirs[key];
        if (!oldDir) {
            // new directive, bind
            callHook(dir, 'bind', vnode, oldVnode);
            if (dir.def && dir.def.inserted) {
                dirsWithInsert.push(dir);
            }
        }
        else {
            // existing directive, update
            dir.oldValue = oldDir.value;
            dir.oldArg = oldDir.arg;
            callHook(dir, 'update', vnode, oldVnode);
            if (dir.def && dir.def.componentUpdated) {
                dirsWithPostpatch.push(dir);
            }
        }
    }
    if (dirsWithInsert.length) {
        const callInsert = () => {
            for (let i = 0; i < dirsWithInsert.length; i++) {
                callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode);
            }
        };
        if (isCreate) {
            mergeVNodeHook(vnode, 'insert', callInsert);
        }
        else {
            callInsert();
        }
    }
    if (dirsWithPostpatch.length) {
        mergeVNodeHook(vnode, 'postpatch', () => {
            for (let i = 0; i < dirsWithPostpatch.length; i++) {
                callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
            }
        });
    }
    if (!isCreate) {
        for (key in oldDirs) {
            if (!newDirs[key]) {
                // no longer present, unbind
                callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
            }
        }
    }
}
const emptyModifiers = Object.create(null);
function normalizeDirectives(dirs, vm) {
    const res = Object.create(null);
    if (!dirs) {
        // $flow-disable-line
        return res;
    }
    let i, dir;
    for (i = 0; i < dirs.length; i++) {
        dir = dirs[i];
        if (!dir.modifiers) {
            // $flow-disable-line
            dir.modifiers = emptyModifiers;
        }
        res[getRawDirName(dir)] = dir;
        if (vm._setupState && vm._setupState.__sfc) {
            const setupDef = dir.def || resolveAsset(vm, '_setupState', 'v-' + dir.name);
            if (typeof setupDef === 'function') {
                dir.def = {
                    bind: setupDef,
                    update: setupDef,
                };
            }
            else {
                dir.def = setupDef;
            }
        }
        dir.def = dir.def || resolveAsset(vm.$options, 'directives', dir.name, true);
    }
    // $flow-disable-line
    return res;
}
function getRawDirName(dir) {
    return (dir.rawName || `${dir.name}.${Object.keys(dir.modifiers || {}).join('.')}`);
}
function callHook(dir, hook, vnode, oldVnode, isDestroy) {
    const fn = dir.def && dir.def[hook];
    if (fn) {
        try {
            fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
        }
        catch (e) {
            handleError(e, vnode.context, `directive ${dir.name} ${hook} hook`);
        }
    }
}

var baseModules = [ref, directives];

function updateAttrs(oldVnode, vnode) {
    const opts = vnode.componentOptions;
    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
        return;
    }
    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
        return;
    }
    let key, cur, old;
    const elm = vnode.elm;
    const oldAttrs = oldVnode.data.attrs || {};
    let attrs = vnode.data.attrs || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(attrs.__ob__) || isTrue(attrs._v_attr_proxy)) {
        attrs = vnode.data.attrs = extend({}, attrs);
    }
    for (key in attrs) {
        cur = attrs[key];
        old = oldAttrs[key];
        if (old !== cur) {
            setAttr(elm, key, cur, vnode.data.pre);
        }
    }
    // #4391: in IE9, setting type can reset value for input[type=radio]
    // #6666: IE/Edge forces progress value down to 1 before setting a max
    /* istanbul ignore if */
    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
        setAttr(elm, 'value', attrs.value);
    }
    for (key in oldAttrs) {
        if (isUndef(attrs[key])) {
            if (isXlink(key)) {
                elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
            }
            else if (!isEnumeratedAttr(key)) {
                elm.removeAttribute(key);
            }
        }
    }
}
function setAttr(el, key, value, isInPre) {
    if (isInPre || el.tagName.indexOf('-') > -1) {
        baseSetAttr(el, key, value);
    }
    else if (isBooleanAttr(key)) {
        // set attribute for blank value
        // e.g. <option disabled>Select one</option>
        if (isFalsyAttrValue(value)) {
            el.removeAttribute(key);
        }
        else {
            // technically allowfullscreen is a boolean attribute for <iframe>,
            // but Flash expects a value of "true" when used on <embed> tag
            value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
            el.setAttribute(key, value);
        }
    }
    else if (isEnumeratedAttr(key)) {
        el.setAttribute(key, convertEnumeratedValue(key, value));
    }
    else if (isXlink(key)) {
        if (isFalsyAttrValue(value)) {
            el.removeAttributeNS(xlinkNS, getXlinkProp(key));
        }
        else {
            el.setAttributeNS(xlinkNS, key, value);
        }
    }
    else {
        baseSetAttr(el, key, value);
    }
}
function baseSetAttr(el, key, value) {
    if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
    }
    else {
        // #7138: IE10 & 11 fires input event when setting placeholder on
        // <textarea>... block the first input event and remove the blocker
        // immediately.
        /* istanbul ignore if */
        if (isIE &&
            !isIE9 &&
            el.tagName === 'TEXTAREA' &&
            key === 'placeholder' &&
            value !== '' &&
            !el.__ieph) {
            const blocker = e => {
                e.stopImmediatePropagation();
                el.removeEventListener('input', blocker);
            };
            el.addEventListener('input', blocker);
            // $flow-disable-line
            el.__ieph = true; /* IE placeholder patched */
        }
        el.setAttribute(key, value);
    }
}
var attrs = {
    create: updateAttrs,
    update: updateAttrs
};

function updateClass(oldVnode, vnode) {
    const el = vnode.elm;
    const data = vnode.data;
    const oldData = oldVnode.data;
    if (isUndef(data.staticClass) &&
        isUndef(data.class) &&
        (isUndef(oldData) ||
            (isUndef(oldData.staticClass) && isUndef(oldData.class)))) {
        return;
    }
    let cls = genClassForVnode(vnode);
    // handle transition classes
    const transitionClass = el._transitionClasses;
    if (isDef(transitionClass)) {
        cls = concat(cls, stringifyClass(transitionClass));
    }
    // set the class
    if (cls !== el._prevClass) {
        el.setAttribute('class', cls);
        el._prevClass = cls;
    }
}
var klass = {
    create: updateClass,
    update: updateClass
};

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
const RANGE_TOKEN = '__r';
const CHECKBOX_RADIO_TOKEN = '__c';

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents(on) {
    /* istanbul ignore if */
    if (isDef(on[RANGE_TOKEN])) {
        // IE input[type=range] only supports `change` event
        const event = isIE ? 'change' : 'input';
        on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
        delete on[RANGE_TOKEN];
    }
    // This was originally intended to fix #4521 but no longer necessary
    // after 2.5. Keeping it for backwards compat with generated code from < 2.4
    /* istanbul ignore if */
    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
        on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
        delete on[CHECKBOX_RADIO_TOKEN];
    }
}
let target;
function createOnceHandler(event, handler, capture) {
    const _target = target; // save current target element in closure
    return function onceHandler() {
        const res = handler.apply(null, arguments);
        if (res !== null) {
            remove(event, onceHandler, capture, _target);
        }
    };
}
// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.
const useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);
function add(name, handler, capture, passive) {
    // async edge case #6566: inner click event triggers patch, event handler
    // attached to outer element during patch, and triggered again. This
    // happens because browsers fire microtask ticks between event propagation.
    // the solution is simple: we save the timestamp when a handler is attached,
    // and the handler would only fire if the event passed to it was fired
    // AFTER it was attached.
    if (useMicrotaskFix) {
        const attachedTimestamp = currentFlushTimestamp;
        const original = handler;
        //@ts-expect-error
        handler = original._wrapper = function (e) {
            if (
            // no bubbling, should always fire.
            // this is just a safety net in case event.timeStamp is unreliable in
            // certain weird environments...
            e.target === e.currentTarget ||
                // event is fired after handler attachment
                e.timeStamp >= attachedTimestamp ||
                // bail for environments that have buggy event.timeStamp implementations
                // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
                // #9681 QtWebEngine event.timeStamp is negative value
                e.timeStamp <= 0 ||
                // #9448 bail if event is fired in another document in a multi-page
                // electron/nw.js app, since event.timeStamp will be using a different
                // starting reference
                e.target.ownerDocument !== document) {
                return original.apply(this, arguments);
            }
        };
    }
    target.addEventListener(name, handler, supportsPassive ? { capture, passive } : capture);
}
function remove(name, handler, capture, _target) {
    (_target || target).removeEventListener(name, 
    //@ts-expect-error
    handler._wrapper || handler, capture);
}
function updateDOMListeners(oldVnode, vnode) {
    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
        return;
    }
    const on = vnode.data.on || {};
    const oldOn = oldVnode.data.on || {};
    // vnode is empty when removing all listeners,
    // and use old vnode dom element
    target = vnode.elm || oldVnode.elm;
    normalizeEvents(on);
    updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);
    target = undefined;
}
var events = {
    create: updateDOMListeners,
    update: updateDOMListeners,
    // @ts-expect-error emptyNode has actually data
    destroy: (vnode) => updateDOMListeners(vnode, emptyNode)
};

let svgContainer;
function updateDOMProps(oldVnode, vnode) {
    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
        return;
    }
    let key, cur;
    const elm = vnode.elm;
    const oldProps = oldVnode.data.domProps || {};
    let props = vnode.data.domProps || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(props.__ob__) || isTrue(props._v_attr_proxy)) {
        props = vnode.data.domProps = extend({}, props);
    }
    for (key in oldProps) {
        if (!(key in props)) {
            elm[key] = '';
        }
    }
    for (key in props) {
        cur = props[key];
        // ignore children if the node has textContent or innerHTML,
        // as these will throw away existing DOM nodes and cause removal errors
        // on subsequent patches (#3360)
        if (key === 'textContent' || key === 'innerHTML') {
            if (vnode.children)
                vnode.children.length = 0;
            if (cur === oldProps[key])
                continue;
            // #6601 work around Chrome version <= 55 bug where single textNode
            // replaced by innerHTML/textContent retains its parentNode property
            if (elm.childNodes.length === 1) {
                elm.removeChild(elm.childNodes[0]);
            }
        }
        if (key === 'value' && elm.tagName !== 'PROGRESS') {
            // store value as _value as well since
            // non-string values will be stringified
            elm._value = cur;
            // avoid resetting cursor position when value is the same
            const strCur = isUndef(cur) ? '' : String(cur);
            if (shouldUpdateValue(elm, strCur)) {
                elm.value = strCur;
            }
        }
        else if (key === 'innerHTML' &&
            isSVG(elm.tagName) &&
            isUndef(elm.innerHTML)) {
            // IE doesn't support innerHTML for SVG elements
            svgContainer = svgContainer || document.createElement('div');
            svgContainer.innerHTML = `<svg>${cur}</svg>`;
            const svg = svgContainer.firstChild;
            while (elm.firstChild) {
                elm.removeChild(elm.firstChild);
            }
            while (svg.firstChild) {
                elm.appendChild(svg.firstChild);
            }
        }
        else if (
        // skip the update if old and new VDOM state is the same.
        // `value` is handled separately because the DOM value may be temporarily
        // out of sync with VDOM state due to focus, composition and modifiers.
        // This  #4521 by skipping the unnecessary `checked` update.
        cur !== oldProps[key]) {
            // some property updates can throw
            // e.g. `value` on <progress> w/ non-finite value
            try {
                elm[key] = cur;
            }
            catch (e) { }
        }
    }
}
function shouldUpdateValue(elm, checkVal) {
    return (
    //@ts-expect-error
    !elm.composing &&
        (elm.tagName === 'OPTION' ||
            isNotInFocusAndDirty(elm, checkVal) ||
            isDirtyWithModifiers(elm, checkVal)));
}
function isNotInFocusAndDirty(elm, checkVal) {
    // return true when textbox (.number and .trim) loses focus and its value is
    // not equal to the updated value
    let notInFocus = true;
    // #6157
    // work around IE bug when accessing document.activeElement in an iframe
    try {
        notInFocus = document.activeElement !== elm;
    }
    catch (e) { }
    return notInFocus && elm.value !== checkVal;
}
function isDirtyWithModifiers(elm, newVal) {
    const value = elm.value;
    const modifiers = elm._vModifiers; // injected by v-model runtime
    if (isDef(modifiers)) {
        if (modifiers.number) {
            return toNumber(value) !== toNumber(newVal);
        }
        if (modifiers.trim) {
            return value.trim() !== newVal.trim();
        }
    }
    return value !== newVal;
}
var domProps = {
    create: updateDOMProps,
    update: updateDOMProps
};

const parseStyleText = cached(function (cssText) {
    const res = {};
    const listDelimiter = /;(?![^(]*\))/g;
    const propertyDelimiter = /:(.+)/;
    cssText.split(listDelimiter).forEach(function (item) {
        if (item) {
            const tmp = item.split(propertyDelimiter);
            tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return res;
});
// merge static and dynamic style data on the same vnode
function normalizeStyleData(data) {
    const style = normalizeStyleBinding(data.style);
    // static style is pre-processed into an object during compilation
    // and is always a fresh object, so it's safe to merge into it
    return data.staticStyle ? extend(data.staticStyle, style) : style;
}
// normalize possible array / string values into Object
function normalizeStyleBinding(bindingStyle) {
    if (Array.isArray(bindingStyle)) {
        return toObject(bindingStyle);
    }
    if (typeof bindingStyle === 'string') {
        return parseStyleText(bindingStyle);
    }
    return bindingStyle;
}
/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle(vnode, checkChild) {
    const res = {};
    let styleData;
    if (checkChild) {
        let childNode = vnode;
        while (childNode.componentInstance) {
            childNode = childNode.componentInstance._vnode;
            if (childNode &&
                childNode.data &&
                (styleData = normalizeStyleData(childNode.data))) {
                extend(res, styleData);
            }
        }
    }
    if ((styleData = normalizeStyleData(vnode.data))) {
        extend(res, styleData);
    }
    let parentNode = vnode;
    // @ts-expect-error parentNode.parent not VNodeWithData
    while ((parentNode = parentNode.parent)) {
        if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
            extend(res, styleData);
        }
    }
    return res;
}

const cssVarRE = /^--/;
const importantRE = /\s*!important$/;
const setProp = (el, name, val) => {
    /* istanbul ignore if */
    if (cssVarRE.test(name)) {
        el.style.setProperty(name, val);
    }
    else if (importantRE.test(val)) {
        el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
    }
    else {
        const normalizedName = normalize(name);
        if (Array.isArray(val)) {
            // Support values array created by autoprefixer, e.g.
            // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
            // Set them one by one, and the browser will only set those it can recognize
            for (let i = 0, len = val.length; i < len; i++) {
                el.style[normalizedName] = val[i];
            }
        }
        else {
            el.style[normalizedName] = val;
        }
    }
};
const vendorNames = ['Webkit', 'Moz', 'ms'];
let emptyStyle;
const normalize = cached(function (prop) {
    emptyStyle = emptyStyle || document.createElement('div').style;
    prop = camelize(prop);
    if (prop !== 'filter' && prop in emptyStyle) {
        return prop;
    }
    const capName = prop.charAt(0).toUpperCase() + prop.slice(1);
    for (let i = 0; i < vendorNames.length; i++) {
        const name = vendorNames[i] + capName;
        if (name in emptyStyle) {
            return name;
        }
    }
});
function updateStyle(oldVnode, vnode) {
    const data = vnode.data;
    const oldData = oldVnode.data;
    if (isUndef(data.staticStyle) &&
        isUndef(data.style) &&
        isUndef(oldData.staticStyle) &&
        isUndef(oldData.style)) {
        return;
    }
    let cur, name;
    const el = vnode.elm;
    const oldStaticStyle = oldData.staticStyle;
    const oldStyleBinding = oldData.normalizedStyle || oldData.style || {};
    // if static style exists, stylebinding already merged into it when doing normalizeStyleData
    const oldStyle = oldStaticStyle || oldStyleBinding;
    const style = normalizeStyleBinding(vnode.data.style) || {};
    // store normalized style under a different key for next diff
    // make sure to clone it if it's reactive, since the user likely wants
    // to mutate it.
    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
    const newStyle = getStyle(vnode, true);
    for (name in oldStyle) {
        if (isUndef(newStyle[name])) {
            setProp(el, name, '');
        }
    }
    for (name in newStyle) {
        cur = newStyle[name];
        if (cur !== oldStyle[name]) {
            // ie9 setting to null has no effect, must use empty string
            setProp(el, name, cur == null ? '' : cur);
        }
    }
}
var style = {
    create: updateStyle,
    update: updateStyle
};

const whitespaceRE = /\s+/;
/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
        return;
    }
    /* istanbul ignore else */
    if (el.classList) {
        if (cls.indexOf(' ') > -1) {
            cls.split(whitespaceRE).forEach(c => el.classList.add(c));
        }
        else {
            el.classList.add(cls);
        }
    }
    else {
        const cur = ` ${el.getAttribute('class') || ''} `;
        if (cur.indexOf(' ' + cls + ' ') < 0) {
            el.setAttribute('class', (cur + cls).trim());
        }
    }
}
/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
        return;
    }
    /* istanbul ignore else */
    if (el.classList) {
        if (cls.indexOf(' ') > -1) {
            cls.split(whitespaceRE).forEach(c => el.classList.remove(c));
        }
        else {
            el.classList.remove(cls);
        }
        if (!el.classList.length) {
            el.removeAttribute('class');
        }
    }
    else {
        let cur = ` ${el.getAttribute('class') || ''} `;
        const tar = ' ' + cls + ' ';
        while (cur.indexOf(tar) >= 0) {
            cur = cur.replace(tar, ' ');
        }
        cur = cur.trim();
        if (cur) {
            el.setAttribute('class', cur);
        }
        else {
            el.removeAttribute('class');
        }
    }
}

function resolveTransition(def) {
    if (!def) {
        return;
    }
    /* istanbul ignore else */
    if (typeof def === 'object') {
        const res = {};
        if (def.css !== false) {
            extend(res, autoCssTransition(def.name || 'v'));
        }
        extend(res, def);
        return res;
    }
    else if (typeof def === 'string') {
        return autoCssTransition(def);
    }
}
const autoCssTransition = cached(name => {
    return {
        enterClass: `${name}-enter`,
        enterToClass: `${name}-enter-to`,
        enterActiveClass: `${name}-enter-active`,
        leaveClass: `${name}-leave`,
        leaveToClass: `${name}-leave-to`,
        leaveActiveClass: `${name}-leave-active`
    };
});
const hasTransition = inBrowser && !isIE9;
const TRANSITION = 'transition';
const ANIMATION = 'animation';
// Transition property/event sniffing
let transitionProp = 'transition';
let transitionEndEvent = 'transitionend';
let animationProp = 'animation';
let animationEndEvent = 'animationend';
if (hasTransition) {
    /* istanbul ignore if */
    if (window.ontransitionend === undefined &&
        window.onwebkittransitionend !== undefined) {
        transitionProp = 'WebkitTransition';
        transitionEndEvent = 'webkitTransitionEnd';
    }
    if (window.onanimationend === undefined &&
        window.onwebkitanimationend !== undefined) {
        animationProp = 'WebkitAnimation';
        animationEndEvent = 'webkitAnimationEnd';
    }
}
// binding to window is necessary to make hot reload work in IE in strict mode
const raf = inBrowser
    ? window.requestAnimationFrame
        ? window.requestAnimationFrame.bind(window)
        : setTimeout
    : /* istanbul ignore next */ /* istanbul ignore next */ fn => fn();
function nextFrame(fn) {
    raf(() => {
        // @ts-expect-error
        raf(fn);
    });
}
function addTransitionClass(el, cls) {
    const transitionClasses = el._transitionClasses || (el._transitionClasses = []);
    if (transitionClasses.indexOf(cls) < 0) {
        transitionClasses.push(cls);
        addClass(el, cls);
    }
}
function removeTransitionClass(el, cls) {
    if (el._transitionClasses) {
        remove$2(el._transitionClasses, cls);
    }
    removeClass(el, cls);
}
function whenTransitionEnds(el, expectedType, cb) {
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type)
        return cb();
    const event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
    let ended = 0;
    const end = () => {
        el.removeEventListener(event, onEnd);
        cb();
    };
    const onEnd = e => {
        if (e.target === el) {
            if (++ended >= propCount) {
                end();
            }
        }
    };
    setTimeout(() => {
        if (ended < propCount) {
            end();
        }
    }, timeout + 1);
    el.addEventListener(event, onEnd);
}
const transformRE = /\b(transform|all)(,|$)/;
function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    // JSDOM may return undefined for transition properties
    const transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
    const transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
    const animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type;
    let timeout = 0;
    let propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    }
    else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    }
    else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type =
            timeout > 0
                ? transitionTimeout > animationTimeout
                    ? TRANSITION
                    : ANIMATION
                : null;
        propCount = type
            ? type === TRANSITION
                ? transitionDurations.length
                : animationDurations.length
            : 0;
    }
    const hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
    return {
        type,
        timeout,
        propCount,
        hasTransform
    };
}
function getTimeout(delays, durations) {
    /* istanbul ignore next */
    while (delays.length < durations.length) {
        delays = delays.concat(delays);
    }
    return Math.max.apply(null, durations.map((d, i) => {
        return toMs(d) + toMs(delays[i]);
    }));
}
// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors
function toMs(s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}

function enter(vnode, toggleDisplay) {
    const el = vnode.elm;
    // call leave callback now
    if (isDef(el._leaveCb)) {
        el._leaveCb.cancelled = true;
        el._leaveCb();
    }
    const data = resolveTransition(vnode.data.transition);
    if (isUndef(data)) {
        return;
    }
    /* istanbul ignore if */
    if (isDef(el._enterCb) || el.nodeType !== 1) {
        return;
    }
    const { css, type, enterClass, enterToClass, enterActiveClass, appearClass, appearToClass, appearActiveClass, beforeEnter, enter, afterEnter, enterCancelled, beforeAppear, appear, afterAppear, appearCancelled, duration } = data;
    // activeInstance will always be the <transition> component managing this
    // transition. One edge case to check is when the <transition> is placed
    // as the root node of a child component. In that case we need to check
    // <transition>'s parent for appear check.
    let context = activeInstance;
    let transitionNode = activeInstance.$vnode;
    while (transitionNode && transitionNode.parent) {
        context = transitionNode.context;
        transitionNode = transitionNode.parent;
    }
    const isAppear = !context._isMounted || !vnode.isRootInsert;
    if (isAppear && !appear && appear !== '') {
        return;
    }
    const startClass = isAppear && appearClass ? appearClass : enterClass;
    const activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
    const toClass = isAppear && appearToClass ? appearToClass : enterToClass;
    const beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
    const enterHook = isAppear ? (isFunction(appear) ? appear : enter) : enter;
    const afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
    const enterCancelledHook = isAppear
        ? appearCancelled || enterCancelled
        : enterCancelled;
    const explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);
    if (explicitEnterDuration != null) {
        checkDuration(explicitEnterDuration, 'enter', vnode);
    }
    const expectsCSS = css !== false && !isIE9;
    const userWantsControl = getHookArgumentsLength(enterHook);
    const cb = (el._enterCb = once(() => {
        if (expectsCSS) {
            removeTransitionClass(el, toClass);
            removeTransitionClass(el, activeClass);
        }
        // @ts-expect-error
        if (cb.cancelled) {
            if (expectsCSS) {
                removeTransitionClass(el, startClass);
            }
            enterCancelledHook && enterCancelledHook(el);
        }
        else {
            afterEnterHook && afterEnterHook(el);
        }
        el._enterCb = null;
    }));
    if (!vnode.data.show) {
        // remove pending leave element on enter by injecting an insert hook
        mergeVNodeHook(vnode, 'insert', () => {
            const parent = el.parentNode;
            const pendingNode = parent && parent._pending && parent._pending[vnode.key];
            if (pendingNode &&
                pendingNode.tag === vnode.tag &&
                pendingNode.elm._leaveCb) {
                pendingNode.elm._leaveCb();
            }
            enterHook && enterHook(el, cb);
        });
    }
    // start enter transition
    beforeEnterHook && beforeEnterHook(el);
    if (expectsCSS) {
        addTransitionClass(el, startClass);
        addTransitionClass(el, activeClass);
        nextFrame(() => {
            removeTransitionClass(el, startClass);
            // @ts-expect-error
            if (!cb.cancelled) {
                addTransitionClass(el, toClass);
                if (!userWantsControl) {
                    if (isValidDuration(explicitEnterDuration)) {
                        setTimeout(cb, explicitEnterDuration);
                    }
                    else {
                        whenTransitionEnds(el, type, cb);
                    }
                }
            }
        });
    }
    if (vnode.data.show) {
        toggleDisplay && toggleDisplay();
        enterHook && enterHook(el, cb);
    }
    if (!expectsCSS && !userWantsControl) {
        cb();
    }
}
function leave(vnode, rm) {
    const el = vnode.elm;
    // call enter callback now
    if (isDef(el._enterCb)) {
        el._enterCb.cancelled = true;
        el._enterCb();
    }
    const data = resolveTransition(vnode.data.transition);
    if (isUndef(data) || el.nodeType !== 1) {
        return rm();
    }
    /* istanbul ignore if */
    if (isDef(el._leaveCb)) {
        return;
    }
    const { css, type, leaveClass, leaveToClass, leaveActiveClass, beforeLeave, leave, afterLeave, leaveCancelled, delayLeave, duration } = data;
    const expectsCSS = css !== false && !isIE9;
    const userWantsControl = getHookArgumentsLength(leave);
    const explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);
    if (isDef(explicitLeaveDuration)) {
        checkDuration(explicitLeaveDuration, 'leave', vnode);
    }
    const cb = (el._leaveCb = once(() => {
        if (el.parentNode && el.parentNode._pending) {
            el.parentNode._pending[vnode.key] = null;
        }
        if (expectsCSS) {
            removeTransitionClass(el, leaveToClass);
            removeTransitionClass(el, leaveActiveClass);
        }
        // @ts-expect-error
        if (cb.cancelled) {
            if (expectsCSS) {
                removeTransitionClass(el, leaveClass);
            }
            leaveCancelled && leaveCancelled(el);
        }
        else {
            rm();
            afterLeave && afterLeave(el);
        }
        el._leaveCb = null;
    }));
    if (delayLeave) {
        delayLeave(performLeave);
    }
    else {
        performLeave();
    }
    function performLeave() {
        // the delayed leave may have already been cancelled
        // @ts-expect-error
        if (cb.cancelled) {
            return;
        }
        // record leaving element
        if (!vnode.data.show && el.parentNode) {
            (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] =
                vnode;
        }
        beforeLeave && beforeLeave(el);
        if (expectsCSS) {
            addTransitionClass(el, leaveClass);
            addTransitionClass(el, leaveActiveClass);
            nextFrame(() => {
                removeTransitionClass(el, leaveClass);
                // @ts-expect-error
                if (!cb.cancelled) {
                    addTransitionClass(el, leaveToClass);
                    if (!userWantsControl) {
                        if (isValidDuration(explicitLeaveDuration)) {
                            setTimeout(cb, explicitLeaveDuration);
                        }
                        else {
                            whenTransitionEnds(el, type, cb);
                        }
                    }
                }
            });
        }
        leave && leave(el, cb);
        if (!expectsCSS && !userWantsControl) {
            cb();
        }
    }
}
// only used in dev mode
function checkDuration(val, name, vnode) {
    if (typeof val !== 'number') {
        warn(`<transition> explicit ${name} duration is not a valid number - ` +
            `got ${JSON.stringify(val)}.`, vnode.context);
    }
    else if (isNaN(val)) {
        warn(`<transition> explicit ${name} duration is NaN - ` +
            'the duration expression might be incorrect.', vnode.context);
    }
}
function isValidDuration(val) {
    return typeof val === 'number' && !isNaN(val);
}
/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength(fn) {
    if (isUndef(fn)) {
        return false;
    }
    // @ts-expect-error
    const invokerFns = fn.fns;
    if (isDef(invokerFns)) {
        // invoker
        return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
    }
    else {
        // @ts-expect-error
        return (fn._length || fn.length) > 1;
    }
}
function _enter(_, vnode) {
    if (vnode.data.show !== true) {
        enter(vnode);
    }
}
var transition = inBrowser
    ? {
        create: _enter,
        activate: _enter,
        remove(vnode, rm) {
            /* istanbul ignore else */
            if (vnode.data.show !== true) {
                // @ts-expect-error
                leave(vnode, rm);
            }
            else {
                rm();
            }
        }
    }
    : {};

var platformModules = [attrs, klass, events, domProps, style, transition];

// the directive module should be applied last, after all
// built-in modules have been applied.
const modules = platformModules.concat(baseModules);
const patch = createPatchFunction({ nodeOps, modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */
/* istanbul ignore if */
if (isIE9) {
    // http://www.matts411.com/post/internet-explorer-9-oninput/
    document.addEventListener('selectionchange', () => {
        const el = document.activeElement;
        // @ts-expect-error
        if (el && el.vmodel) {
            trigger(el, 'input');
        }
    });
}
const directive = {
    inserted(el, binding, vnode, oldVnode) {
        if (vnode.tag === 'select') {
            // #6903
            if (oldVnode.elm && !oldVnode.elm._vOptions) {
                mergeVNodeHook(vnode, 'postpatch', () => {
                    directive.componentUpdated(el, binding, vnode);
                });
            }
            else {
                setSelected(el, binding, vnode.context);
            }
            el._vOptions = [].map.call(el.options, getValue);
        }
        else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
            el._vModifiers = binding.modifiers;
            if (!binding.modifiers.lazy) {
                el.addEventListener('compositionstart', onCompositionStart);
                el.addEventListener('compositionend', onCompositionEnd);
                // Safari < 10.2 & UIWebView doesn't fire compositionend when
                // switching focus before confirming composition choice
                // this also fixes the issue where some browsers e.g. iOS Chrome
                // fires "change" instead of "input" on autocomplete.
                el.addEventListener('change', onCompositionEnd);
                /* istanbul ignore if */
                if (isIE9) {
                    el.vmodel = true;
                }
            }
        }
    },
    componentUpdated(el, binding, vnode) {
        if (vnode.tag === 'select') {
            setSelected(el, binding, vnode.context);
            // in case the options rendered by v-for have changed,
            // it's possible that the value is out-of-sync with the rendered options.
            // detect such cases and filter out values that no longer has a matching
            // option in the DOM.
            const prevOptions = el._vOptions;
            const curOptions = (el._vOptions = [].map.call(el.options, getValue));
            if (curOptions.some((o, i) => !looseEqual(o, prevOptions[i]))) {
                // trigger change event if
                // no matching option found for at least one value
                const needReset = el.multiple
                    ? binding.value.some(v => hasNoMatchingOption(v, curOptions))
                    : binding.value !== binding.oldValue &&
                        hasNoMatchingOption(binding.value, curOptions);
                if (needReset) {
                    trigger(el, 'change');
                }
            }
        }
    }
};
function setSelected(el, binding, vm) {
    actuallySetSelected(el, binding, vm);
    /* istanbul ignore if */
    if (isIE || isEdge) {
        setTimeout(() => {
            actuallySetSelected(el, binding, vm);
        }, 0);
    }
}
function actuallySetSelected(el, binding, vm) {
    const value = binding.value;
    const isMultiple = el.multiple;
    if (isMultiple && !Array.isArray(value)) {
        warn(`<select multiple v-model="${binding.expression}"> ` +
                `expects an Array value for its binding, but got ${Object.prototype.toString
                    .call(value)
                    .slice(8, -1)}`, vm);
        return;
    }
    let selected, option;
    for (let i = 0, l = el.options.length; i < l; i++) {
        option = el.options[i];
        if (isMultiple) {
            selected = looseIndexOf(value, getValue(option)) > -1;
            if (option.selected !== selected) {
                option.selected = selected;
            }
        }
        else {
            if (looseEqual(getValue(option), value)) {
                if (el.selectedIndex !== i) {
                    el.selectedIndex = i;
                }
                return;
            }
        }
    }
    if (!isMultiple) {
        el.selectedIndex = -1;
    }
}
function hasNoMatchingOption(value, options) {
    return options.every(o => !looseEqual(o, value));
}
function getValue(option) {
    return '_value' in option ? option._value : option.value;
}
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    // prevent triggering an input event for no reason
    if (!e.target.composing)
        return;
    e.target.composing = false;
    trigger(e.target, 'input');
}
function trigger(el, type) {
    const e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
}

// recursively search for possible transition defined inside the component root
function locateNode(vnode) {
    // @ts-expect-error
    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
        ? locateNode(vnode.componentInstance._vnode)
        : vnode;
}
var show = {
    bind(el, { value }, vnode) {
        vnode = locateNode(vnode);
        const transition = vnode.data && vnode.data.transition;
        const originalDisplay = (el.__vOriginalDisplay =
            el.style.display === 'none' ? '' : el.style.display);
        if (value && transition) {
            vnode.data.show = true;
            enter(vnode, () => {
                el.style.display = originalDisplay;
            });
        }
        else {
            el.style.display = value ? originalDisplay : 'none';
        }
    },
    update(el, { value, oldValue }, vnode) {
        /* istanbul ignore if */
        if (!value === !oldValue)
            return;
        vnode = locateNode(vnode);
        const transition = vnode.data && vnode.data.transition;
        if (transition) {
            vnode.data.show = true;
            if (value) {
                enter(vnode, () => {
                    el.style.display = el.__vOriginalDisplay;
                });
            }
            else {
                leave(vnode, () => {
                    el.style.display = 'none';
                });
            }
        }
        else {
            el.style.display = value ? el.__vOriginalDisplay : 'none';
        }
    },
    unbind(el, binding, vnode, oldVnode, isDestroy) {
        if (!isDestroy) {
            el.style.display = el.__vOriginalDisplay;
        }
    }
};

var platformDirectives = {
    model: directive,
    show
};

// Provides transition support for a single element/component.
const transitionProps = {
    name: String,
    appear: Boolean,
    css: Boolean,
    mode: String,
    type: String,
    enterClass: String,
    leaveClass: String,
    enterToClass: String,
    leaveToClass: String,
    enterActiveClass: String,
    leaveActiveClass: String,
    appearClass: String,
    appearActiveClass: String,
    appearToClass: String,
    duration: [Number, String, Object]
};
// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild(vnode) {
    const compOptions = vnode && vnode.componentOptions;
    if (compOptions && compOptions.Ctor.options.abstract) {
        return getRealChild(getFirstComponentChild(compOptions.children));
    }
    else {
        return vnode;
    }
}
function extractTransitionData(comp) {
    const data = {};
    const options = comp.$options;
    // props
    for (const key in options.propsData) {
        data[key] = comp[key];
    }
    // events.
    // extract listeners and pass them directly to the transition methods
    const listeners = options._parentListeners;
    for (const key in listeners) {
        data[camelize(key)] = listeners[key];
    }
    return data;
}
function placeholder(h, rawChild) {
    // @ts-expect-error
    if (/\d-keep-alive$/.test(rawChild.tag)) {
        return h('keep-alive', {
            props: rawChild.componentOptions.propsData
        });
    }
}
function hasParentTransition(vnode) {
    while ((vnode = vnode.parent)) {
        if (vnode.data.transition) {
            return true;
        }
    }
}
function isSameChild(child, oldChild) {
    return oldChild.key === child.key && oldChild.tag === child.tag;
}
const isNotTextNode = (c) => c.tag || isAsyncPlaceholder(c);
const isVShowDirective = d => d.name === 'show';
var Transition = {
    name: 'transition',
    props: transitionProps,
    abstract: true,
    render(h) {
        let children = this.$slots.default;
        if (!children) {
            return;
        }
        // filter out text nodes (possible whitespaces)
        children = children.filter(isNotTextNode);
        /* istanbul ignore if */
        if (!children.length) {
            return;
        }
        // warn multiple elements
        if (children.length > 1) {
            warn('<transition> can only be used on a single element. Use ' +
                '<transition-group> for lists.', this.$parent);
        }
        const mode = this.mode;
        // warn invalid mode
        if (mode && mode !== 'in-out' && mode !== 'out-in') {
            warn('invalid <transition> mode: ' + mode, this.$parent);
        }
        const rawChild = children[0];
        // if this is a component root node and the component's
        // parent container node also has transition, skip.
        if (hasParentTransition(this.$vnode)) {
            return rawChild;
        }
        // apply transition data to child
        // use getRealChild() to ignore abstract components e.g. keep-alive
        const child = getRealChild(rawChild);
        /* istanbul ignore if */
        if (!child) {
            return rawChild;
        }
        if (this._leaving) {
            return placeholder(h, rawChild);
        }
        // ensure a key that is unique to the vnode type and to this transition
        // component instance. This key will be used to remove pending leaving nodes
        // during entering.
        const id = `__transition-${this._uid}-`;
        child.key =
            child.key == null
                ? child.isComment
                    ? id + 'comment'
                    : id + child.tag
                : isPrimitive(child.key)
                    ? String(child.key).indexOf(id) === 0
                        ? child.key
                        : id + child.key
                    : child.key;
        const data = ((child.data || (child.data = {})).transition =
            extractTransitionData(this));
        const oldRawChild = this._vnode;
        const oldChild = getRealChild(oldRawChild);
        // mark v-show
        // so that the transition module can hand over the control to the directive
        if (child.data.directives && child.data.directives.some(isVShowDirective)) {
            child.data.show = true;
        }
        if (oldChild &&
            oldChild.data &&
            !isSameChild(child, oldChild) &&
            !isAsyncPlaceholder(oldChild) &&
            // #6687 component root is a comment node
            !(oldChild.componentInstance &&
                oldChild.componentInstance._vnode.isComment)) {
            // replace old child transition data with fresh one
            // important for dynamic transitions!
            const oldData = (oldChild.data.transition = extend({}, data));
            // handle transition mode
            if (mode === 'out-in') {
                // return placeholder node and queue update when leave finishes
                this._leaving = true;
                mergeVNodeHook(oldData, 'afterLeave', () => {
                    this._leaving = false;
                    this.$forceUpdate();
                });
                return placeholder(h, rawChild);
            }
            else if (mode === 'in-out') {
                if (isAsyncPlaceholder(child)) {
                    return oldRawChild;
                }
                let delayedLeave;
                const performLeave = () => {
                    delayedLeave();
                };
                mergeVNodeHook(data, 'afterEnter', performLeave);
                mergeVNodeHook(data, 'enterCancelled', performLeave);
                mergeVNodeHook(oldData, 'delayLeave', leave => {
                    delayedLeave = leave;
                });
            }
        }
        return rawChild;
    }
};

// Provides transition support for list items.
const props = extend({
    tag: String,
    moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
    props,
    beforeMount() {
        const update = this._update;
        this._update = (vnode, hydrating) => {
            const restoreActiveInstance = setActiveInstance(this);
            // force removing pass
            this.__patch__(this._vnode, this.kept, false, // hydrating
            true // removeOnly (!important, avoids unnecessary moves)
            );
            this._vnode = this.kept;
            restoreActiveInstance();
            update.call(this, vnode, hydrating);
        };
    },
    render(h) {
        const tag = this.tag || this.$vnode.data.tag || 'span';
        const map = Object.create(null);
        const prevChildren = (this.prevChildren = this.children);
        const rawChildren = this.$slots.default || [];
        const children = (this.children = []);
        const transitionData = extractTransitionData(this);
        for (let i = 0; i < rawChildren.length; i++) {
            const c = rawChildren[i];
            if (c.tag) {
                if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
                    children.push(c);
                    map[c.key] = c;
                    (c.data || (c.data = {})).transition = transitionData;
                }
                else {
                    const opts = c.componentOptions;
                    const name = opts
                        ? getComponentName(opts.Ctor.options) || opts.tag || ''
                        : c.tag;
                    warn(`<transition-group> children must be keyed: <${name}>`);
                }
            }
        }
        if (prevChildren) {
            const kept = [];
            const removed = [];
            for (let i = 0; i < prevChildren.length; i++) {
                const c = prevChildren[i];
                c.data.transition = transitionData;
                // @ts-expect-error .getBoundingClientRect is not typed in Node
                c.data.pos = c.elm.getBoundingClientRect();
                if (map[c.key]) {
                    kept.push(c);
                }
                else {
                    removed.push(c);
                }
            }
            this.kept = h(tag, null, kept);
            this.removed = removed;
        }
        return h(tag, null, children);
    },
    updated() {
        const children = this.prevChildren;
        const moveClass = this.moveClass || (this.name || 'v') + '-move';
        if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
            return;
        }
        // we divide the work into three loops to avoid mixing DOM reads and writes
        // in each iteration - which helps prevent layout thrashing.
        children.forEach(callPendingCbs);
        children.forEach(recordPosition);
        children.forEach(applyTranslation);
        // force reflow to put everything in position
        // assign to this to avoid being removed in tree-shaking
        // $flow-disable-line
        this._reflow = document.body.offsetHeight;
        children.forEach((c) => {
            if (c.data.moved) {
                const el = c.elm;
                const s = el.style;
                addTransitionClass(el, moveClass);
                s.transform = s.WebkitTransform = s.transitionDuration = '';
                el.addEventListener(transitionEndEvent, (el._moveCb = function cb(e) {
                    if (e && e.target !== el) {
                        return;
                    }
                    if (!e || /transform$/.test(e.propertyName)) {
                        el.removeEventListener(transitionEndEvent, cb);
                        el._moveCb = null;
                        removeTransitionClass(el, moveClass);
                    }
                }));
            }
        });
    },
    methods: {
        hasMove(el, moveClass) {
            /* istanbul ignore if */
            if (!hasTransition) {
                return false;
            }
            /* istanbul ignore if */
            if (this._hasMove) {
                return this._hasMove;
            }
            // Detect whether an element with the move class applied has
            // CSS transitions. Since the element may be inside an entering
            // transition at this very moment, we make a clone of it and remove
            // all other transition classes applied to ensure only the move class
            // is applied.
            const clone = el.cloneNode();
            if (el._transitionClasses) {
                el._transitionClasses.forEach((cls) => {
                    removeClass(clone, cls);
                });
            }
            addClass(clone, moveClass);
            clone.style.display = 'none';
            this.$el.appendChild(clone);
            const info = getTransitionInfo(clone);
            this.$el.removeChild(clone);
            return (this._hasMove = info.hasTransform);
        }
    }
};
function callPendingCbs(c) {
    /* istanbul ignore if */
    if (c.elm._moveCb) {
        c.elm._moveCb();
    }
    /* istanbul ignore if */
    if (c.elm._enterCb) {
        c.elm._enterCb();
    }
}
function recordPosition(c) {
    c.data.newPos = c.elm.getBoundingClientRect();
}
function applyTranslation(c) {
    const oldPos = c.data.pos;
    const newPos = c.data.newPos;
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
        c.data.moved = true;
        const s = c.elm.style;
        s.transform = s.WebkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = '0s';
    }
}

var platformComponents = {
    Transition,
    TransitionGroup
};

// install platform specific utils
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;
// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);
// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;
// public mount method
Vue.prototype.$mount = function (el, hydrating) {
    el = el && inBrowser ? query(el) : undefined;
    return mountComponent(this, el, hydrating);
};
// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
    setTimeout(() => {
        if (config.devtools) {
            if (devtools) {
                devtools.emit('init', Vue);
            }
            else {
                // @ts-expect-error
                console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' +
                    'https://github.com/vuejs/vue-devtools');
            }
        }
        if (config.productionTip !== false &&
            typeof console !== 'undefined') {
            // @ts-expect-error
            console[console.info ? 'info' : 'log'](`You are running Vue in development mode.\n` +
                `Make sure to turn on production mode when deploying for production.\n` +
                `See more tips at https://vuejs.org/guide/deployment.html`);
        }
    }, 0);
}

extend(Vue, vca);

module.exports = Vue;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"timers":5}],9:[function(require,module,exports){
(function (process){
if (process.env.NODE_ENV === 'production') {
  module.exports = require('./vue.runtime.common.prod.js')
} else {
  module.exports = require('./vue.runtime.common.dev.js')
}

}).call(this,require('_process'))

},{"./vue.runtime.common.dev.js":8,"./vue.runtime.common.prod.js":10,"_process":4}],10:[function(require,module,exports){
(function (global,setImmediate){
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
"use strict";const t=Object.freeze({}),e=Array.isArray;function n(t){return null==t}function o(t){return null!=t}function r(t){return!0===t}function s(t){return"string"==typeof t||"number"==typeof t||"symbol"==typeof t||"boolean"==typeof t}function i(t){return"function"==typeof t}function c(t){return null!==t&&"object"==typeof t}const a=Object.prototype.toString;function l(t){return"[object Object]"===a.call(t)}function u(t){const e=parseFloat(String(t));return e>=0&&Math.floor(e)===e&&isFinite(t)}function f(t){return o(t)&&"function"==typeof t.then&&"function"==typeof t.catch}function d(t){return null==t?"":Array.isArray(t)||l(t)&&t.toString===a?JSON.stringify(t,null,2):String(t)}function p(t){const e=parseFloat(t);return isNaN(e)?t:e}function h(t,e){const n=Object.create(null),o=t.split(",");for(let t=0;t<o.length;t++)n[o[t]]=!0;return e?t=>n[t.toLowerCase()]:t=>n[t]}const m=h("key,ref,slot,slot-scope,is");function _(t,e){const n=t.length;if(n){if(e===t[n-1])return void(t.length=n-1);const o=t.indexOf(e);if(o>-1)return t.splice(o,1)}}const v=Object.prototype.hasOwnProperty;function y(t,e){return v.call(t,e)}function g(t){const e=Object.create(null);return function(n){return e[n]||(e[n]=t(n))}}const b=/-(\w)/g,$=g((t=>t.replace(b,((t,e)=>e?e.toUpperCase():"")))),w=g((t=>t.charAt(0).toUpperCase()+t.slice(1))),C=/\B([A-Z])/g,x=g((t=>t.replace(C,"-$1").toLowerCase()));const k=Function.prototype.bind?function(t,e){return t.bind(e)}:function(t,e){function n(n){const o=arguments.length;return o?o>1?t.apply(e,arguments):t.call(e,n):t.call(e)}return n._length=t.length,n};function O(t,e){e=e||0;let n=t.length-e;const o=new Array(n);for(;n--;)o[n]=t[n+e];return o}function S(t,e){for(const n in e)t[n]=e[n];return t}function j(t){const e={};for(let n=0;n<t.length;n++)t[n]&&S(e,t[n]);return e}function A(t,e,n){}const T=(t,e,n)=>!1,E=t=>t;function P(t,e){if(t===e)return!0;const n=c(t),o=c(e);if(!n||!o)return!n&&!o&&String(t)===String(e);try{const n=Array.isArray(t),o=Array.isArray(e);if(n&&o)return t.length===e.length&&t.every(((t,n)=>P(t,e[n])));if(t instanceof Date&&e instanceof Date)return t.getTime()===e.getTime();if(n||o)return!1;{const n=Object.keys(t),o=Object.keys(e);return n.length===o.length&&n.every((n=>P(t[n],e[n])))}}catch(t){return!1}}function I(t,e){for(let n=0;n<t.length;n++)if(P(t[n],e))return n;return-1}function D(t){let e=!1;return function(){e||(e=!0,t.apply(this,arguments))}}function N(t,e){return t===e?0===t&&1/t!=1/e:t==t||e==e}const M=["component","directive","filter"],R=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"];var L={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:T,isReservedAttr:T,isUnknownElement:T,getTagNamespace:A,parsePlatformTagName:E,mustUseProp:T,async:!0,_lifecycleHooks:R};function F(t){const e=(t+"").charCodeAt(0);return 36===e||95===e}function U(t,e,n,o){Object.defineProperty(t,e,{value:n,enumerable:!!o,writable:!0,configurable:!0})}const B=new RegExp(`[^${/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/.source}.$_\\d]`);const V="__proto__"in{},z="undefined"!=typeof window,H=z&&window.navigator.userAgent.toLowerCase(),W=H&&/msie|trident/.test(H),K=H&&H.indexOf("msie 9.0")>0,q=H&&H.indexOf("edge/")>0;H&&H.indexOf("android");const G=H&&/iphone|ipad|ipod|ios/.test(H);H&&/chrome\/\d+/.test(H),H&&/phantomjs/.test(H);const Z=H&&H.match(/firefox\/(\d+)/),J={}.watch;let X,Q=!1;if(z)try{const t={};Object.defineProperty(t,"passive",{get(){Q=!0}}),window.addEventListener("test-passive",null,t)}catch(t){}const Y=()=>(void 0===X&&(X=!z&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),X),tt=z&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function et(t){return"function"==typeof t&&/native code/.test(t.toString())}const nt="undefined"!=typeof Symbol&&et(Symbol)&&"undefined"!=typeof Reflect&&et(Reflect.ownKeys);let ot;ot="undefined"!=typeof Set&&et(Set)?Set:class{constructor(){this.set=Object.create(null)}has(t){return!0===this.set[t]}add(t){this.set[t]=!0}clear(){this.set=Object.create(null)}};let rt=null;function st(t=null){t||rt&&rt._scope.off(),rt=t,t&&t._scope.on()}class it{constructor(t,e,n,o,r,s,i,c){this.tag=t,this.data=e,this.children=n,this.text=o,this.elm=r,this.ns=void 0,this.context=s,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=c,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}get child(){return this.componentInstance}}const ct=(t="")=>{const e=new it;return e.text=t,e.isComment=!0,e};function at(t){return new it(void 0,void 0,void 0,String(t))}function lt(t){const e=new it(t.tag,t.data,t.children&&t.children.slice(),t.text,t.elm,t.context,t.componentOptions,t.asyncFactory);return e.ns=t.ns,e.isStatic=t.isStatic,e.key=t.key,e.isComment=t.isComment,e.fnContext=t.fnContext,e.fnOptions=t.fnOptions,e.fnScopeId=t.fnScopeId,e.asyncMeta=t.asyncMeta,e.isCloned=!0,e}let ut=0;const ft=[];class dt{constructor(){this._pending=!1,this.id=ut++,this.subs=[]}addSub(t){this.subs.push(t)}removeSub(t){this.subs[this.subs.indexOf(t)]=null,this._pending||(this._pending=!0,ft.push(this))}depend(t){dt.target&&dt.target.addDep(this)}notify(t){const e=this.subs.filter((t=>t));for(let t=0,n=e.length;t<n;t++){e[t].update()}}}dt.target=null;const pt=[];function ht(t){pt.push(t),dt.target=t}function mt(){pt.pop(),dt.target=pt[pt.length-1]}const _t=Array.prototype,vt=Object.create(_t);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(t){const e=_t[t];U(vt,t,(function(...n){const o=e.apply(this,n),r=this.__ob__;let s;switch(t){case"push":case"unshift":s=n;break;case"splice":s=n.slice(2)}return s&&r.observeArray(s),r.dep.notify(),o}))}));const yt=Object.getOwnPropertyNames(vt),gt={};let bt=!0;function $t(t){bt=t}const wt={notify:A,depend:A,addSub:A,removeSub:A};class Ct{constructor(t,n=!1,o=!1){if(this.value=t,this.shallow=n,this.mock=o,this.dep=o?wt:new dt,this.vmCount=0,U(t,"__ob__",this),e(t)){if(!o)if(V)t.__proto__=vt;else for(let e=0,n=yt.length;e<n;e++){const n=yt[e];U(t,n,vt[n])}n||this.observeArray(t)}else{const e=Object.keys(t);for(let r=0;r<e.length;r++){kt(t,e[r],gt,void 0,n,o)}}}observeArray(t){for(let e=0,n=t.length;e<n;e++)xt(t[e],!1,this.mock)}}function xt(t,n,o){return t&&y(t,"__ob__")&&t.__ob__ instanceof Ct?t.__ob__:!bt||!o&&Y()||!e(t)&&!l(t)||!Object.isExtensible(t)||t.__v_skip||Dt(t)||t instanceof it?void 0:new Ct(t,n,o)}function kt(t,n,o,r,s,i){const c=new dt,a=Object.getOwnPropertyDescriptor(t,n);if(a&&!1===a.configurable)return;const l=a&&a.get,u=a&&a.set;l&&!u||o!==gt&&2!==arguments.length||(o=t[n]);let f=!s&&xt(o,!1,i);return Object.defineProperty(t,n,{enumerable:!0,configurable:!0,get:function(){const n=l?l.call(t):o;return dt.target&&(c.depend(),f&&(f.dep.depend(),e(n)&&jt(n))),Dt(n)&&!s?n.value:n},set:function(e){const n=l?l.call(t):o;if(N(n,e)){if(u)u.call(t,e);else{if(l)return;if(!s&&Dt(n)&&!Dt(e))return void(n.value=e);o=e}f=!s&&xt(e,!1,i),c.notify()}}}),c}function Ot(t,n,o){if(It(t))return;const r=t.__ob__;return e(t)&&u(n)?(t.length=Math.max(t.length,n),t.splice(n,1,o),r&&!r.shallow&&r.mock&&xt(o,!1,!0),o):n in t&&!(n in Object.prototype)?(t[n]=o,o):t._isVue||r&&r.vmCount?o:r?(kt(r.value,n,o,void 0,r.shallow,r.mock),r.dep.notify(),o):(t[n]=o,o)}function St(t,n){if(e(t)&&u(n))return void t.splice(n,1);const o=t.__ob__;t._isVue||o&&o.vmCount||It(t)||y(t,n)&&(delete t[n],o&&o.dep.notify())}function jt(t){for(let n,o=0,r=t.length;o<r;o++)n=t[o],n&&n.__ob__&&n.__ob__.dep.depend(),e(n)&&jt(n)}function At(t){return Tt(t,!0),U(t,"__v_isShallow",!0),t}function Tt(t,e){It(t)||xt(t,e,Y())}function Et(t){return It(t)?Et(t.__v_raw):!(!t||!t.__ob__)}function Pt(t){return!(!t||!t.__v_isShallow)}function It(t){return!(!t||!t.__v_isReadonly)}function Dt(t){return!(!t||!0!==t.__v_isRef)}function Nt(t,e){if(Dt(t))return t;const n={};return U(n,"__v_isRef",!0),U(n,"__v_isShallow",e),U(n,"dep",kt(n,"value",t,null,e,Y())),n}function Mt(t,e,n){Object.defineProperty(t,n,{enumerable:!0,configurable:!0,get:()=>{const t=e[n];if(Dt(t))return t.value;{const e=t&&t.__ob__;return e&&e.dep.depend(),t}},set:t=>{const o=e[n];Dt(o)&&!Dt(t)?o.value=t:e[n]=t}})}function Rt(t,e,n){const o=t[e];if(Dt(o))return o;const r={get value(){const o=t[e];return void 0===o?n:o},set value(n){t[e]=n}};return U(r,"__v_isRef",!0),r}function Lt(t){return Ft(t,!1)}function Ft(t,e){if(!l(t))return t;if(It(t))return t;const n=e?"__v_rawToShallowReadonly":"__v_rawToReadonly",o=t[n];if(o)return o;const r=Object.create(Object.getPrototypeOf(t));U(t,n,r),U(r,"__v_isReadonly",!0),U(r,"__v_raw",t),Dt(t)&&U(r,"__v_isRef",!0),(e||Pt(t))&&U(r,"__v_isShallow",!0);const s=Object.keys(t);for(let n=0;n<s.length;n++)Ut(r,t,s[n],e);return r}function Ut(t,e,n,o){Object.defineProperty(t,n,{enumerable:!0,configurable:!0,get(){const t=e[n];return o||!l(t)?t:Lt(t)},set(){}})}function Bt(t,e){return zt(t,null,{flush:"post"})}const Vt={};function zt(n,o,{immediate:r,deep:s,flush:c="pre",onTrack:a,onTrigger:l}=t){const u=rt,f=(t,e,n=null)=>Ie(t,null,n,u,e);let d,p,h=!1,m=!1;if(Dt(n)?(d=()=>n.value,h=Pt(n)):Et(n)?(d=()=>(n.__ob__.dep.depend(),n),s=!0):e(n)?(m=!0,h=n.some((t=>Et(t)||Pt(t))),d=()=>n.map((t=>Dt(t)?t.value:Et(t)?on(t):i(t)?f(t,"watcher getter"):void 0))):d=i(n)?o?()=>f(n,"watcher getter"):()=>{if(!u||!u._isDestroyed)return p&&p(),f(n,"watcher",[_])}:A,o&&s){const t=d;d=()=>on(t())}let _=t=>{p=v.onStop=()=>{f(t,"watcher cleanup")}};if(Y())return _=A,o?r&&f(o,"watcher callback",[d(),m?[]:void 0,_]):d(),A;const v=new an(rt,d,A,{lazy:!0});v.noRecurse=!o;let y=m?[]:Vt;return v.run=()=>{if(v.active)if(o){const t=v.get();(s||h||(m?t.some(((t,e)=>N(t,y[e]))):N(t,y)))&&(p&&p(),f(o,"watcher callback",[t,y===Vt?void 0:y,_]),y=t)}else v.get()},"sync"===c?v.update=v.run:"post"===c?(v.post=!0,v.update=()=>An(v)):v.update=()=>{if(u&&u===rt&&!u._isMounted){const t=u._preWatchers||(u._preWatchers=[]);t.indexOf(v)<0&&t.push(v)}else An(v)},o?r?v.run():y=v.get():"post"===c&&u?u.$once("hook:mounted",(()=>v.get())):v.get(),()=>{v.teardown()}}let Ht;class Wt{constructor(t=!1){this.detached=t,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Ht,!t&&Ht&&(this.index=(Ht.scopes||(Ht.scopes=[])).push(this)-1)}run(t){if(this.active){const e=Ht;try{return Ht=this,t()}finally{Ht=e}}}on(){Ht=this}off(){Ht=this.parent}stop(t){if(this.active){let e,n;for(e=0,n=this.effects.length;e<n;e++)this.effects[e].teardown();for(e=0,n=this.cleanups.length;e<n;e++)this.cleanups[e]();if(this.scopes)for(e=0,n=this.scopes.length;e<n;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!t){const t=this.parent.scopes.pop();t&&t!==this&&(this.parent.scopes[this.index]=t,t.index=this.index)}this.parent=void 0,this.active=!1}}}function Kt(t){const e=t._provided,n=t.$parent&&t.$parent._provided;return n===e?t._provided=Object.create(n):e}const qt=g((t=>{const e="&"===t.charAt(0),n="~"===(t=e?t.slice(1):t).charAt(0),o="!"===(t=n?t.slice(1):t).charAt(0);return{name:t=o?t.slice(1):t,once:n,capture:o,passive:e}}));function Gt(t,n){function o(){const t=o.fns;if(!e(t))return Ie(t,null,arguments,n,"v-on handler");{const e=t.slice();for(let t=0;t<e.length;t++)Ie(e[t],null,arguments,n,"v-on handler")}}return o.fns=t,o}function Zt(t,e,o,s,i,c){let a,l,u,f;for(a in t)l=t[a],u=e[a],f=qt(a),n(l)||(n(u)?(n(l.fns)&&(l=t[a]=Gt(l,c)),r(f.once)&&(l=t[a]=i(f.name,l,f.capture)),o(f.name,l,f.capture,f.passive,f.params)):l!==u&&(u.fns=l,t[a]=u));for(a in e)n(t[a])&&(f=qt(a),s(f.name,e[a],f.capture))}function Jt(t,e,s){let i;t instanceof it&&(t=t.data.hook||(t.data.hook={}));const c=t[e];function a(){s.apply(this,arguments),_(i.fns,a)}n(c)?i=Gt([a]):o(c.fns)&&r(c.merged)?(i=c,i.fns.push(a)):i=Gt([c,a]),i.merged=!0,t[e]=i}function Xt(t,e,n,r,s){if(o(e)){if(y(e,n))return t[n]=e[n],s||delete e[n],!0;if(y(e,r))return t[n]=e[r],s||delete e[r],!0}return!1}function Qt(t){return s(t)?[at(t)]:e(t)?te(t):void 0}function Yt(t){return o(t)&&o(t.text)&&!1===t.isComment}function te(t,i){const c=[];let a,l,u,f;for(a=0;a<t.length;a++)l=t[a],n(l)||"boolean"==typeof l||(u=c.length-1,f=c[u],e(l)?l.length>0&&(l=te(l,`${i||""}_${a}`),Yt(l[0])&&Yt(f)&&(c[u]=at(f.text+l[0].text),l.shift()),c.push.apply(c,l)):s(l)?Yt(f)?c[u]=at(f.text+l):""!==l&&c.push(at(l)):Yt(l)&&Yt(f)?c[u]=at(f.text+l.text):(r(t._isVList)&&o(l.tag)&&n(l.key)&&o(i)&&(l.key=`__vlist${i}_${a}__`),c.push(l)));return c}function ee(t,n){let r,s,i,a,l=null;if(e(t)||"string"==typeof t)for(l=new Array(t.length),r=0,s=t.length;r<s;r++)l[r]=n(t[r],r);else if("number"==typeof t)for(l=new Array(t),r=0;r<t;r++)l[r]=n(r+1,r);else if(c(t))if(nt&&t[Symbol.iterator]){l=[];const e=t[Symbol.iterator]();let o=e.next();for(;!o.done;)l.push(n(o.value,l.length)),o=e.next()}else for(i=Object.keys(t),l=new Array(i.length),r=0,s=i.length;r<s;r++)a=i[r],l[r]=n(t[a],a,r);return o(l)||(l=[]),l._isVList=!0,l}function ne(t,e,n,o){const r=this.$scopedSlots[t];let s;r?(n=n||{},o&&(n=S(S({},o),n)),s=r(n)||(i(e)?e():e)):s=this.$slots[t]||(i(e)?e():e);const c=n&&n.slot;return c?this.$createElement("template",{slot:c},s):s}function oe(t){return qn(this.$options,"filters",t)||E}function re(t,n){return e(t)?-1===t.indexOf(n):t!==n}function se(t,e,n,o,r){const s=L.keyCodes[e]||n;return r&&o&&!L.keyCodes[e]?re(r,o):s?re(s,t):o?x(o)!==e:void 0===t}function ie(t,n,o,r,s){if(o)if(c(o)){let i;e(o)&&(o=j(o));for(const e in o){if("class"===e||"style"===e||m(e))i=t;else{const o=t.attrs&&t.attrs.type;i=r||L.mustUseProp(n,o,e)?t.domProps||(t.domProps={}):t.attrs||(t.attrs={})}const c=$(e),a=x(e);if(!(c in i)&&!(a in i)&&(i[e]=o[e],s)){(t.on||(t.on={}))[`update:${e}`]=function(t){o[e]=t}}}}else;return t}function ce(t,e){const n=this._staticTrees||(this._staticTrees=[]);let o=n[t];return o&&!e||(o=n[t]=this.$options.staticRenderFns[t].call(this._renderProxy,this._c,this),le(o,`__static__${t}`,!1)),o}function ae(t,e,n){return le(t,`__once__${e}${n?`_${n}`:""}`,!0),t}function le(t,n,o){if(e(t))for(let e=0;e<t.length;e++)t[e]&&"string"!=typeof t[e]&&ue(t[e],`${n}_${e}`,o);else ue(t,n,o)}function ue(t,e,n){t.isStatic=!0,t.key=e,t.isOnce=n}function fe(t,e){if(e)if(l(e)){const n=t.on=t.on?S({},t.on):{};for(const t in e){const o=n[t],r=e[t];n[t]=o?[].concat(o,r):r}}else;return t}function de(t,n,o,r){n=n||{$stable:!o};for(let r=0;r<t.length;r++){const s=t[r];e(s)?de(s,n,o):s&&(s.proxy&&(s.fn.proxy=!0),n[s.key]=s.fn)}return r&&(n.$key=r),n}function pe(t,e){for(let n=0;n<e.length;n+=2){const o=e[n];"string"==typeof o&&o&&(t[e[n]]=e[n+1])}return t}function he(t,e){return"string"==typeof t?e+t:t}function me(t){t._o=ae,t._n=p,t._s=d,t._l=ee,t._t=ne,t._q=P,t._i=I,t._m=ce,t._f=oe,t._k=se,t._b=ie,t._v=at,t._e=ct,t._u=de,t._g=fe,t._d=pe,t._p=he}function _e(t,e){if(!t||!t.length)return{};const n={};for(let o=0,r=t.length;o<r;o++){const r=t[o],s=r.data;if(s&&s.attrs&&s.attrs.slot&&delete s.attrs.slot,r.context!==e&&r.fnContext!==e||!s||null==s.slot)(n.default||(n.default=[])).push(r);else{const t=s.slot,e=n[t]||(n[t]=[]);"template"===r.tag?e.push.apply(e,r.children||[]):e.push(r)}}for(const t in n)n[t].every(ve)&&delete n[t];return n}function ve(t){return t.isComment&&!t.asyncFactory||" "===t.text}function ye(t){return t.isComment&&t.asyncFactory}function ge(e,n,o,r){let s;const i=Object.keys(o).length>0,c=n?!!n.$stable:!i,a=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(c&&r&&r!==t&&a===r.$key&&!i&&!r.$hasNormal)return r;s={};for(const t in n)n[t]&&"$"!==t[0]&&(s[t]=be(e,o,t,n[t]))}else s={};for(const t in o)t in s||(s[t]=$e(o,t));return n&&Object.isExtensible(n)&&(n._normalized=s),U(s,"$stable",c),U(s,"$key",a),U(s,"$hasNormal",i),s}function be(t,n,o,r){const s=function(){const n=rt;st(t);let o=arguments.length?r.apply(null,arguments):r({});o=o&&"object"==typeof o&&!e(o)?[o]:Qt(o);const s=o&&o[0];return st(n),o&&(!s||1===o.length&&s.isComment&&!ye(s))?void 0:o};return r.proxy&&Object.defineProperty(n,o,{get:s,enumerable:!0,configurable:!0}),s}function $e(t,e){return()=>t[e]}function we(e){return{get attrs(){if(!e._attrsProxy){const n=e._attrsProxy={};U(n,"_v_attr_proxy",!0),Ce(n,e.$attrs,t,e,"$attrs")}return e._attrsProxy},get listeners(){if(!e._listenersProxy){Ce(e._listenersProxy={},e.$listeners,t,e,"$listeners")}return e._listenersProxy},get slots(){return function(t){t._slotsProxy||ke(t._slotsProxy={},t.$scopedSlots);return t._slotsProxy}(e)},emit:k(e.$emit,e),expose(t){t&&Object.keys(t).forEach((n=>Mt(e,t,n)))}}}function Ce(t,e,n,o,r){let s=!1;for(const i in e)i in t?e[i]!==n[i]&&(s=!0):(s=!0,xe(t,i,o,r));for(const n in t)n in e||(s=!0,delete t[n]);return s}function xe(t,e,n,o){Object.defineProperty(t,e,{enumerable:!0,configurable:!0,get:()=>n[o][e]})}function ke(t,e){for(const n in e)t[n]=e[n];for(const n in t)n in e||delete t[n]}function Oe(){const t=rt;return t._setupContext||(t._setupContext=we(t))}let Se=null;function je(t,e){return(t.__esModule||nt&&"Module"===t[Symbol.toStringTag])&&(t=t.default),c(t)?e.extend(t):t}function Ae(t){if(e(t))for(let e=0;e<t.length;e++){const n=t[e];if(o(n)&&(o(n.componentOptions)||ye(n)))return n}}function Te(t,n,a,l,u,f){return(e(a)||s(a))&&(u=l,l=a,a=void 0),r(f)&&(u=2),function(t,n,r,s,a){if(o(r)&&o(r.__ob__))return ct();o(r)&&o(r.is)&&(n=r.is);if(!n)return ct();e(s)&&i(s[0])&&((r=r||{}).scopedSlots={default:s[0]},s.length=0);2===a?s=Qt(s):1===a&&(s=function(t){for(let n=0;n<t.length;n++)if(e(t[n]))return Array.prototype.concat.apply([],t);return t}(s));let l,u;if("string"==typeof n){let e;u=t.$vnode&&t.$vnode.ns||L.getTagNamespace(n),l=L.isReservedTag(n)?new it(L.parsePlatformTagName(n),r,s,void 0,void 0,t):r&&r.pre||!o(e=qn(t.$options,"components",n))?new it(n,r,s,void 0,void 0,t):Rn(e,r,t,s,n)}else l=Rn(n,r,t,s);return e(l)?l:o(l)?(o(u)&&Ee(l,u),o(r)&&function(t){c(t.style)&&on(t.style);c(t.class)&&on(t.class)}(r),l):ct()}(t,n,a,l,u)}function Ee(t,e,s){if(t.ns=e,"foreignObject"===t.tag&&(e=void 0,s=!0),o(t.children))for(let i=0,c=t.children.length;i<c;i++){const c=t.children[i];o(c.tag)&&(n(c.ns)||r(s)&&"svg"!==c.tag)&&Ee(c,e,s)}}function Pe(t,e,n){ht();try{if(e){let o=e;for(;o=o.$parent;){const r=o.$options.errorCaptured;if(r)for(let s=0;s<r.length;s++)try{if(!1===r[s].call(o,t,e,n))return}catch(t){De(t,o,"errorCaptured hook")}}}De(t,e,n)}finally{mt()}}function Ie(t,e,n,o,r){let s;try{s=n?t.apply(e,n):t.call(e),s&&!s._isVue&&f(s)&&!s._handled&&(s.catch((t=>Pe(t,o,r+" (Promise/async)"))),s._handled=!0)}catch(t){Pe(t,o,r)}return s}function De(t,e,n){if(L.errorHandler)try{return L.errorHandler.call(null,t,e,n)}catch(e){e!==t&&Ne(e)}Ne(t)}function Ne(t,e,n){if(!z||"undefined"==typeof console)throw t;console.error(t)}let Me=!1;const Re=[];let Le,Fe=!1;function Ue(){Fe=!1;const t=Re.slice(0);Re.length=0;for(let e=0;e<t.length;e++)t[e]()}if("undefined"!=typeof Promise&&et(Promise)){const t=Promise.resolve();Le=()=>{t.then(Ue),G&&setTimeout(A)},Me=!0}else if(W||"undefined"==typeof MutationObserver||!et(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Le="undefined"!=typeof setImmediate&&et(setImmediate)?()=>{setImmediate(Ue)}:()=>{setTimeout(Ue,0)};else{let t=1;const e=new MutationObserver(Ue),n=document.createTextNode(String(t));e.observe(n,{characterData:!0}),Le=()=>{t=(t+1)%2,n.data=String(t)},Me=!0}function Be(t,e){let n;if(Re.push((()=>{if(t)try{t.call(e)}catch(t){Pe(t,e,"nextTick")}else n&&n(e)})),Fe||(Fe=!0,Le()),!t&&"undefined"!=typeof Promise)return new Promise((t=>{n=t}))}function Ve(t){return(e,n=rt)=>{if(n)return function(t,e,n){const o=t.$options;o[e]=zn(o[e],n)}(n,t,e)}}const ze=Ve("beforeMount"),He=Ve("mounted"),We=Ve("beforeUpdate"),Ke=Ve("updated"),qe=Ve("beforeDestroy"),Ge=Ve("destroyed"),Ze=Ve("activated"),Je=Ve("deactivated"),Xe=Ve("serverPrefetch"),Qe=Ve("renderTracked"),Ye=Ve("renderTriggered"),tn=Ve("errorCaptured");var en=Object.freeze({__proto__:null,version:"2.7.14",defineComponent:function(t){return t},ref:function(t){return Nt(t,!1)},shallowRef:function(t){return Nt(t,!0)},isRef:Dt,toRef:Rt,toRefs:function(t){const n=e(t)?new Array(t.length):{};for(const e in t)n[e]=Rt(t,e);return n},unref:function(t){return Dt(t)?t.value:t},proxyRefs:function(t){if(Et(t))return t;const e={},n=Object.keys(t);for(let o=0;o<n.length;o++)Mt(e,t,n[o]);return e},customRef:function(t){const e=new dt,{get:n,set:o}=t((()=>{e.depend()}),(()=>{e.notify()})),r={get value(){return n()},set value(t){o(t)}};return U(r,"__v_isRef",!0),r},triggerRef:function(t){t.dep&&t.dep.notify()},reactive:function(t){return Tt(t,!1),t},isReactive:Et,isReadonly:It,isShallow:Pt,isProxy:function(t){return Et(t)||It(t)},shallowReactive:At,markRaw:function(t){return Object.isExtensible(t)&&U(t,"__v_skip",!0),t},toRaw:function t(e){const n=e&&e.__v_raw;return n?t(n):e},readonly:Lt,shallowReadonly:function(t){return Ft(t,!0)},computed:function(t,e){let n,o;const r=i(t);r?(n=t,o=A):(n=t.get,o=t.set);const s=Y()?null:new an(rt,n,A,{lazy:!0}),c={effect:s,get value(){return s?(s.dirty&&s.evaluate(),dt.target&&s.depend(),s.value):n()},set value(t){o(t)}};return U(c,"__v_isRef",!0),U(c,"__v_isReadonly",r),c},watch:function(t,e,n){return zt(t,e,n)},watchEffect:function(t,e){return zt(t,null,e)},watchPostEffect:Bt,watchSyncEffect:function(t,e){return zt(t,null,{flush:"sync"})},EffectScope:Wt,effectScope:function(t){return new Wt(t)},onScopeDispose:function(t){Ht&&Ht.cleanups.push(t)},getCurrentScope:function(){return Ht},provide:function(t,e){rt&&(Kt(rt)[t]=e)},inject:function(t,e,n=!1){const o=rt;if(o){const r=o.$parent&&o.$parent._provided;if(r&&t in r)return r[t];if(arguments.length>1)return n&&i(e)?e.call(o):e}},h:function(t,e,n){return Te(rt,t,e,n,2,!0)},getCurrentInstance:function(){return rt&&{proxy:rt}},useSlots:function(){return Oe().slots},useAttrs:function(){return Oe().attrs},useListeners:function(){return Oe().listeners},mergeDefaults:function(t,n){const o=e(t)?t.reduce(((t,e)=>(t[e]={},t)),{}):t;for(const t in n){const r=o[t];r?e(r)||i(r)?o[t]={type:r,default:n[t]}:r.default=n[t]:null===r&&(o[t]={default:n[t]})}return o},nextTick:Be,set:Ot,del:St,useCssModule:function(e="$style"){{if(!rt)return t;const n=rt[e];return n||t}},useCssVars:function(t){if(!z)return;const e=rt;e&&Bt((()=>{const n=e.$el,o=t(e,e._setupProxy);if(n&&1===n.nodeType){const t=n.style;for(const e in o)t.setProperty(`--${e}`,o[e])}}))},defineAsyncComponent:function(t){i(t)&&(t={loader:t});const{loader:e,loadingComponent:n,errorComponent:o,delay:r=200,timeout:s,suspensible:c=!1,onError:a}=t;let l=null,u=0;const f=()=>{let t;return l||(t=l=e().catch((t=>{if(t=t instanceof Error?t:new Error(String(t)),a)return new Promise(((e,n)=>{a(t,(()=>e((u++,l=null,f()))),(()=>n(t)),u+1)}));throw t})).then((e=>t!==l&&l?l:(e&&(e.__esModule||"Module"===e[Symbol.toStringTag])&&(e=e.default),e))))};return()=>({component:f(),delay:r,timeout:s,error:o,loading:n})},onBeforeMount:ze,onMounted:He,onBeforeUpdate:We,onUpdated:Ke,onBeforeUnmount:qe,onUnmounted:Ge,onActivated:Ze,onDeactivated:Je,onServerPrefetch:Xe,onRenderTracked:Qe,onRenderTriggered:Ye,onErrorCaptured:function(t,e=rt){tn(t,e)}});const nn=new ot;function on(t){return rn(t,nn),nn.clear(),t}function rn(t,n){let o,r;const s=e(t);if(!(!s&&!c(t)||t.__v_skip||Object.isFrozen(t)||t instanceof it)){if(t.__ob__){const e=t.__ob__.dep.id;if(n.has(e))return;n.add(e)}if(s)for(o=t.length;o--;)rn(t[o],n);else if(Dt(t))rn(t.value,n);else for(r=Object.keys(t),o=r.length;o--;)rn(t[r[o]],n)}}let sn,cn=0;class an{constructor(t,e,n,o,r){!function(t,e=Ht){e&&e.active&&e.effects.push(t)}(this,Ht&&!Ht._vm?Ht:t?t._scope:void 0),(this.vm=t)&&r&&(t._watcher=this),o?(this.deep=!!o.deep,this.user=!!o.user,this.lazy=!!o.lazy,this.sync=!!o.sync,this.before=o.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++cn,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new ot,this.newDepIds=new ot,this.expression="",i(e)?this.getter=e:(this.getter=function(t){if(B.test(t))return;const e=t.split(".");return function(t){for(let n=0;n<e.length;n++){if(!t)return;t=t[e[n]]}return t}}(e),this.getter||(this.getter=A)),this.value=this.lazy?void 0:this.get()}get(){let t;ht(this);const e=this.vm;try{t=this.getter.call(e,e)}catch(t){if(!this.user)throw t;Pe(t,e,`getter for watcher "${this.expression}"`)}finally{this.deep&&on(t),mt(),this.cleanupDeps()}return t}addDep(t){const e=t.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(t),this.depIds.has(e)||t.addSub(this))}cleanupDeps(){let t=this.deps.length;for(;t--;){const e=this.deps[t];this.newDepIds.has(e.id)||e.removeSub(this)}let e=this.depIds;this.depIds=this.newDepIds,this.newDepIds=e,this.newDepIds.clear(),e=this.deps,this.deps=this.newDeps,this.newDeps=e,this.newDeps.length=0}update(){this.lazy?this.dirty=!0:this.sync?this.run():An(this)}run(){if(this.active){const t=this.get();if(t!==this.value||c(t)||this.deep){const e=this.value;if(this.value=t,this.user){const n=`callback for watcher "${this.expression}"`;Ie(this.cb,this.vm,[t,e],this.vm,n)}else this.cb.call(this.vm,t,e)}}}evaluate(){this.value=this.get(),this.dirty=!1}depend(){let t=this.deps.length;for(;t--;)this.deps[t].depend()}teardown(){if(this.vm&&!this.vm._isBeingDestroyed&&_(this.vm._scope.effects,this),this.active){let t=this.deps.length;for(;t--;)this.deps[t].removeSub(this);this.active=!1,this.onStop&&this.onStop()}}}function ln(t,e){sn.$on(t,e)}function un(t,e){sn.$off(t,e)}function fn(t,e){const n=sn;return function o(){const r=e.apply(null,arguments);null!==r&&n.$off(t,o)}}function dn(t,e,n){sn=t,Zt(e,n||{},ln,un,fn,t),sn=void 0}let pn=null;function hn(t){const e=pn;return pn=t,()=>{pn=e}}function mn(t){for(;t&&(t=t.$parent);)if(t._inactive)return!0;return!1}function _n(t,e){if(e){if(t._directInactive=!1,mn(t))return}else if(t._directInactive)return;if(t._inactive||null===t._inactive){t._inactive=!1;for(let e=0;e<t.$children.length;e++)_n(t.$children[e]);yn(t,"activated")}}function vn(t,e){if(!(e&&(t._directInactive=!0,mn(t))||t._inactive)){t._inactive=!0;for(let e=0;e<t.$children.length;e++)vn(t.$children[e]);yn(t,"deactivated")}}function yn(t,e,n,o=!0){ht();const r=rt;o&&st(t);const s=t.$options[e],i=`${e} hook`;if(s)for(let e=0,o=s.length;e<o;e++)Ie(s[e],t,n||null,t,i);t._hasHookEvent&&t.$emit("hook:"+e),o&&st(r),mt()}const gn=[],bn=[];let $n={},wn=!1,Cn=!1,xn=0;let kn=0,On=Date.now;if(z&&!W){const t=window.performance;t&&"function"==typeof t.now&&On()>document.createEvent("Event").timeStamp&&(On=()=>t.now())}const Sn=(t,e)=>{if(t.post){if(!e.post)return 1}else if(e.post)return-1;return t.id-e.id};function jn(){let t,e;for(kn=On(),Cn=!0,gn.sort(Sn),xn=0;xn<gn.length;xn++)t=gn[xn],t.before&&t.before(),e=t.id,$n[e]=null,t.run();const n=bn.slice(),o=gn.slice();xn=gn.length=bn.length=0,$n={},wn=Cn=!1,function(t){for(let e=0;e<t.length;e++)t[e]._inactive=!0,_n(t[e],!0)}(n),function(t){let e=t.length;for(;e--;){const n=t[e],o=n.vm;o&&o._watcher===n&&o._isMounted&&!o._isDestroyed&&yn(o,"updated")}}(o),(()=>{for(let t=0;t<ft.length;t++){const e=ft[t];e.subs=e.subs.filter((t=>t)),e._pending=!1}ft.length=0})(),tt&&L.devtools&&tt.emit("flush")}function An(t){const e=t.id;if(null==$n[e]&&(t!==dt.target||!t.noRecurse)){if($n[e]=!0,Cn){let e=gn.length-1;for(;e>xn&&gn[e].id>t.id;)e--;gn.splice(e+1,0,t)}else gn.push(t);wn||(wn=!0,Be(jn))}}function Tn(t,e){if(t){const n=Object.create(null),o=nt?Reflect.ownKeys(t):Object.keys(t);for(let r=0;r<o.length;r++){const s=o[r];if("__ob__"===s)continue;const c=t[s].from;if(c in e._provided)n[s]=e._provided[c];else if("default"in t[s]){const o=t[s].default;n[s]=i(o)?o.call(e):o}}return n}}function En(n,o,s,i,c){const a=c.options;let l;y(i,"_uid")?(l=Object.create(i),l._original=i):(l=i,i=i._original);const u=r(a._compiled),f=!u;this.data=n,this.props=o,this.children=s,this.parent=i,this.listeners=n.on||t,this.injections=Tn(a.inject,i),this.slots=()=>(this.$slots||ge(i,n.scopedSlots,this.$slots=_e(s,i)),this.$slots),Object.defineProperty(this,"scopedSlots",{enumerable:!0,get(){return ge(i,n.scopedSlots,this.slots())}}),u&&(this.$options=a,this.$slots=this.slots(),this.$scopedSlots=ge(i,n.scopedSlots,this.$slots)),a._scopeId?this._c=(t,n,o,r)=>{const s=Te(l,t,n,o,r,f);return s&&!e(s)&&(s.fnScopeId=a._scopeId,s.fnContext=i),s}:this._c=(t,e,n,o)=>Te(l,t,e,n,o,f)}function Pn(t,e,n,o,r){const s=lt(t);return s.fnContext=n,s.fnOptions=o,e.slot&&((s.data||(s.data={})).slot=e.slot),s}function In(t,e){for(const n in e)t[$(n)]=e[n]}function Dn(t){return t.name||t.__name||t._componentTag}me(En.prototype);const Nn={init(t,e){if(t.componentInstance&&!t.componentInstance._isDestroyed&&t.data.keepAlive){const e=t;Nn.prepatch(e,e)}else{(t.componentInstance=function(t,e){const n={_isComponent:!0,_parentVnode:t,parent:e},r=t.data.inlineTemplate;o(r)&&(n.render=r.render,n.staticRenderFns=r.staticRenderFns);return new t.componentOptions.Ctor(n)}(t,pn)).$mount(e?t.elm:void 0,e)}},prepatch(e,n){const o=n.componentOptions;!function(e,n,o,r,s){const i=r.data.scopedSlots,c=e.$scopedSlots,a=!!(i&&!i.$stable||c!==t&&!c.$stable||i&&e.$scopedSlots.$key!==i.$key||!i&&e.$scopedSlots.$key);let l=!!(s||e.$options._renderChildren||a);const u=e.$vnode;e.$options._parentVnode=r,e.$vnode=r,e._vnode&&(e._vnode.parent=r),e.$options._renderChildren=s;const f=r.data.attrs||t;e._attrsProxy&&Ce(e._attrsProxy,f,u.data&&u.data.attrs||t,e,"$attrs")&&(l=!0),e.$attrs=f,o=o||t;const d=e.$options._parentListeners;if(e._listenersProxy&&Ce(e._listenersProxy,o,d||t,e,"$listeners"),e.$listeners=e.$options._parentListeners=o,dn(e,o,d),n&&e.$options.props){$t(!1);const t=e._props,o=e.$options._propKeys||[];for(let r=0;r<o.length;r++){const s=o[r],i=e.$options.props;t[s]=Gn(s,i,n,e)}$t(!0),e.$options.propsData=n}l&&(e.$slots=_e(s,r.context),e.$forceUpdate())}(n.componentInstance=e.componentInstance,o.propsData,o.listeners,n,o.children)},insert(t){const{context:e,componentInstance:n}=t;var o;n._isMounted||(n._isMounted=!0,yn(n,"mounted")),t.data.keepAlive&&(e._isMounted?((o=n)._inactive=!1,bn.push(o)):_n(n,!0))},destroy(t){const{componentInstance:e}=t;e._isDestroyed||(t.data.keepAlive?vn(e,!0):e.$destroy())}},Mn=Object.keys(Nn);function Rn(s,i,a,l,u){if(n(s))return;const d=a.$options._base;if(c(s)&&(s=d.extend(s)),"function"!=typeof s)return;let p;if(n(s.cid)&&(p=s,s=function(t,e){if(r(t.error)&&o(t.errorComp))return t.errorComp;if(o(t.resolved))return t.resolved;const s=Se;if(s&&o(t.owners)&&-1===t.owners.indexOf(s)&&t.owners.push(s),r(t.loading)&&o(t.loadingComp))return t.loadingComp;if(s&&!o(t.owners)){const r=t.owners=[s];let i=!0,a=null,l=null;s.$on("hook:destroyed",(()=>_(r,s)));const u=t=>{for(let t=0,e=r.length;t<e;t++)r[t].$forceUpdate();t&&(r.length=0,null!==a&&(clearTimeout(a),a=null),null!==l&&(clearTimeout(l),l=null))},d=D((n=>{t.resolved=je(n,e),i?r.length=0:u(!0)})),p=D((e=>{o(t.errorComp)&&(t.error=!0,u(!0))})),h=t(d,p);return c(h)&&(f(h)?n(t.resolved)&&h.then(d,p):f(h.component)&&(h.component.then(d,p),o(h.error)&&(t.errorComp=je(h.error,e)),o(h.loading)&&(t.loadingComp=je(h.loading,e),0===h.delay?t.loading=!0:a=setTimeout((()=>{a=null,n(t.resolved)&&n(t.error)&&(t.loading=!0,u(!1))}),h.delay||200)),o(h.timeout)&&(l=setTimeout((()=>{l=null,n(t.resolved)&&p(null)}),h.timeout)))),i=!1,t.loading?t.loadingComp:t.resolved}}(p,d),void 0===s))return function(t,e,n,o,r){const s=ct();return s.asyncFactory=t,s.asyncMeta={data:e,context:n,children:o,tag:r},s}(p,i,a,l,u);i=i||{},ao(s),o(i.model)&&function(t,n){const r=t.model&&t.model.prop||"value",s=t.model&&t.model.event||"input";(n.attrs||(n.attrs={}))[r]=n.model.value;const i=n.on||(n.on={}),c=i[s],a=n.model.callback;o(c)?(e(c)?-1===c.indexOf(a):c!==a)&&(i[s]=[a].concat(c)):i[s]=a}(s.options,i);const h=function(t,e,r){const s=e.options.props;if(n(s))return;const i={},{attrs:c,props:a}=t;if(o(c)||o(a))for(const t in s){const e=x(t);Xt(i,a,t,e,!0)||Xt(i,c,t,e,!1)}return i}(i,s);if(r(s.options.functional))return function(n,r,s,i,c){const a=n.options,l={},u=a.props;if(o(u))for(const e in u)l[e]=Gn(e,u,r||t);else o(s.attrs)&&In(l,s.attrs),o(s.props)&&In(l,s.props);const f=new En(s,l,c,i,n),d=a.render.call(null,f._c,f);if(d instanceof it)return Pn(d,s,f.parent,a);if(e(d)){const t=Qt(d)||[],e=new Array(t.length);for(let n=0;n<t.length;n++)e[n]=Pn(t[n],s,f.parent,a);return e}}(s,h,i,a,l);const m=i.on;if(i.on=i.nativeOn,r(s.options.abstract)){const t=i.slot;i={},t&&(i.slot=t)}!function(t){const e=t.hook||(t.hook={});for(let t=0;t<Mn.length;t++){const n=Mn[t],o=e[n],r=Nn[n];o===r||o&&o._merged||(e[n]=o?Ln(r,o):r)}}(i);const v=Dn(s.options)||u;return new it(`vue-component-${s.cid}${v?`-${v}`:""}`,i,void 0,void 0,void 0,a,{Ctor:s,propsData:h,listeners:m,tag:u,children:l},p)}function Ln(t,e){const n=(n,o)=>{t(n,o),e(n,o)};return n._merged=!0,n}let Fn=A;const Un=L.optionMergeStrategies;function Bn(t,e,n=!0){if(!e)return t;let o,r,s;const i=nt?Reflect.ownKeys(e):Object.keys(e);for(let c=0;c<i.length;c++)o=i[c],"__ob__"!==o&&(r=t[o],s=e[o],n&&y(t,o)?r!==s&&l(r)&&l(s)&&Bn(r,s):Ot(t,o,s));return t}function Vn(t,e,n){return n?function(){const o=i(e)?e.call(n,n):e,r=i(t)?t.call(n,n):t;return o?Bn(o,r):r}:e?t?function(){return Bn(i(e)?e.call(this,this):e,i(t)?t.call(this,this):t)}:e:t}function zn(t,n){const o=n?t?t.concat(n):e(n)?n:[n]:t;return o?function(t){const e=[];for(let n=0;n<t.length;n++)-1===e.indexOf(t[n])&&e.push(t[n]);return e}(o):o}function Hn(t,e,n,o){const r=Object.create(t||null);return e?S(r,e):r}Un.data=function(t,e,n){return n?Vn(t,e,n):e&&"function"!=typeof e?t:Vn(t,e)},R.forEach((t=>{Un[t]=zn})),M.forEach((function(t){Un[t+"s"]=Hn})),Un.watch=function(t,n,o,r){if(t===J&&(t=void 0),n===J&&(n=void 0),!n)return Object.create(t||null);if(!t)return n;const s={};S(s,t);for(const t in n){let o=s[t];const r=n[t];o&&!e(o)&&(o=[o]),s[t]=o?o.concat(r):e(r)?r:[r]}return s},Un.props=Un.methods=Un.inject=Un.computed=function(t,e,n,o){if(!t)return e;const r=Object.create(null);return S(r,t),e&&S(r,e),r},Un.provide=function(t,e){return t?function(){const n=Object.create(null);return Bn(n,i(t)?t.call(this):t),e&&Bn(n,i(e)?e.call(this):e,!1),n}:e};const Wn=function(t,e){return void 0===e?t:e};function Kn(t,n,o){if(i(n)&&(n=n.options),function(t,n){const o=t.props;if(!o)return;const r={};let s,i,c;if(e(o))for(s=o.length;s--;)i=o[s],"string"==typeof i&&(c=$(i),r[c]={type:null});else if(l(o))for(const t in o)i=o[t],c=$(t),r[c]=l(i)?i:{type:i};t.props=r}(n),function(t,n){const o=t.inject;if(!o)return;const r=t.inject={};if(e(o))for(let t=0;t<o.length;t++)r[o[t]]={from:o[t]};else if(l(o))for(const t in o){const e=o[t];r[t]=l(e)?S({from:t},e):{from:e}}}(n),function(t){const e=t.directives;if(e)for(const t in e){const n=e[t];i(n)&&(e[t]={bind:n,update:n})}}(n),!n._base&&(n.extends&&(t=Kn(t,n.extends,o)),n.mixins))for(let e=0,r=n.mixins.length;e<r;e++)t=Kn(t,n.mixins[e],o);const r={};let s;for(s in t)c(s);for(s in n)y(t,s)||c(s);function c(e){const s=Un[e]||Wn;r[e]=s(t[e],n[e],o,e)}return r}function qn(t,e,n,o){if("string"!=typeof n)return;const r=t[e];if(y(r,n))return r[n];const s=$(n);if(y(r,s))return r[s];const i=w(s);if(y(r,i))return r[i];return r[n]||r[s]||r[i]}function Gn(t,e,n,o){const r=e[t],s=!y(n,t);let c=n[t];const a=Qn(Boolean,r.type);if(a>-1)if(s&&!y(r,"default"))c=!1;else if(""===c||c===x(t)){const t=Qn(String,r.type);(t<0||a<t)&&(c=!0)}if(void 0===c){c=function(t,e,n){if(!y(e,"default"))return;const o=e.default;if(t&&t.$options.propsData&&void 0===t.$options.propsData[n]&&void 0!==t._props[n])return t._props[n];return i(o)&&"Function"!==Jn(e.type)?o.call(t):o}(o,r,t);const e=bt;$t(!0),xt(c),$t(e)}return c}const Zn=/^\s*function (\w+)/;function Jn(t){const e=t&&t.toString().match(Zn);return e?e[1]:""}function Xn(t,e){return Jn(t)===Jn(e)}function Qn(t,n){if(!e(n))return Xn(n,t)?0:-1;for(let e=0,o=n.length;e<o;e++)if(Xn(n[e],t))return e;return-1}const Yn={enumerable:!0,configurable:!0,get:A,set:A};function to(t,e,n){Yn.get=function(){return this[e][n]},Yn.set=function(t){this[e][n]=t},Object.defineProperty(t,n,Yn)}function eo(t){const n=t.$options;if(n.props&&function(t,e){const n=t.$options.propsData||{},o=t._props=At({}),r=t.$options._propKeys=[];t.$parent&&$t(!1);for(const s in e){r.push(s);kt(o,s,Gn(s,e,n,t)),s in t||to(t,"_props",s)}$t(!0)}(t,n.props),function(t){const e=t.$options,n=e.setup;if(n){const o=t._setupContext=we(t);st(t),ht();const r=Ie(n,null,[t._props||At({}),o],t,"setup");if(mt(),st(),i(r))e.render=r;else if(c(r))if(t._setupState=r,r.__sfc){const e=t._setupProxy={};for(const t in r)"__sfc"!==t&&Mt(e,r,t)}else for(const e in r)F(e)||Mt(t,r,e)}}(t),n.methods&&function(t,e){t.$options.props;for(const n in e)t[n]="function"!=typeof e[n]?A:k(e[n],t)}(t,n.methods),n.data)!function(t){let e=t.$options.data;e=t._data=i(e)?function(t,e){ht();try{return t.call(e,e)}catch(t){return Pe(t,e,"data()"),{}}finally{mt()}}(e,t):e||{},l(e)||(e={});const n=Object.keys(e),o=t.$options.props;t.$options.methods;let r=n.length;for(;r--;){const e=n[r];o&&y(o,e)||F(e)||to(t,"_data",e)}const s=xt(e);s&&s.vmCount++}(t);else{const e=xt(t._data={});e&&e.vmCount++}n.computed&&function(t,e){const n=t._computedWatchers=Object.create(null),o=Y();for(const r in e){const s=e[r],c=i(s)?s:s.get;o||(n[r]=new an(t,c||A,A,no)),r in t||oo(t,r,s)}}(t,n.computed),n.watch&&n.watch!==J&&function(t,n){for(const o in n){const r=n[o];if(e(r))for(let e=0;e<r.length;e++)io(t,o,r[e]);else io(t,o,r)}}(t,n.watch)}const no={lazy:!0};function oo(t,e,n){const o=!Y();i(n)?(Yn.get=o?ro(e):so(n),Yn.set=A):(Yn.get=n.get?o&&!1!==n.cache?ro(e):so(n.get):A,Yn.set=n.set||A),Object.defineProperty(t,e,Yn)}function ro(t){return function(){const e=this._computedWatchers&&this._computedWatchers[t];if(e)return e.dirty&&e.evaluate(),dt.target&&e.depend(),e.value}}function so(t){return function(){return t.call(this,this)}}function io(t,e,n,o){return l(n)&&(o=n,n=n.handler),"string"==typeof n&&(n=t[n]),t.$watch(e,n,o)}let co=0;function ao(t){let e=t.options;if(t.super){const n=ao(t.super);if(n!==t.superOptions){t.superOptions=n;const o=function(t){let e;const n=t.options,o=t.sealedOptions;for(const t in n)n[t]!==o[t]&&(e||(e={}),e[t]=n[t]);return e}(t);o&&S(t.extendOptions,o),e=t.options=Kn(n,t.extendOptions),e.name&&(e.components[e.name]=t)}}return e}function lo(t){this._init(t)}function uo(t){t.cid=0;let e=1;t.extend=function(t){t=t||{};const n=this,o=n.cid,r=t._Ctor||(t._Ctor={});if(r[o])return r[o];const s=Dn(t)||Dn(n.options),i=function(t){this._init(t)};return(i.prototype=Object.create(n.prototype)).constructor=i,i.cid=e++,i.options=Kn(n.options,t),i.super=n,i.options.props&&function(t){const e=t.options.props;for(const n in e)to(t.prototype,"_props",n)}(i),i.options.computed&&function(t){const e=t.options.computed;for(const n in e)oo(t.prototype,n,e[n])}(i),i.extend=n.extend,i.mixin=n.mixin,i.use=n.use,M.forEach((function(t){i[t]=n[t]})),s&&(i.options.components[s]=i),i.superOptions=n.options,i.extendOptions=t,i.sealedOptions=S({},i.options),r[o]=i,i}}function fo(t){return t&&(Dn(t.Ctor.options)||t.tag)}function po(t,n){return e(t)?t.indexOf(n)>-1:"string"==typeof t?t.split(",").indexOf(n)>-1:(o=t,"[object RegExp]"===a.call(o)&&t.test(n));var o}function ho(t,e){const{cache:n,keys:o,_vnode:r}=t;for(const t in n){const s=n[t];if(s){const i=s.name;i&&!e(i)&&mo(n,t,o,r)}}}function mo(t,e,n,o){const r=t[e];!r||o&&r.tag===o.tag||r.componentInstance.$destroy(),t[e]=null,_(n,e)}!function(e){e.prototype._init=function(e){const n=this;n._uid=co++,n._isVue=!0,n.__v_skip=!0,n._scope=new Wt(!0),n._scope._vm=!0,e&&e._isComponent?function(t,e){const n=t.$options=Object.create(t.constructor.options),o=e._parentVnode;n.parent=e.parent,n._parentVnode=o;const r=o.componentOptions;n.propsData=r.propsData,n._parentListeners=r.listeners,n._renderChildren=r.children,n._componentTag=r.tag,e.render&&(n.render=e.render,n.staticRenderFns=e.staticRenderFns)}(n,e):n.$options=Kn(ao(n.constructor),e||{},n),n._renderProxy=n,n._self=n,function(t){const e=t.$options;let n=e.parent;if(n&&!e.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(t)}t.$parent=n,t.$root=n?n.$root:t,t.$children=[],t.$refs={},t._provided=n?n._provided:Object.create(null),t._watcher=null,t._inactive=null,t._directInactive=!1,t._isMounted=!1,t._isDestroyed=!1,t._isBeingDestroyed=!1}(n),function(t){t._events=Object.create(null),t._hasHookEvent=!1;const e=t.$options._parentListeners;e&&dn(t,e)}(n),function(e){e._vnode=null,e._staticTrees=null;const n=e.$options,o=e.$vnode=n._parentVnode,r=o&&o.context;e.$slots=_e(n._renderChildren,r),e.$scopedSlots=o?ge(e.$parent,o.data.scopedSlots,e.$slots):t,e._c=(t,n,o,r)=>Te(e,t,n,o,r,!1),e.$createElement=(t,n,o,r)=>Te(e,t,n,o,r,!0);const s=o&&o.data;kt(e,"$attrs",s&&s.attrs||t,null,!0),kt(e,"$listeners",n._parentListeners||t,null,!0)}(n),yn(n,"beforeCreate",void 0,!1),function(t){const e=Tn(t.$options.inject,t);e&&($t(!1),Object.keys(e).forEach((n=>{kt(t,n,e[n])})),$t(!0))}(n),eo(n),function(t){const e=t.$options.provide;if(e){const n=i(e)?e.call(t):e;if(!c(n))return;const o=Kt(t),r=nt?Reflect.ownKeys(n):Object.keys(n);for(let t=0;t<r.length;t++){const e=r[t];Object.defineProperty(o,e,Object.getOwnPropertyDescriptor(n,e))}}}(n),yn(n,"created"),n.$options.el&&n.$mount(n.$options.el)}}(lo),function(t){const e={get:function(){return this._data}},n={get:function(){return this._props}};Object.defineProperty(t.prototype,"$data",e),Object.defineProperty(t.prototype,"$props",n),t.prototype.$set=Ot,t.prototype.$delete=St,t.prototype.$watch=function(t,e,n){const o=this;if(l(e))return io(o,t,e,n);(n=n||{}).user=!0;const r=new an(o,t,e,n);if(n.immediate){const t=`callback for immediate watcher "${r.expression}"`;ht(),Ie(e,o,[r.value],o,t),mt()}return function(){r.teardown()}}}(lo),function(t){const n=/^hook:/;t.prototype.$on=function(t,o){const r=this;if(e(t))for(let e=0,n=t.length;e<n;e++)r.$on(t[e],o);else(r._events[t]||(r._events[t]=[])).push(o),n.test(t)&&(r._hasHookEvent=!0);return r},t.prototype.$once=function(t,e){const n=this;function o(){n.$off(t,o),e.apply(n,arguments)}return o.fn=e,n.$on(t,o),n},t.prototype.$off=function(t,n){const o=this;if(!arguments.length)return o._events=Object.create(null),o;if(e(t)){for(let e=0,r=t.length;e<r;e++)o.$off(t[e],n);return o}const r=o._events[t];if(!r)return o;if(!n)return o._events[t]=null,o;let s,i=r.length;for(;i--;)if(s=r[i],s===n||s.fn===n){r.splice(i,1);break}return o},t.prototype.$emit=function(t){const e=this;let n=e._events[t];if(n){n=n.length>1?O(n):n;const o=O(arguments,1),r=`event handler for "${t}"`;for(let t=0,s=n.length;t<s;t++)Ie(n[t],e,o,e,r)}return e}}(lo),function(t){t.prototype._update=function(t,e){const n=this,o=n.$el,r=n._vnode,s=hn(n);n._vnode=t,n.$el=r?n.__patch__(r,t):n.__patch__(n.$el,t,e,!1),s(),o&&(o.__vue__=null),n.$el&&(n.$el.__vue__=n);let i=n;for(;i&&i.$vnode&&i.$parent&&i.$vnode===i.$parent._vnode;)i.$parent.$el=i.$el,i=i.$parent},t.prototype.$forceUpdate=function(){const t=this;t._watcher&&t._watcher.update()},t.prototype.$destroy=function(){const t=this;if(t._isBeingDestroyed)return;yn(t,"beforeDestroy"),t._isBeingDestroyed=!0;const e=t.$parent;!e||e._isBeingDestroyed||t.$options.abstract||_(e.$children,t),t._scope.stop(),t._data.__ob__&&t._data.__ob__.vmCount--,t._isDestroyed=!0,t.__patch__(t._vnode,null),yn(t,"destroyed"),t.$off(),t.$el&&(t.$el.__vue__=null),t.$vnode&&(t.$vnode.parent=null)}}(lo),function(t){me(t.prototype),t.prototype.$nextTick=function(t){return Be(t,this)},t.prototype._render=function(){const t=this,{render:n,_parentVnode:o}=t.$options;let r;o&&t._isMounted&&(t.$scopedSlots=ge(t.$parent,o.data.scopedSlots,t.$slots,t.$scopedSlots),t._slotsProxy&&ke(t._slotsProxy,t.$scopedSlots)),t.$vnode=o;try{st(t),Se=t,r=n.call(t._renderProxy,t.$createElement)}catch(e){Pe(e,t,"render"),r=t._vnode}finally{Se=null,st()}return e(r)&&1===r.length&&(r=r[0]),r instanceof it||(r=ct()),r.parent=o,r}}(lo);const _o=[String,RegExp,Array];var vo={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:_o,exclude:_o,max:[String,Number]},methods:{cacheVNode(){const{cache:t,keys:e,vnodeToCache:n,keyToCache:o}=this;if(n){const{tag:r,componentInstance:s,componentOptions:i}=n;t[o]={name:fo(i),tag:r,componentInstance:s},e.push(o),this.max&&e.length>parseInt(this.max)&&mo(t,e[0],e,this._vnode),this.vnodeToCache=null}}},created(){this.cache=Object.create(null),this.keys=[]},destroyed(){for(const t in this.cache)mo(this.cache,t,this.keys)},mounted(){this.cacheVNode(),this.$watch("include",(t=>{ho(this,(e=>po(t,e)))})),this.$watch("exclude",(t=>{ho(this,(e=>!po(t,e)))}))},updated(){this.cacheVNode()},render(){const t=this.$slots.default,e=Ae(t),n=e&&e.componentOptions;if(n){const t=fo(n),{include:o,exclude:r}=this;if(o&&(!t||!po(o,t))||r&&t&&po(r,t))return e;const{cache:s,keys:i}=this,c=null==e.key?n.Ctor.cid+(n.tag?`::${n.tag}`:""):e.key;s[c]?(e.componentInstance=s[c].componentInstance,_(i,c),i.push(c)):(this.vnodeToCache=e,this.keyToCache=c),e.data.keepAlive=!0}return e||t&&t[0]}}};!function(t){const e={get:()=>L};Object.defineProperty(t,"config",e),t.util={warn:Fn,extend:S,mergeOptions:Kn,defineReactive:kt},t.set=Ot,t.delete=St,t.nextTick=Be,t.observable=t=>(xt(t),t),t.options=Object.create(null),M.forEach((e=>{t.options[e+"s"]=Object.create(null)})),t.options._base=t,S(t.options.components,vo),function(t){t.use=function(t){const e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(t)>-1)return this;const n=O(arguments,1);return n.unshift(this),i(t.install)?t.install.apply(t,n):i(t)&&t.apply(null,n),e.push(t),this}}(t),function(t){t.mixin=function(t){return this.options=Kn(this.options,t),this}}(t),uo(t),function(t){M.forEach((e=>{t[e]=function(t,n){return n?("component"===e&&l(n)&&(n.name=n.name||t,n=this.options._base.extend(n)),"directive"===e&&i(n)&&(n={bind:n,update:n}),this.options[e+"s"][t]=n,n):this.options[e+"s"][t]}}))}(t)}(lo),Object.defineProperty(lo.prototype,"$isServer",{get:Y}),Object.defineProperty(lo.prototype,"$ssrContext",{get(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(lo,"FunctionalRenderContext",{value:En}),lo.version="2.7.14";const yo=h("style,class"),go=h("input,textarea,option,select,progress"),bo=h("contenteditable,draggable,spellcheck"),$o=h("events,caret,typing,plaintext-only"),wo=h("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Co="http://www.w3.org/1999/xlink",xo=t=>":"===t.charAt(5)&&"xlink"===t.slice(0,5),ko=t=>xo(t)?t.slice(6,t.length):"",Oo=t=>null==t||!1===t;function So(t){let e=t.data,n=t,r=t;for(;o(r.componentInstance);)r=r.componentInstance._vnode,r&&r.data&&(e=jo(r.data,e));for(;o(n=n.parent);)n&&n.data&&(e=jo(e,n.data));return function(t,e){if(o(t)||o(e))return Ao(t,To(e));return""}(e.staticClass,e.class)}function jo(t,e){return{staticClass:Ao(t.staticClass,e.staticClass),class:o(t.class)?[t.class,e.class]:e.class}}function Ao(t,e){return t?e?t+" "+e:t:e||""}function To(t){return Array.isArray(t)?function(t){let e,n="";for(let r=0,s=t.length;r<s;r++)o(e=To(t[r]))&&""!==e&&(n&&(n+=" "),n+=e);return n}(t):c(t)?function(t){let e="";for(const n in t)t[n]&&(e&&(e+=" "),e+=n);return e}(t):"string"==typeof t?t:""}const Eo={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Po=h("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Io=h("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Do=t=>Po(t)||Io(t);const No=Object.create(null);const Mo=h("text,number,password,search,email,tel,url");var Ro=Object.freeze({__proto__:null,createElement:function(t,e){const n=document.createElement(t);return"select"!==t||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n},createElementNS:function(t,e){return document.createElementNS(Eo[t],e)},createTextNode:function(t){return document.createTextNode(t)},createComment:function(t){return document.createComment(t)},insertBefore:function(t,e,n){t.insertBefore(e,n)},removeChild:function(t,e){t.removeChild(e)},appendChild:function(t,e){t.appendChild(e)},parentNode:function(t){return t.parentNode},nextSibling:function(t){return t.nextSibling},tagName:function(t){return t.tagName},setTextContent:function(t,e){t.textContent=e},setStyleScope:function(t,e){t.setAttribute(e,"")}}),Lo={create(t,e){Fo(e)},update(t,e){t.data.ref!==e.data.ref&&(Fo(t,!0),Fo(e))},destroy(t){Fo(t,!0)}};function Fo(t,n){const r=t.data.ref;if(!o(r))return;const s=t.context,c=t.componentInstance||t.elm,a=n?null:c,l=n?void 0:c;if(i(r))return void Ie(r,s,[a],s,"template ref function");const u=t.data.refInFor,f="string"==typeof r||"number"==typeof r,d=Dt(r),p=s.$refs;if(f||d)if(u){const t=f?p[r]:r.value;n?e(t)&&_(t,c):e(t)?t.includes(c)||t.push(c):f?(p[r]=[c],Uo(s,r,p[r])):r.value=[c]}else if(f){if(n&&p[r]!==c)return;p[r]=l,Uo(s,r,a)}else if(d){if(n&&r.value!==c)return;r.value=a}}function Uo({_setupState:t},e,n){t&&y(t,e)&&(Dt(t[e])?t[e].value=n:t[e]=n)}const Bo=new it("",{},[]),Vo=["create","activate","update","remove","destroy"];function zo(t,e){return t.key===e.key&&t.asyncFactory===e.asyncFactory&&(t.tag===e.tag&&t.isComment===e.isComment&&o(t.data)===o(e.data)&&function(t,e){if("input"!==t.tag)return!0;let n;const r=o(n=t.data)&&o(n=n.attrs)&&n.type,s=o(n=e.data)&&o(n=n.attrs)&&n.type;return r===s||Mo(r)&&Mo(s)}(t,e)||r(t.isAsyncPlaceholder)&&n(e.asyncFactory.error))}function Ho(t,e,n){let r,s;const i={};for(r=e;r<=n;++r)s=t[r].key,o(s)&&(i[s]=r);return i}var Wo={create:Ko,update:Ko,destroy:function(t){Ko(t,Bo)}};function Ko(t,e){(t.data.directives||e.data.directives)&&function(t,e){const n=t===Bo,o=e===Bo,r=Go(t.data.directives,t.context),s=Go(e.data.directives,e.context),i=[],c=[];let a,l,u;for(a in s)l=r[a],u=s[a],l?(u.oldValue=l.value,u.oldArg=l.arg,Jo(u,"update",e,t),u.def&&u.def.componentUpdated&&c.push(u)):(Jo(u,"bind",e,t),u.def&&u.def.inserted&&i.push(u));if(i.length){const o=()=>{for(let n=0;n<i.length;n++)Jo(i[n],"inserted",e,t)};n?Jt(e,"insert",o):o()}c.length&&Jt(e,"postpatch",(()=>{for(let n=0;n<c.length;n++)Jo(c[n],"componentUpdated",e,t)}));if(!n)for(a in r)s[a]||Jo(r[a],"unbind",t,t,o)}(t,e)}const qo=Object.create(null);function Go(t,e){const n=Object.create(null);if(!t)return n;let o,r;for(o=0;o<t.length;o++){if(r=t[o],r.modifiers||(r.modifiers=qo),n[Zo(r)]=r,e._setupState&&e._setupState.__sfc){const t=r.def||qn(e,"_setupState","v-"+r.name);r.def="function"==typeof t?{bind:t,update:t}:t}r.def=r.def||qn(e.$options,"directives",r.name)}return n}function Zo(t){return t.rawName||`${t.name}.${Object.keys(t.modifiers||{}).join(".")}`}function Jo(t,e,n,o,r){const s=t.def&&t.def[e];if(s)try{s(n.elm,t,n,o,r)}catch(o){Pe(o,n.context,`directive ${t.name} ${e} hook`)}}var Xo=[Lo,Wo];function Qo(t,e){const s=e.componentOptions;if(o(s)&&!1===s.Ctor.options.inheritAttrs)return;if(n(t.data.attrs)&&n(e.data.attrs))return;let i,c,a;const l=e.elm,u=t.data.attrs||{};let f=e.data.attrs||{};for(i in(o(f.__ob__)||r(f._v_attr_proxy))&&(f=e.data.attrs=S({},f)),f)c=f[i],a=u[i],a!==c&&Yo(l,i,c,e.data.pre);for(i in(W||q)&&f.value!==u.value&&Yo(l,"value",f.value),u)n(f[i])&&(xo(i)?l.removeAttributeNS(Co,ko(i)):bo(i)||l.removeAttribute(i))}function Yo(t,e,n,o){o||t.tagName.indexOf("-")>-1?tr(t,e,n):wo(e)?Oo(n)?t.removeAttribute(e):(n="allowfullscreen"===e&&"EMBED"===t.tagName?"true":e,t.setAttribute(e,n)):bo(e)?t.setAttribute(e,((t,e)=>Oo(e)||"false"===e?"false":"contenteditable"===t&&$o(e)?e:"true")(e,n)):xo(e)?Oo(n)?t.removeAttributeNS(Co,ko(e)):t.setAttributeNS(Co,e,n):tr(t,e,n)}function tr(t,e,n){if(Oo(n))t.removeAttribute(e);else{if(W&&!K&&"TEXTAREA"===t.tagName&&"placeholder"===e&&""!==n&&!t.__ieph){const e=n=>{n.stopImmediatePropagation(),t.removeEventListener("input",e)};t.addEventListener("input",e),t.__ieph=!0}t.setAttribute(e,n)}}var er={create:Qo,update:Qo};function nr(t,e){const r=e.elm,s=e.data,i=t.data;if(n(s.staticClass)&&n(s.class)&&(n(i)||n(i.staticClass)&&n(i.class)))return;let c=So(e);const a=r._transitionClasses;o(a)&&(c=Ao(c,To(a))),c!==r._prevClass&&(r.setAttribute("class",c),r._prevClass=c)}var or={create:nr,update:nr};let rr;function sr(t,e,n){const o=rr;return function r(){const s=e.apply(null,arguments);null!==s&&ar(t,r,n,o)}}const ir=Me&&!(Z&&Number(Z[1])<=53);function cr(t,e,n,o){if(ir){const t=kn,n=e;e=n._wrapper=function(e){if(e.target===e.currentTarget||e.timeStamp>=t||e.timeStamp<=0||e.target.ownerDocument!==document)return n.apply(this,arguments)}}rr.addEventListener(t,e,Q?{capture:n,passive:o}:n)}function ar(t,e,n,o){(o||rr).removeEventListener(t,e._wrapper||e,n)}function lr(t,e){if(n(t.data.on)&&n(e.data.on))return;const r=e.data.on||{},s=t.data.on||{};rr=e.elm||t.elm,function(t){if(o(t.__r)){const e=W?"change":"input";t[e]=[].concat(t.__r,t[e]||[]),delete t.__r}o(t.__c)&&(t.change=[].concat(t.__c,t.change||[]),delete t.__c)}(r),Zt(r,s,cr,ar,sr,e.context),rr=void 0}var ur={create:lr,update:lr,destroy:t=>lr(t,Bo)};let fr;function dr(t,e){if(n(t.data.domProps)&&n(e.data.domProps))return;let s,i;const c=e.elm,a=t.data.domProps||{};let l=e.data.domProps||{};for(s in(o(l.__ob__)||r(l._v_attr_proxy))&&(l=e.data.domProps=S({},l)),a)s in l||(c[s]="");for(s in l){if(i=l[s],"textContent"===s||"innerHTML"===s){if(e.children&&(e.children.length=0),i===a[s])continue;1===c.childNodes.length&&c.removeChild(c.childNodes[0])}if("value"===s&&"PROGRESS"!==c.tagName){c._value=i;const t=n(i)?"":String(i);pr(c,t)&&(c.value=t)}else if("innerHTML"===s&&Io(c.tagName)&&n(c.innerHTML)){fr=fr||document.createElement("div"),fr.innerHTML=`<svg>${i}</svg>`;const t=fr.firstChild;for(;c.firstChild;)c.removeChild(c.firstChild);for(;t.firstChild;)c.appendChild(t.firstChild)}else if(i!==a[s])try{c[s]=i}catch(t){}}}function pr(t,e){return!t.composing&&("OPTION"===t.tagName||function(t,e){let n=!0;try{n=document.activeElement!==t}catch(t){}return n&&t.value!==e}(t,e)||function(t,e){const n=t.value,r=t._vModifiers;if(o(r)){if(r.number)return p(n)!==p(e);if(r.trim)return n.trim()!==e.trim()}return n!==e}(t,e))}var hr={create:dr,update:dr};const mr=g((function(t){const e={},n=/:(.+)/;return t.split(/;(?![^(]*\))/g).forEach((function(t){if(t){const o=t.split(n);o.length>1&&(e[o[0].trim()]=o[1].trim())}})),e}));function _r(t){const e=vr(t.style);return t.staticStyle?S(t.staticStyle,e):e}function vr(t){return Array.isArray(t)?j(t):"string"==typeof t?mr(t):t}const yr=/^--/,gr=/\s*!important$/,br=(t,e,n)=>{if(yr.test(e))t.style.setProperty(e,n);else if(gr.test(n))t.style.setProperty(x(e),n.replace(gr,""),"important");else{const o=Cr(e);if(Array.isArray(n))for(let e=0,r=n.length;e<r;e++)t.style[o]=n[e];else t.style[o]=n}},$r=["Webkit","Moz","ms"];let wr;const Cr=g((function(t){if(wr=wr||document.createElement("div").style,"filter"!==(t=$(t))&&t in wr)return t;const e=t.charAt(0).toUpperCase()+t.slice(1);for(let t=0;t<$r.length;t++){const n=$r[t]+e;if(n in wr)return n}}));function xr(t,e){const r=e.data,s=t.data;if(n(r.staticStyle)&&n(r.style)&&n(s.staticStyle)&&n(s.style))return;let i,c;const a=e.elm,l=s.staticStyle,u=s.normalizedStyle||s.style||{},f=l||u,d=vr(e.data.style)||{};e.data.normalizedStyle=o(d.__ob__)?S({},d):d;const p=function(t,e){const n={};let o;if(e){let e=t;for(;e.componentInstance;)e=e.componentInstance._vnode,e&&e.data&&(o=_r(e.data))&&S(n,o)}(o=_r(t.data))&&S(n,o);let r=t;for(;r=r.parent;)r.data&&(o=_r(r.data))&&S(n,o);return n}(e,!0);for(c in f)n(p[c])&&br(a,c,"");for(c in p)i=p[c],i!==f[c]&&br(a,c,null==i?"":i)}var kr={create:xr,update:xr};const Or=/\s+/;function Sr(t,e){if(e&&(e=e.trim()))if(t.classList)e.indexOf(" ")>-1?e.split(Or).forEach((e=>t.classList.add(e))):t.classList.add(e);else{const n=` ${t.getAttribute("class")||""} `;n.indexOf(" "+e+" ")<0&&t.setAttribute("class",(n+e).trim())}}function jr(t,e){if(e&&(e=e.trim()))if(t.classList)e.indexOf(" ")>-1?e.split(Or).forEach((e=>t.classList.remove(e))):t.classList.remove(e),t.classList.length||t.removeAttribute("class");else{let n=` ${t.getAttribute("class")||""} `;const o=" "+e+" ";for(;n.indexOf(o)>=0;)n=n.replace(o," ");n=n.trim(),n?t.setAttribute("class",n):t.removeAttribute("class")}}function Ar(t){if(t){if("object"==typeof t){const e={};return!1!==t.css&&S(e,Tr(t.name||"v")),S(e,t),e}return"string"==typeof t?Tr(t):void 0}}const Tr=g((t=>({enterClass:`${t}-enter`,enterToClass:`${t}-enter-to`,enterActiveClass:`${t}-enter-active`,leaveClass:`${t}-leave`,leaveToClass:`${t}-leave-to`,leaveActiveClass:`${t}-leave-active`}))),Er=z&&!K;let Pr="transition",Ir="transitionend",Dr="animation",Nr="animationend";Er&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Pr="WebkitTransition",Ir="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Dr="WebkitAnimation",Nr="webkitAnimationEnd"));const Mr=z?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:t=>t();function Rr(t){Mr((()=>{Mr(t)}))}function Lr(t,e){const n=t._transitionClasses||(t._transitionClasses=[]);n.indexOf(e)<0&&(n.push(e),Sr(t,e))}function Fr(t,e){t._transitionClasses&&_(t._transitionClasses,e),jr(t,e)}function Ur(t,e,n){const{type:o,timeout:r,propCount:s}=Vr(t,e);if(!o)return n();const i="transition"===o?Ir:Nr;let c=0;const a=()=>{t.removeEventListener(i,l),n()},l=e=>{e.target===t&&++c>=s&&a()};setTimeout((()=>{c<s&&a()}),r+1),t.addEventListener(i,l)}const Br=/\b(transform|all)(,|$)/;function Vr(t,e){const n=window.getComputedStyle(t),o=(n[Pr+"Delay"]||"").split(", "),r=(n[Pr+"Duration"]||"").split(", "),s=zr(o,r),i=(n[Dr+"Delay"]||"").split(", "),c=(n[Dr+"Duration"]||"").split(", "),a=zr(i,c);let l,u=0,f=0;"transition"===e?s>0&&(l="transition",u=s,f=r.length):"animation"===e?a>0&&(l="animation",u=a,f=c.length):(u=Math.max(s,a),l=u>0?s>a?"transition":"animation":null,f=l?"transition"===l?r.length:c.length:0);return{type:l,timeout:u,propCount:f,hasTransform:"transition"===l&&Br.test(n[Pr+"Property"])}}function zr(t,e){for(;t.length<e.length;)t=t.concat(t);return Math.max.apply(null,e.map(((e,n)=>Hr(e)+Hr(t[n]))))}function Hr(t){return 1e3*Number(t.slice(0,-1).replace(",","."))}function Wr(t,e){const r=t.elm;o(r._leaveCb)&&(r._leaveCb.cancelled=!0,r._leaveCb());const s=Ar(t.data.transition);if(n(s))return;if(o(r._enterCb)||1!==r.nodeType)return;const{css:a,type:l,enterClass:u,enterToClass:f,enterActiveClass:d,appearClass:h,appearToClass:m,appearActiveClass:_,beforeEnter:v,enter:y,afterEnter:g,enterCancelled:b,beforeAppear:$,appear:w,afterAppear:C,appearCancelled:x,duration:k}=s;let O=pn,S=pn.$vnode;for(;S&&S.parent;)O=S.context,S=S.parent;const j=!O._isMounted||!t.isRootInsert;if(j&&!w&&""!==w)return;const A=j&&h?h:u,T=j&&_?_:d,E=j&&m?m:f,P=j&&$||v,I=j&&i(w)?w:y,N=j&&C||g,M=j&&x||b,R=p(c(k)?k.enter:k),L=!1!==a&&!K,F=Gr(I),U=r._enterCb=D((()=>{L&&(Fr(r,E),Fr(r,T)),U.cancelled?(L&&Fr(r,A),M&&M(r)):N&&N(r),r._enterCb=null}));t.data.show||Jt(t,"insert",(()=>{const e=r.parentNode,n=e&&e._pending&&e._pending[t.key];n&&n.tag===t.tag&&n.elm._leaveCb&&n.elm._leaveCb(),I&&I(r,U)})),P&&P(r),L&&(Lr(r,A),Lr(r,T),Rr((()=>{Fr(r,A),U.cancelled||(Lr(r,E),F||(qr(R)?setTimeout(U,R):Ur(r,l,U)))}))),t.data.show&&(e&&e(),I&&I(r,U)),L||F||U()}function Kr(t,e){const r=t.elm;o(r._enterCb)&&(r._enterCb.cancelled=!0,r._enterCb());const s=Ar(t.data.transition);if(n(s)||1!==r.nodeType)return e();if(o(r._leaveCb))return;const{css:i,type:a,leaveClass:l,leaveToClass:u,leaveActiveClass:f,beforeLeave:d,leave:h,afterLeave:m,leaveCancelled:_,delayLeave:v,duration:y}=s,g=!1!==i&&!K,b=Gr(h),$=p(c(y)?y.leave:y),w=r._leaveCb=D((()=>{r.parentNode&&r.parentNode._pending&&(r.parentNode._pending[t.key]=null),g&&(Fr(r,u),Fr(r,f)),w.cancelled?(g&&Fr(r,l),_&&_(r)):(e(),m&&m(r)),r._leaveCb=null}));function C(){w.cancelled||(!t.data.show&&r.parentNode&&((r.parentNode._pending||(r.parentNode._pending={}))[t.key]=t),d&&d(r),g&&(Lr(r,l),Lr(r,f),Rr((()=>{Fr(r,l),w.cancelled||(Lr(r,u),b||(qr($)?setTimeout(w,$):Ur(r,a,w)))}))),h&&h(r,w),g||b||w())}v?v(C):C()}function qr(t){return"number"==typeof t&&!isNaN(t)}function Gr(t){if(n(t))return!1;const e=t.fns;return o(e)?Gr(Array.isArray(e)?e[0]:e):(t._length||t.length)>1}function Zr(t,e){!0!==e.data.show&&Wr(e)}const Jr=function(t){let i,c;const a={},{modules:l,nodeOps:u}=t;for(i=0;i<Vo.length;++i)for(a[Vo[i]]=[],c=0;c<l.length;++c)o(l[c][Vo[i]])&&a[Vo[i]].push(l[c][Vo[i]]);function f(t){const e=u.parentNode(t);o(e)&&u.removeChild(e,t)}function d(t,e,n,s,i,c,l){if(o(t.elm)&&o(c)&&(t=c[l]=lt(t)),t.isRootInsert=!i,function(t,e,n,s){let i=t.data;if(o(i)){const c=o(t.componentInstance)&&i.keepAlive;if(o(i=i.hook)&&o(i=i.init)&&i(t,!1),o(t.componentInstance))return p(t,e),m(n,t.elm,s),r(c)&&function(t,e,n,r){let s,i=t;for(;i.componentInstance;)if(i=i.componentInstance._vnode,o(s=i.data)&&o(s=s.transition)){for(s=0;s<a.activate.length;++s)a.activate[s](Bo,i);e.push(i);break}m(n,t.elm,r)}(t,e,n,s),!0}}(t,e,n,s))return;const f=t.data,d=t.children,h=t.tag;o(h)?(t.elm=t.ns?u.createElementNS(t.ns,h):u.createElement(h,t),g(t),_(t,d,e),o(f)&&y(t,e),m(n,t.elm,s)):r(t.isComment)?(t.elm=u.createComment(t.text),m(n,t.elm,s)):(t.elm=u.createTextNode(t.text),m(n,t.elm,s))}function p(t,e){o(t.data.pendingInsert)&&(e.push.apply(e,t.data.pendingInsert),t.data.pendingInsert=null),t.elm=t.componentInstance.$el,v(t)?(y(t,e),g(t)):(Fo(t),e.push(t))}function m(t,e,n){o(t)&&(o(n)?u.parentNode(n)===t&&u.insertBefore(t,e,n):u.appendChild(t,e))}function _(t,n,o){if(e(n))for(let e=0;e<n.length;++e)d(n[e],o,t.elm,null,!0,n,e);else s(t.text)&&u.appendChild(t.elm,u.createTextNode(String(t.text)))}function v(t){for(;t.componentInstance;)t=t.componentInstance._vnode;return o(t.tag)}function y(t,e){for(let e=0;e<a.create.length;++e)a.create[e](Bo,t);i=t.data.hook,o(i)&&(o(i.create)&&i.create(Bo,t),o(i.insert)&&e.push(t))}function g(t){let e;if(o(e=t.fnScopeId))u.setStyleScope(t.elm,e);else{let n=t;for(;n;)o(e=n.context)&&o(e=e.$options._scopeId)&&u.setStyleScope(t.elm,e),n=n.parent}o(e=pn)&&e!==t.context&&e!==t.fnContext&&o(e=e.$options._scopeId)&&u.setStyleScope(t.elm,e)}function b(t,e,n,o,r,s){for(;o<=r;++o)d(n[o],s,t,e,!1,n,o)}function $(t){let e,n;const r=t.data;if(o(r))for(o(e=r.hook)&&o(e=e.destroy)&&e(t),e=0;e<a.destroy.length;++e)a.destroy[e](t);if(o(e=t.children))for(n=0;n<t.children.length;++n)$(t.children[n])}function w(t,e,n){for(;e<=n;++e){const n=t[e];o(n)&&(o(n.tag)?(C(n),$(n)):f(n.elm))}}function C(t,e){if(o(e)||o(t.data)){let n;const r=a.remove.length+1;for(o(e)?e.listeners+=r:e=function(t,e){function n(){0==--n.listeners&&f(t)}return n.listeners=e,n}(t.elm,r),o(n=t.componentInstance)&&o(n=n._vnode)&&o(n.data)&&C(n,e),n=0;n<a.remove.length;++n)a.remove[n](t,e);o(n=t.data.hook)&&o(n=n.remove)?n(t,e):e()}else f(t.elm)}function x(t,e,n,r){for(let s=n;s<r;s++){const n=e[s];if(o(n)&&zo(t,n))return s}}function k(t,e,s,i,c,l){if(t===e)return;o(e.elm)&&o(i)&&(e=i[c]=lt(e));const f=e.elm=t.elm;if(r(t.isAsyncPlaceholder))return void(o(e.asyncFactory.resolved)?j(t.elm,e,s):e.isAsyncPlaceholder=!0);if(r(e.isStatic)&&r(t.isStatic)&&e.key===t.key&&(r(e.isCloned)||r(e.isOnce)))return void(e.componentInstance=t.componentInstance);let p;const h=e.data;o(h)&&o(p=h.hook)&&o(p=p.prepatch)&&p(t,e);const m=t.children,_=e.children;if(o(h)&&v(e)){for(p=0;p<a.update.length;++p)a.update[p](t,e);o(p=h.hook)&&o(p=p.update)&&p(t,e)}n(e.text)?o(m)&&o(_)?m!==_&&function(t,e,r,s,i){let c,a,l,f,p=0,h=0,m=e.length-1,_=e[0],v=e[m],y=r.length-1,g=r[0],$=r[y];const C=!i;for(;p<=m&&h<=y;)n(_)?_=e[++p]:n(v)?v=e[--m]:zo(_,g)?(k(_,g,s,r,h),_=e[++p],g=r[++h]):zo(v,$)?(k(v,$,s,r,y),v=e[--m],$=r[--y]):zo(_,$)?(k(_,$,s,r,y),C&&u.insertBefore(t,_.elm,u.nextSibling(v.elm)),_=e[++p],$=r[--y]):zo(v,g)?(k(v,g,s,r,h),C&&u.insertBefore(t,v.elm,_.elm),v=e[--m],g=r[++h]):(n(c)&&(c=Ho(e,p,m)),a=o(g.key)?c[g.key]:x(g,e,p,m),n(a)?d(g,s,t,_.elm,!1,r,h):(l=e[a],zo(l,g)?(k(l,g,s,r,h),e[a]=void 0,C&&u.insertBefore(t,l.elm,_.elm)):d(g,s,t,_.elm,!1,r,h)),g=r[++h]);p>m?(f=n(r[y+1])?null:r[y+1].elm,b(t,f,r,h,y,s)):h>y&&w(e,p,m)}(f,m,_,s,l):o(_)?(o(t.text)&&u.setTextContent(f,""),b(f,null,_,0,_.length-1,s)):o(m)?w(m,0,m.length-1):o(t.text)&&u.setTextContent(f,""):t.text!==e.text&&u.setTextContent(f,e.text),o(h)&&o(p=h.hook)&&o(p=p.postpatch)&&p(t,e)}function O(t,e,n){if(r(n)&&o(t.parent))t.parent.data.pendingInsert=e;else for(let t=0;t<e.length;++t)e[t].data.hook.insert(e[t])}const S=h("attrs,class,staticClass,staticStyle,key");function j(t,e,n,s){let i;const{tag:c,data:a,children:l}=e;if(s=s||a&&a.pre,e.elm=t,r(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(a)&&(o(i=a.hook)&&o(i=i.init)&&i(e,!0),o(i=e.componentInstance)))return p(e,n),!0;if(o(c)){if(o(l))if(t.hasChildNodes())if(o(i=a)&&o(i=i.domProps)&&o(i=i.innerHTML)){if(i!==t.innerHTML)return!1}else{let e=!0,o=t.firstChild;for(let t=0;t<l.length;t++){if(!o||!j(o,l[t],n,s)){e=!1;break}o=o.nextSibling}if(!e||o)return!1}else _(e,l,n);if(o(a)){let t=!1;for(const o in a)if(!S(o)){t=!0,y(e,n);break}!t&&a.class&&on(a.class)}}else t.data!==e.text&&(t.data=e.text);return!0}return function(t,e,s,i){if(n(e))return void(o(t)&&$(t));let c=!1;const l=[];if(n(t))c=!0,d(e,l);else{const n=o(t.nodeType);if(!n&&zo(t,e))k(t,e,l,null,null,i);else{if(n){if(1===t.nodeType&&t.hasAttribute("data-server-rendered")&&(t.removeAttribute("data-server-rendered"),s=!0),r(s)&&j(t,e,l))return O(e,l,!0),t;f=t,t=new it(u.tagName(f).toLowerCase(),{},[],void 0,f)}const i=t.elm,c=u.parentNode(i);if(d(e,l,i._leaveCb?null:c,u.nextSibling(i)),o(e.parent)){let t=e.parent;const n=v(e);for(;t;){for(let e=0;e<a.destroy.length;++e)a.destroy[e](t);if(t.elm=e.elm,n){for(let e=0;e<a.create.length;++e)a.create[e](Bo,t);const e=t.data.hook.insert;if(e.merged)for(let t=1;t<e.fns.length;t++)e.fns[t]()}else Fo(t);t=t.parent}}o(c)?w([t],0,0):o(t.tag)&&$(t)}}var f;return O(e,l,c),e.elm}}({nodeOps:Ro,modules:[er,or,ur,hr,kr,z?{create:Zr,activate:Zr,remove(t,e){!0!==t.data.show?Kr(t,e):e()}}:{}].concat(Xo)});K&&document.addEventListener("selectionchange",(()=>{const t=document.activeElement;t&&t.vmodel&&rs(t,"input")}));const Xr={inserted(t,e,n,o){"select"===n.tag?(o.elm&&!o.elm._vOptions?Jt(n,"postpatch",(()=>{Xr.componentUpdated(t,e,n)})):Qr(t,e,n.context),t._vOptions=[].map.call(t.options,es)):("textarea"===n.tag||Mo(t.type))&&(t._vModifiers=e.modifiers,e.modifiers.lazy||(t.addEventListener("compositionstart",ns),t.addEventListener("compositionend",os),t.addEventListener("change",os),K&&(t.vmodel=!0)))},componentUpdated(t,e,n){if("select"===n.tag){Qr(t,e,n.context);const o=t._vOptions,r=t._vOptions=[].map.call(t.options,es);if(r.some(((t,e)=>!P(t,o[e])))){(t.multiple?e.value.some((t=>ts(t,r))):e.value!==e.oldValue&&ts(e.value,r))&&rs(t,"change")}}}};function Qr(t,e,n){Yr(t,e),(W||q)&&setTimeout((()=>{Yr(t,e)}),0)}function Yr(t,e,n){const o=e.value,r=t.multiple;if(r&&!Array.isArray(o))return;let s,i;for(let e=0,n=t.options.length;e<n;e++)if(i=t.options[e],r)s=I(o,es(i))>-1,i.selected!==s&&(i.selected=s);else if(P(es(i),o))return void(t.selectedIndex!==e&&(t.selectedIndex=e));r||(t.selectedIndex=-1)}function ts(t,e){return e.every((e=>!P(e,t)))}function es(t){return"_value"in t?t._value:t.value}function ns(t){t.target.composing=!0}function os(t){t.target.composing&&(t.target.composing=!1,rs(t.target,"input"))}function rs(t,e){const n=document.createEvent("HTMLEvents");n.initEvent(e,!0,!0),t.dispatchEvent(n)}function ss(t){return!t.componentInstance||t.data&&t.data.transition?t:ss(t.componentInstance._vnode)}var is={bind(t,{value:e},n){const o=(n=ss(n)).data&&n.data.transition,r=t.__vOriginalDisplay="none"===t.style.display?"":t.style.display;e&&o?(n.data.show=!0,Wr(n,(()=>{t.style.display=r}))):t.style.display=e?r:"none"},update(t,{value:e,oldValue:n},o){if(!e==!n)return;(o=ss(o)).data&&o.data.transition?(o.data.show=!0,e?Wr(o,(()=>{t.style.display=t.__vOriginalDisplay})):Kr(o,(()=>{t.style.display="none"}))):t.style.display=e?t.__vOriginalDisplay:"none"},unbind(t,e,n,o,r){r||(t.style.display=t.__vOriginalDisplay)}},cs={model:Xr,show:is};const as={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function ls(t){const e=t&&t.componentOptions;return e&&e.Ctor.options.abstract?ls(Ae(e.children)):t}function us(t){const e={},n=t.$options;for(const o in n.propsData)e[o]=t[o];const o=n._parentListeners;for(const t in o)e[$(t)]=o[t];return e}function fs(t,e){if(/\d-keep-alive$/.test(e.tag))return t("keep-alive",{props:e.componentOptions.propsData})}const ds=t=>t.tag||ye(t),ps=t=>"show"===t.name;var hs={name:"transition",props:as,abstract:!0,render(t){let e=this.$slots.default;if(!e)return;if(e=e.filter(ds),!e.length)return;const n=this.mode,o=e[0];if(function(t){for(;t=t.parent;)if(t.data.transition)return!0}(this.$vnode))return o;const r=ls(o);if(!r)return o;if(this._leaving)return fs(t,o);const i=`__transition-${this._uid}-`;r.key=null==r.key?r.isComment?i+"comment":i+r.tag:s(r.key)?0===String(r.key).indexOf(i)?r.key:i+r.key:r.key;const c=(r.data||(r.data={})).transition=us(this),a=this._vnode,l=ls(a);if(r.data.directives&&r.data.directives.some(ps)&&(r.data.show=!0),l&&l.data&&!function(t,e){return e.key===t.key&&e.tag===t.tag}(r,l)&&!ye(l)&&(!l.componentInstance||!l.componentInstance._vnode.isComment)){const e=l.data.transition=S({},c);if("out-in"===n)return this._leaving=!0,Jt(e,"afterLeave",(()=>{this._leaving=!1,this.$forceUpdate()})),fs(t,o);if("in-out"===n){if(ye(r))return a;let t;const n=()=>{t()};Jt(c,"afterEnter",n),Jt(c,"enterCancelled",n),Jt(e,"delayLeave",(e=>{t=e}))}}return o}};const ms=S({tag:String,moveClass:String},as);delete ms.mode;var _s={props:ms,beforeMount(){const t=this._update;this._update=(e,n)=>{const o=hn(this);this.__patch__(this._vnode,this.kept,!1,!0),this._vnode=this.kept,o(),t.call(this,e,n)}},render(t){const e=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),o=this.prevChildren=this.children,r=this.$slots.default||[],s=this.children=[],i=us(this);for(let t=0;t<r.length;t++){const e=r[t];e.tag&&null!=e.key&&0!==String(e.key).indexOf("__vlist")&&(s.push(e),n[e.key]=e,(e.data||(e.data={})).transition=i)}if(o){const r=[],s=[];for(let t=0;t<o.length;t++){const e=o[t];e.data.transition=i,e.data.pos=e.elm.getBoundingClientRect(),n[e.key]?r.push(e):s.push(e)}this.kept=t(e,null,r),this.removed=s}return t(e,null,s)},updated(){const t=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";t.length&&this.hasMove(t[0].elm,e)&&(t.forEach(vs),t.forEach(ys),t.forEach(gs),this._reflow=document.body.offsetHeight,t.forEach((t=>{if(t.data.moved){const n=t.elm,o=n.style;Lr(n,e),o.transform=o.WebkitTransform=o.transitionDuration="",n.addEventListener(Ir,n._moveCb=function t(o){o&&o.target!==n||o&&!/transform$/.test(o.propertyName)||(n.removeEventListener(Ir,t),n._moveCb=null,Fr(n,e))})}})))},methods:{hasMove(t,e){if(!Er)return!1;if(this._hasMove)return this._hasMove;const n=t.cloneNode();t._transitionClasses&&t._transitionClasses.forEach((t=>{jr(n,t)})),Sr(n,e),n.style.display="none",this.$el.appendChild(n);const o=Vr(n);return this.$el.removeChild(n),this._hasMove=o.hasTransform}}};function vs(t){t.elm._moveCb&&t.elm._moveCb(),t.elm._enterCb&&t.elm._enterCb()}function ys(t){t.data.newPos=t.elm.getBoundingClientRect()}function gs(t){const e=t.data.pos,n=t.data.newPos,o=e.left-n.left,r=e.top-n.top;if(o||r){t.data.moved=!0;const e=t.elm.style;e.transform=e.WebkitTransform=`translate(${o}px,${r}px)`,e.transitionDuration="0s"}}var bs={Transition:hs,TransitionGroup:_s};lo.config.mustUseProp=(t,e,n)=>"value"===n&&go(t)&&"button"!==e||"selected"===n&&"option"===t||"checked"===n&&"input"===t||"muted"===n&&"video"===t,lo.config.isReservedTag=Do,lo.config.isReservedAttr=yo,lo.config.getTagNamespace=function(t){return Io(t)?"svg":"math"===t?"math":void 0},lo.config.isUnknownElement=function(t){if(!z)return!0;if(Do(t))return!1;if(t=t.toLowerCase(),null!=No[t])return No[t];const e=document.createElement(t);return t.indexOf("-")>-1?No[t]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:No[t]=/HTMLUnknownElement/.test(e.toString())},S(lo.options.directives,cs),S(lo.options.components,bs),lo.prototype.__patch__=z?Jr:A,lo.prototype.$mount=function(t,e){return function(t,e,n){let o;t.$el=e,t.$options.render||(t.$options.render=ct),yn(t,"beforeMount"),o=()=>{t._update(t._render(),n)},new an(t,o,A,{before(){t._isMounted&&!t._isDestroyed&&yn(t,"beforeUpdate")}},!0),n=!1;const r=t._preWatchers;if(r)for(let t=0;t<r.length;t++)r[t].run();return null==t.$vnode&&(t._isMounted=!0,yn(t,"mounted")),t}(this,t=t&&z?function(t){if("string"==typeof t){return document.querySelector(t)||document.createElement("div")}return t}(t):void 0,e)},z&&setTimeout((()=>{L.devtools&&tt&&tt.emit("init",lo)}),0),S(lo,en),module.exports=lo;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"timers":5}],11:[function(require,module,exports){
;(function(){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
    data: function data() {
        return {
            loading: false,
            failed: false,
            hasChanged: false,
            tags: [],
            rules: [],
            backup: null
        };
    },


    computed: {
        filteredTags: function filteredTags() {
            var _this = this;

            return _.filter(this.tags, function (tag) {
                return !_this.tagHasRules(tag.id);
            });
        }
    },

    mounted: function mounted() {
        var _this2 = this;

        this.fetchTags();
        this.fetchRules();

        $('#files_classifier_select_tags').select2({
            placeholder: this.$gettext('Add a tag'),
            formatNoMatches: this.$gettext('No tags found'),
            initSelection: function initSelection(el, callback) {
                callback();
            },

            query: function query(_query) {
                var results = _.filter(_this2.filteredTags, function (tag) {
                    return tag.text.toUpperCase().indexOf(_query.term.toUpperCase()) >= 0;
                });
                _query.callback({ results: results });
            }
        }).on('change', function (e) {
            _this2.addRule(e.added.id);
            $(e.target).select2('val', '');
        });
    },


    watch: {
        rules: {
            deep: true,
            handler: function handler() {
                if (!this.backup) {
                    return;
                }

                this.hasChanged = (0, _stringify2.default)(this.rules) !== this.backup;
            }
        }
    },

    methods: {
        _setLoading: function _setLoading() {
            this.loading = true;
            this.failed = false;
        },
        _setFailed: function _setFailed() {
            var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            this.loading = false;
            this.failed = message ? message : true;
        },
        _setDone: function _setDone() {
            this.loading = false;
            this.failed = false;
        },
        _backupRules: function _backupRules() {
            this.backup = (0, _stringify2.default)(this.rules);
        },
        _restoreRules: function _restoreRules() {
            this.rules = JSON.parse(this.backup);
        },
        addRule: function addRule(tagId) {
            var newRule = _.extend({
                xpath: null,
                value: null,
                documentIdXpath: null,
                daysUntilPasswordlessLinkSharesExpire: null,
                isUploadAllowed: true,
                isLinkShareAllowed: true
            }, { tagId: tagId });

            this.rules.push(newRule);
        },
        removeRule: function removeRule(key) {
            if (!this.loading) {
                this.rules.splice(key, 1);
            }
        },
        getTagNameById: function getTagNameById(id) {
            return _.findWhere(this.tags, { id: id }).text;
        },
        tagHasRules: function tagHasRules(id) {
            var filtered = _.where(this.rules, { tagId: id });
            return !!filtered.length;
        },
        restoreFromBackup: function restoreFromBackup() {
            this._restoreRules();
        },
        toggleAllowUpload: function toggleAllowUpload(id) {
            var rule = this.rules[id];
            rule.isUploadAllowed = !rule.isUploadAllowed;
        },
        toggleAllowLinkShare: function toggleAllowLinkShare(id) {
            var rule = this.rules[id];
            rule.isLinkShareAllowed = !rule.isLinkShareAllowed;

            if (!rule.isLinkShareAllowed) {
                rule.daysUntilPasswordlessLinkSharesExpire = null;
            }
        },
        fetchTags: function fetchTags() {
            var _this3 = this;

            this._setLoading();

            $.ajax({
                dataType: 'json',
                url: OC.generateUrl('apps/files_classifier/tags')
            }).success(function (tags) {
                _this3.tags = _.chain(tags).where({ isUserEditable: false }).map(function (tag) {
                    if (!(tag.isUserVisible && tag.isUserAssignable && tag.isUserEditable)) {
                        return {
                            id: tag.id,
                            text: tag.name
                        };
                    }
                }).value();
                _this3._setDone();
            }).fail(function (err) {
                _this3._setFailed(err);
            });
        },
        fetchRules: function fetchRules() {
            var _this4 = this;

            this._setLoading();
            $.ajax({
                dataType: 'json',
                url: OC.generateUrl('apps/files_classifier/rules')
            }).success(function (rules) {
                _this4.rules = rules ? rules : [];
                _this4._backupRules();
                _this4._setDone();
            }).fail(function (err) {
                _this4._setFailed(err);
            });
        },
        saveRules: function saveRules() {
            var _this5 = this;

            this._setLoading();
            var prepared = this.rules.map(function (rule) {
                var expire = parseInt(rule.daysUntilPasswordlessLinkSharesExpire, 10);
                if (!expire) {
                    expire = null;
                }
                return _.extend(rule, { daysUntilPasswordlessLinkSharesExpire: expire });
            });

            $.ajax({
                type: 'PUT',
                dataType: 'json',
                contentType: 'application/json',
                url: OC.generateUrl('apps/files_classifier/rules'),
                data: (0, _stringify2.default)(prepared)
            }).success(function () {
                _this5.fetchRules();
            }).fail(function (err) {
                _this5._setFailed(err);
            });
        }
    }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"section",attrs:{"id":"files_classifier"}},[_c('h2',{directives:[{name:"translate",rawName:"v-translate"}]},[_vm._v("\n        Document Classification and Feature Policies\n        ")]),_vm._v(" "),_c('p',{directives:[{name:"translate",rawName:"v-translate"}]},[_vm._v("\n        Define rules to automatically tag uploaded documents using their metadata and enforce feature policies based on assigned tags.\n    ")]),_vm._v(" "),_c('section',{staticClass:"tag-list",class:{ 'is-loading' : _vm.loading }},[_c('table',[_c('thead',[_c('tr',[_c('th',{directives:[{name:"translate",rawName:"v-translate"}],attrs:{"colspan":"2"}},[_vm._v("Metadata")]),_vm._v(" "),_c('th',{directives:[{name:"translate",rawName:"v-translate"}],attrs:{"rowspan":"2"}},[_vm._v("Tag")]),_vm._v(" "),_c('th',{directives:[{name:"translate",rawName:"v-translate"}],attrs:{"colspan":"3"}},[_vm._v("Policies")]),_vm._v(" "),_c('th',{directives:[{name:"translate",rawName:"v-translate"}],attrs:{"colspan":"2"}},[_vm._v("Logging")])]),_vm._v(" "),_c('tr',[_c('th',{directives:[{name:"translate",rawName:"v-translate"}]},[_vm._v("Property XPath")]),_vm._v(" "),_c('th',{directives:[{name:"translate",rawName:"v-translate"}]},[_vm._v("Property Value")]),_vm._v(" "),_c('th',{directives:[{name:"translate",rawName:"v-translate"}]},[_vm._v("Prevent upload")]),_vm._v(" "),_c('th',{directives:[{name:"translate",rawName:"v-translate"}]},[_vm._v("Prevent link sharing")]),_vm._v(" "),_c('th',{directives:[{name:"translate",rawName:"v-translate"}],staticStyle:{"min-width":"125px"}},[_vm._v("Unprotected links expire")]),_vm._v(" "),_c('th',{directives:[{name:"translate",rawName:"v-translate"}],attrs:{"colspan":"2"}},[_vm._v("Document ID XPath")])])]),_vm._v(" "),_c('tbody',[(!_vm.rules.length)?_c('tr',[_c('td',{staticClass:"text-center",attrs:{"colspan":"7"}},[_c('em',{directives:[{name:"translate",rawName:"v-translate"}]},[_vm._v("No data yet")])])]):_vm._e(),_vm._v(" "),_vm._l((_vm.rules),function(rule,rid){return _c('tr',{key:rid},[_c('td',[_c('input',{directives:[{name:"model",rawName:"v-model.lazy",value:(rule.xpath),expression:"rule.xpath",modifiers:{"lazy":true}}],attrs:{"type":"text","readonly":_vm.loading},domProps:{"value":(rule.xpath)},on:{"change":function($event){return _vm.$set(rule, "xpath", $event.target.value)}}})]),_vm._v(" "),_c('td',[_c('input',{directives:[{name:"model",rawName:"v-model.lazy",value:(rule.value),expression:"rule.value",modifiers:{"lazy":true}}],attrs:{"type":"text","readonly":_vm.loading},domProps:{"value":(rule.value)},on:{"change":function($event){return _vm.$set(rule, "value", $event.target.value)}}})]),_vm._v(" "),_c('td',{staticClass:"text-bold text-monospace"},[_c('select',{directives:[{name:"model",rawName:"v-model",value:(rule.tagId),expression:"rule.tagId"}],attrs:{"disabled":_vm.loading},on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.$set(rule, "tagId", $event.target.multiple ? $$selectedVal : $$selectedVal[0])}}},_vm._l((_vm.tags),function(tag,tid){return _c('option',{key:tid,attrs:{"disabled":_vm.tagHasRules(tag.id) && rule.tagId != tag.id},domProps:{"value":tag.id}},[_vm._v(_vm._s(_vm.getTagNameById(tag.id)))])}),0)]),_vm._v(" "),_c('td',{staticClass:"checkbox",class:{'is-checked' : !rule.isUploadAllowed },on:{"click":function($event){return _vm.toggleAllowUpload(rid)}}}),_vm._v(" "),_c('td',{staticClass:"checkbox",class:{'is-checked' : !rule.isLinkShareAllowed },on:{"click":function($event){return _vm.toggleAllowLinkShare(rid)}}}),_vm._v(" "),_c('td',[(rule.isLinkShareAllowed)?_c('div',[_c('span',{directives:[{name:"translate",rawName:"v-translate"}]},[_vm._v("after")]),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model.lazy",value:(rule.daysUntilPasswordlessLinkSharesExpire),expression:"rule.daysUntilPasswordlessLinkSharesExpire",modifiers:{"lazy":true}}],staticStyle:{"width":"38px","text-align":"center"},attrs:{"type":"number","min":"1","readonly":_vm.loading},domProps:{"value":(rule.daysUntilPasswordlessLinkSharesExpire)},on:{"change":function($event){return _vm.$set(rule, "daysUntilPasswordlessLinkSharesExpire", $event.target.value)}}}),_vm._v(" "),_c('span',{directives:[{name:"translate",rawName:"v-translate"}]},[_vm._v("days")])]):_vm._e()]),_vm._v(" "),_c('td',[_c('input',{directives:[{name:"model",rawName:"v-model.lazy",value:(rule.documentIdXpath),expression:"rule.documentIdXpath",modifiers:{"lazy":true}}],attrs:{"type":"text","readonly":_vm.loading},domProps:{"value":(rule.documentIdXpath)},on:{"change":function($event){return _vm.$set(rule, "documentIdXpath", $event.target.value)}}})]),_vm._v(" "),_c('td',{staticClass:"text-right"},[_c('span',{staticClass:"icon icon-delete inlineblock",on:{"click":function($event){return _vm.removeRule(rid)}}})])])})],2)]),_vm._v(" "),_c('section',{staticClass:"footer"},[_vm._m(0),_vm._v(" "),_c('div',{staticClass:"footer-right"},[(_vm.hasChanged)?_c('button',{directives:[{name:"translate",rawName:"v-translate"}],attrs:{"disabled":_vm.loading},on:{"click":_vm.restoreFromBackup}},[_vm._v("Revert")]):_vm._e(),_vm._v(" "),_c('button',{directives:[{name:"translate",rawName:"v-translate",value:(_vm.core),expression:"core"}],staticClass:"button-primary",attrs:{"disabled":!_vm.hasChanged || _vm.loading},on:{"click":_vm.saveRules}},[_vm._v("Save")])])]),_vm._v(" "),(_vm.loading)?_c('div',{staticClass:"loading"}):_vm._e()])])}
__vue__options__.staticRenderFns = [function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"footer-left"},[_c('input',{attrs:{"name":"foo","id":"files_classifier_select_tags"}})])}]
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-d588019c", __vue__options__)
  } else {
    hotAPI.reload("data-v-d588019c", __vue__options__)
  }
})()}

},{"babel-runtime/core-js/json/stringify":1,"vue":9,"vue-hot-reload-api":6}],12:[function(require,module,exports){
'use strict';

var _vueMin = require('vue/dist/vue.min.js');

var _vueMin2 = _interopRequireDefault(_vueMin);

var _settings = require('./components/settings.vue');

var _settings2 = _interopRequireDefault(_settings);

var _translate = require('./translate.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vueMin2.default.mixin(_translate.mixin); /**
                                           *
                                           * @copyright Copyright (c) 2018, ownCloud GmbH
                                           * @license OCL
                                           *
                                           * This code is covered by the ownCloud Commercial License.
                                           *
                                           * You should have received a copy of the ownCloud Commercial License
                                           * along with this program. If not, see <https://owncloud.com/licenses/owncloud-commercial/>.
                                           *
                                           */

// @NOTE: Use vue.js (drom .min.) in development mode
// @TODO: Employ NODE_ENV specific version(s)

_vueMin2.default.directive('translate', _translate.directive);

var files_classifier = new _vueMin2.default({
  template: '<Settings/>',
  components: {
    Settings: _settings2.default
  }
});

$(document).ready(function () {

  // outsourced for eslint purposes
  files_classifier.$mount('#app-files_classifier');
});

},{"./components/settings.vue":11,"./translate.js":13,"vue/dist/vue.min.js":7}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
var mixin = {
	data: function data() {
		return {
			core: 'core'
		};
	},

	methods: {
		t: function (_t) {
			function t(_x) {
				return _t.apply(this, arguments);
			}

			t.toString = function () {
				return _t.toString();
			};

			return t;
		}(function (string) {
			var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'files_classifier';

			return t(scope, string);
		}),
		$gettext: function $gettext(string) {
			var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'files_classifier';

			return t(scope, string);
		}
	}
};

var directive = {
	bind: function bind(el) {
		el.innerText = t('files_classifier', el.innerText.trim());
	}
};

exports.mixin = mixin;
exports.directive = directive;

},{}]},{},[12])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGkvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUubWluLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5ydW50aW1lLmNvbW1vbi5kZXYuanMiLCJub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLnJ1bnRpbWUuY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5ydW50aW1lLmNvbW1vbi5wcm9kLmpzIiwic3JjL3NjcmlwdHMvY29tcG9uZW50cy9zZXR0aW5ncy52dWU/YzdiMTI1YTYiLCJzcmMvc2NyaXB0cy9zZXR0aW5ncy5qcyIsInNyYy9zY3JpcHRzL3RyYW5zbGF0ZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzZ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7OztBQUVBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOztBQVFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFjQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQVJBO0FBREE7O0FBYUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7O0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFBQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNUlBO0FBeERBOzs7OztBQTdFQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7QUNlQTs7OztBQUNBOzs7O0FBRUE7Ozs7QUFFQSxpQkFBSSxLQUFKLENBQVUsZ0JBQVYsRSxDQXBCQTs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTs7QUFPQSxpQkFBSSxTQUFKLENBQWMsV0FBZCxFQUEyQixvQkFBM0I7O0FBRUEsSUFBTSxtQkFBbUIsSUFBSSxnQkFBSixDQUFRO0FBQ2hDLFlBQVcsYUFEcUI7QUFFaEMsY0FBYTtBQUNaO0FBRFk7QUFGbUIsQ0FBUixDQUF6Qjs7QUFPQSxFQUFFLFFBQUYsRUFBWSxLQUFaLENBQWtCLFlBQU07O0FBRXZCO0FBQ0EsbUJBQWlCLE1BQWpCLENBQXdCLHVCQUF4QjtBQUNBLENBSkQ7Ozs7Ozs7O0FDOUJBLElBQU0sUUFBUTtBQUNiLEtBRGEsa0JBQ0w7QUFDUCxTQUFPO0FBQ04sU0FBTztBQURELEdBQVA7QUFHQSxFQUxZOztBQU1iLFVBQVU7QUFDVCxHQURTO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLGNBQ1AsTUFETyxFQUM2QjtBQUFBLE9BQTVCLEtBQTRCLHVFQUFwQixrQkFBb0I7O0FBQ3JDLFVBQU8sRUFBRSxLQUFGLEVBQVMsTUFBVCxDQUFQO0FBQ0EsR0FIUTtBQUlULFVBSlMsb0JBSUEsTUFKQSxFQUlvQztBQUFBLE9BQTVCLEtBQTRCLHVFQUFwQixrQkFBb0I7O0FBQzVDLFVBQU8sRUFBRSxLQUFGLEVBQVMsTUFBVCxDQUFQO0FBQ0E7QUFOUTtBQU5HLENBQWQ7O0FBaUJBLElBQU0sWUFBWTtBQUNqQixLQURpQixnQkFDWCxFQURXLEVBQ1A7QUFDVCxLQUFHLFNBQUgsR0FBZSxFQUFFLGtCQUFGLEVBQXNCLEdBQUcsU0FBSCxDQUFhLElBQWIsRUFBdEIsQ0FBZjtBQUNBO0FBSGdCLENBQWxCOztRQU9DLEssR0FBQSxLO1FBQ0EsUyxHQUFBLFMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKTtcbnZhciAkSlNPTiA9IGNvcmUuSlNPTiB8fCAoY29yZS5KU09OID0geyBzdHJpbmdpZnk6IEpTT04uc3RyaW5naWZ5IH0pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gJEpTT04uc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmd1bWVudHMpO1xufTtcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjYuMTEnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59OyIsInZhciBWdWUgLy8gbGF0ZSBiaW5kXG52YXIgdmVyc2lvblxudmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbClcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB3aW5kb3cuX19WVUVfSE9UX01BUF9fID0gbWFwXG59XG52YXIgaW5zdGFsbGVkID0gZmFsc2VcbnZhciBpc0Jyb3dzZXJpZnkgPSBmYWxzZVxudmFyIGluaXRIb29rTmFtZSA9ICdiZWZvcmVDcmVhdGUnXG5cbmV4cG9ydHMuaW5zdGFsbCA9IGZ1bmN0aW9uICh2dWUsIGJyb3dzZXJpZnkpIHtcbiAgaWYgKGluc3RhbGxlZCkgeyByZXR1cm4gfVxuICBpbnN0YWxsZWQgPSB0cnVlXG5cbiAgVnVlID0gdnVlLl9fZXNNb2R1bGUgPyB2dWUuZGVmYXVsdCA6IHZ1ZVxuICB2ZXJzaW9uID0gVnVlLnZlcnNpb24uc3BsaXQoJy4nKS5tYXAoTnVtYmVyKVxuICBpc0Jyb3dzZXJpZnkgPSBicm93c2VyaWZ5XG5cbiAgLy8gY29tcGF0IHdpdGggPCAyLjAuMC1hbHBoYS43XG4gIGlmIChWdWUuY29uZmlnLl9saWZlY3ljbGVIb29rcy5pbmRleE9mKCdpbml0JykgPiAtMSkge1xuICAgIGluaXRIb29rTmFtZSA9ICdpbml0J1xuICB9XG5cbiAgZXhwb3J0cy5jb21wYXRpYmxlID0gdmVyc2lvblswXSA+PSAyXG4gIGlmICghZXhwb3J0cy5jb21wYXRpYmxlKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1tITVJdIFlvdSBhcmUgdXNpbmcgYSB2ZXJzaW9uIG9mIHZ1ZS1ob3QtcmVsb2FkLWFwaSB0aGF0IGlzICcgK1xuICAgICAgICAnb25seSBjb21wYXRpYmxlIHdpdGggVnVlLmpzIGNvcmUgXjIuMC4wLidcbiAgICApXG4gICAgcmV0dXJuXG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSByZWNvcmQgZm9yIGEgaG90IG1vZHVsZSwgd2hpY2gga2VlcHMgdHJhY2sgb2YgaXRzIGNvbnN0cnVjdG9yXG4gKiBhbmQgaW5zdGFuY2VzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmV4cG9ydHMuY3JlYXRlUmVjb3JkID0gZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XG4gIGlmKG1hcFtpZF0pIHsgcmV0dXJuIH1cblxuICB2YXIgQ3RvciA9IG51bGxcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgQ3RvciA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zXG4gIH1cbiAgbWFrZU9wdGlvbnNIb3QoaWQsIG9wdGlvbnMpXG4gIG1hcFtpZF0gPSB7XG4gICAgQ3RvcjogQ3RvcixcbiAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgIGluc3RhbmNlczogW11cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIG1vZHVsZSBpcyByZWNvcmRlZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICovXG5cbmV4cG9ydHMuaXNSZWNvcmRlZCA9IGZ1bmN0aW9uIChpZCkge1xuICByZXR1cm4gdHlwZW9mIG1hcFtpZF0gIT09ICd1bmRlZmluZWQnXG59XG5cbi8qKlxuICogTWFrZSBhIENvbXBvbmVudCBvcHRpb25zIG9iamVjdCBob3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIG1ha2VPcHRpb25zSG90KGlkLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICB2YXIgcmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcbiAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIChoLCBjdHgpIHtcbiAgICAgIHZhciBpbnN0YW5jZXMgPSBtYXBbaWRdLmluc3RhbmNlc1xuICAgICAgaWYgKGN0eCAmJiBpbnN0YW5jZXMuaW5kZXhPZihjdHgucGFyZW50KSA8IDApIHtcbiAgICAgICAgaW5zdGFuY2VzLnB1c2goY3R4LnBhcmVudClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW5kZXIoaCwgY3R4KVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpbmplY3RIb29rKG9wdGlvbnMsIGluaXRIb29rTmFtZSwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVjb3JkID0gbWFwW2lkXVxuICAgICAgaWYgKCFyZWNvcmQuQ3Rvcikge1xuICAgICAgICByZWNvcmQuQ3RvciA9IHRoaXMuY29uc3RydWN0b3JcbiAgICAgIH1cbiAgICAgIHJlY29yZC5pbnN0YW5jZXMucHVzaCh0aGlzKVxuICAgIH0pXG4gICAgaW5qZWN0SG9vayhvcHRpb25zLCAnYmVmb3JlRGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGluc3RhbmNlcyA9IG1hcFtpZF0uaW5zdGFuY2VzXG4gICAgICBpbnN0YW5jZXMuc3BsaWNlKGluc3RhbmNlcy5pbmRleE9mKHRoaXMpLCAxKVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBJbmplY3QgYSBob29rIHRvIGEgaG90IHJlbG9hZGFibGUgY29tcG9uZW50IHNvIHRoYXRcbiAqIHdlIGNhbiBrZWVwIHRyYWNrIG9mIGl0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gaG9va1xuICovXG5cbmZ1bmN0aW9uIGluamVjdEhvb2sob3B0aW9ucywgbmFtZSwgaG9vaykge1xuICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zW25hbWVdXG4gIG9wdGlvbnNbbmFtZV0gPSBleGlzdGluZ1xuICAgID8gQXJyYXkuaXNBcnJheShleGlzdGluZykgPyBleGlzdGluZy5jb25jYXQoaG9vaykgOiBbZXhpc3RpbmcsIGhvb2tdXG4gICAgOiBbaG9va11cbn1cblxuZnVuY3Rpb24gdHJ5V3JhcChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGlkLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgZm4oaWQsIGFyZylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgVnVlIGNvbXBvbmVudCBob3QtcmVsb2FkLiBGdWxsIHJlbG9hZCByZXF1aXJlZC4nXG4gICAgICApXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMgKG9sZE9wdGlvbnMsIG5ld09wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIG9sZE9wdGlvbnMpIHtcbiAgICBpZiAoIShrZXkgaW4gbmV3T3B0aW9ucykpIHtcbiAgICAgIGRlbGV0ZSBvbGRPcHRpb25zW2tleV1cbiAgICB9XG4gIH1cbiAgZm9yICh2YXIga2V5JDEgaW4gbmV3T3B0aW9ucykge1xuICAgIG9sZE9wdGlvbnNba2V5JDFdID0gbmV3T3B0aW9uc1trZXkkMV1cbiAgfVxufVxuXG5leHBvcnRzLnJlcmVuZGVyID0gdHJ5V3JhcChmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlY29yZCA9IG1hcFtpZF1cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgcmVjb3JkLmluc3RhbmNlcy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICBpbnN0YW5jZS4kZm9yY2VVcGRhdGUoKVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMub3B0aW9uc1xuICB9XG4gIGlmIChyZWNvcmQuQ3Rvcikge1xuICAgIHJlY29yZC5DdG9yLm9wdGlvbnMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcbiAgICByZWNvcmQuQ3Rvci5vcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zXG4gICAgcmVjb3JkLmluc3RhbmNlcy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICBpbnN0YW5jZS4kb3B0aW9ucy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgaW5zdGFuY2UuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNcbiAgICAgIC8vIHJlc2V0IHN0YXRpYyB0cmVlc1xuICAgICAgLy8gcHJlIDIuNSwgYWxsIHN0YXRpYyB0cmVlcyBhcmUgY2FjaGVkIHRvZ2V0aGVyIG9uIHRoZSBpbnN0YW5jZVxuICAgICAgaWYgKGluc3RhbmNlLl9zdGF0aWNUcmVlcykge1xuICAgICAgICBpbnN0YW5jZS5fc3RhdGljVHJlZXMgPSBbXVxuICAgICAgfVxuICAgICAgLy8gMi41LjBcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlY29yZC5DdG9yLm9wdGlvbnMuY2FjaGVkKSkge1xuICAgICAgICByZWNvcmQuQ3Rvci5vcHRpb25zLmNhY2hlZCA9IFtdXG4gICAgICB9XG4gICAgICAvLyAyLjUuM1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5zdGFuY2UuJG9wdGlvbnMuY2FjaGVkKSkge1xuICAgICAgICBpbnN0YW5jZS4kb3B0aW9ucy5jYWNoZWQgPSBbXVxuICAgICAgfVxuXG4gICAgICAvLyBwb3N0IDIuNS40OiB2LW9uY2UgdHJlZXMgYXJlIGNhY2hlZCBvbiBpbnN0YW5jZS5fc3RhdGljVHJlZXMuXG4gICAgICAvLyBQdXJlIHN0YXRpYyB0cmVlcyBhcmUgY2FjaGVkIG9uIHRoZSBzdGF0aWNSZW5kZXJGbnMgYXJyYXlcbiAgICAgIC8vIChib3RoIGFscmVhZHkgcmVzZXQgYWJvdmUpXG5cbiAgICAgIC8vIDIuNjogdGVtcG9yYXJpbHkgbWFyayByZW5kZXJlZCBzY29wZWQgc2xvdHMgYXMgdW5zdGFibGUgc28gdGhhdFxuICAgICAgLy8gY2hpbGQgY29tcG9uZW50cyBjYW4gYmUgZm9yY2VkIHRvIHVwZGF0ZVxuICAgICAgdmFyIHJlc3RvcmUgPSBwYXRjaFNjb3BlZFNsb3RzKGluc3RhbmNlKVxuICAgICAgaW5zdGFuY2UuJGZvcmNlVXBkYXRlKClcbiAgICAgIGluc3RhbmNlLiRuZXh0VGljayhyZXN0b3JlKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgLy8gZnVuY3Rpb25hbCBvciBubyBpbnN0YW5jZSBjcmVhdGVkIHlldFxuICAgIHJlY29yZC5vcHRpb25zLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgcmVjb3JkLm9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNcblxuICAgIC8vIGhhbmRsZSBmdW5jdGlvbmFsIGNvbXBvbmVudCByZS1yZW5kZXJcbiAgICBpZiAocmVjb3JkLm9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgICAgLy8gcmVyZW5kZXIgd2l0aCBmdWxsIG9wdGlvbnNcbiAgICAgIGlmIChPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPiAyKSB7XG4gICAgICAgIHVwZGF0ZU9wdGlvbnMocmVjb3JkLm9wdGlvbnMsIG9wdGlvbnMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0ZW1wbGF0ZS1vbmx5IHJlcmVuZGVyLlxuICAgICAgICAvLyBuZWVkIHRvIGluamVjdCB0aGUgc3R5bGUgaW5qZWN0aW9uIGNvZGUgZm9yIENTUyBtb2R1bGVzXG4gICAgICAgIC8vIHRvIHdvcmsgcHJvcGVybHkuXG4gICAgICAgIHZhciBpbmplY3RTdHlsZXMgPSByZWNvcmQub3B0aW9ucy5faW5qZWN0U3R5bGVzXG4gICAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgICB2YXIgcmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcbiAgICAgICAgICByZWNvcmQub3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiAoaCwgY3R4KSB7XG4gICAgICAgICAgICBpbmplY3RTdHlsZXMuY2FsbChjdHgpXG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyKGgsIGN0eClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlY29yZC5vcHRpb25zLl9DdG9yID0gbnVsbFxuICAgICAgLy8gMi41LjNcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlY29yZC5vcHRpb25zLmNhY2hlZCkpIHtcbiAgICAgICAgcmVjb3JkLm9wdGlvbnMuY2FjaGVkID0gW11cbiAgICAgIH1cbiAgICAgIHJlY29yZC5pbnN0YW5jZXMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICBpbnN0YW5jZS4kZm9yY2VVcGRhdGUoKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pXG5cbmV4cG9ydHMucmVsb2FkID0gdHJ5V3JhcChmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlY29yZCA9IG1hcFtpZF1cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zLm9wdGlvbnNcbiAgICB9XG4gICAgbWFrZU9wdGlvbnNIb3QoaWQsIG9wdGlvbnMpXG4gICAgaWYgKHJlY29yZC5DdG9yKSB7XG4gICAgICBpZiAodmVyc2lvblsxXSA8IDIpIHtcbiAgICAgICAgLy8gcHJlc2VydmUgcHJlIDIuMiBiZWhhdmlvciBmb3IgZ2xvYmFsIG1peGluIGhhbmRsaW5nXG4gICAgICAgIHJlY29yZC5DdG9yLmV4dGVuZE9wdGlvbnMgPSBvcHRpb25zXG4gICAgICB9XG4gICAgICB2YXIgbmV3Q3RvciA9IHJlY29yZC5DdG9yLnN1cGVyLmV4dGVuZChvcHRpb25zKVxuICAgICAgLy8gcHJldmVudCByZWNvcmQub3B0aW9ucy5fQ3RvciBmcm9tIGJlaW5nIG92ZXJ3cml0dGVuIGFjY2lkZW50YWxseVxuICAgICAgbmV3Q3Rvci5vcHRpb25zLl9DdG9yID0gcmVjb3JkLm9wdGlvbnMuX0N0b3JcbiAgICAgIHJlY29yZC5DdG9yLm9wdGlvbnMgPSBuZXdDdG9yLm9wdGlvbnNcbiAgICAgIHJlY29yZC5DdG9yLmNpZCA9IG5ld0N0b3IuY2lkXG4gICAgICByZWNvcmQuQ3Rvci5wcm90b3R5cGUgPSBuZXdDdG9yLnByb3RvdHlwZVxuICAgICAgaWYgKG5ld0N0b3IucmVsZWFzZSkge1xuICAgICAgICAvLyB0ZW1wb3JhcnkgZ2xvYmFsIG1peGluIHN0cmF0ZWd5IHVzZWQgaW4gPCAyLjAuMC1hbHBoYS42XG4gICAgICAgIG5ld0N0b3IucmVsZWFzZSgpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZU9wdGlvbnMocmVjb3JkLm9wdGlvbnMsIG9wdGlvbnMpXG4gICAgfVxuICB9XG4gIHJlY29yZC5pbnN0YW5jZXMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIGlmIChpbnN0YW5jZS4kdm5vZGUgJiYgaW5zdGFuY2UuJHZub2RlLmNvbnRleHQpIHtcbiAgICAgIGluc3RhbmNlLiR2bm9kZS5jb250ZXh0LiRmb3JjZVVwZGF0ZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1Jvb3Qgb3IgbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSBtb2RpZmllZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuJ1xuICAgICAgKVxuICAgIH1cbiAgfSlcbn0pXG5cbi8vIDIuNiBvcHRpbWl6ZXMgdGVtcGxhdGUtY29tcGlsZWQgc2NvcGVkIHNsb3RzIGFuZCBza2lwcyB1cGRhdGVzIGlmIGNoaWxkXG4vLyBvbmx5IHVzZXMgc2NvcGVkIHNsb3RzLiBXZSBuZWVkIHRvIHBhdGNoIHRoZSBzY29wZWQgc2xvdHMgcmVzb2x2aW5nIGhlbHBlclxuLy8gdG8gdGVtcG9yYXJpbHkgbWFyayBhbGwgc2NvcGVkIHNsb3RzIGFzIHVuc3RhYmxlIGluIG9yZGVyIHRvIGZvcmNlIGNoaWxkXG4vLyB1cGRhdGVzLlxuZnVuY3Rpb24gcGF0Y2hTY29wZWRTbG90cyAoaW5zdGFuY2UpIHtcbiAgaWYgKCFpbnN0YW5jZS5fdSkgeyByZXR1cm4gfVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL2Jsb2IvZGV2L3NyYy9jb3JlL2luc3RhbmNlL3JlbmRlci1oZWxwZXJzL3Jlc29sdmUtc2NvcGVkLXNsb3RzLmpzXG4gIHZhciBvcmlnaW5hbCA9IGluc3RhbmNlLl91XG4gIGluc3RhbmNlLl91ID0gZnVuY3Rpb24gKHNsb3RzKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIDIuNi40IH4gMi42LjZcbiAgICAgIHJldHVybiBvcmlnaW5hbChzbG90cywgdHJ1ZSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyAyLjUgLyA+PSAyLjYuN1xuICAgICAgcmV0dXJuIG9yaWdpbmFsKHNsb3RzLCBudWxsLCB0cnVlKVxuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGluc3RhbmNlLl91ID0gb3JpZ2luYWxcbiAgfVxufVxuIiwiLyohXG4gKiBWdWUuanMgdjIuNy4xNFxuICogKGMpIDIwMTQtMjAyMiBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKiFcbiAqIFZ1ZS5qcyB2Mi43LjE0XG4gKiAoYykgMjAxNC0yMDIyIEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKGUpOih0PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6dHx8c2VsZikuVnVlPWUoKX0odGhpcywoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgdD1PYmplY3QuZnJlZXplKHt9KSxlPUFycmF5LmlzQXJyYXk7ZnVuY3Rpb24gbih0KXtyZXR1cm4gbnVsbD09dH1mdW5jdGlvbiByKHQpe3JldHVybiBudWxsIT10fWZ1bmN0aW9uIG8odCl7cmV0dXJuITA9PT10fWZ1bmN0aW9uIGkodCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR8fFwibnVtYmVyXCI9PXR5cGVvZiB0fHxcInN5bWJvbFwiPT10eXBlb2YgdHx8XCJib29sZWFuXCI9PXR5cGVvZiB0fWZ1bmN0aW9uIGEodCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdH1mdW5jdGlvbiBzKHQpe3JldHVybiBudWxsIT09dCYmXCJvYmplY3RcIj09dHlwZW9mIHR9dmFyIGM9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztmdW5jdGlvbiB1KHQpe3JldHVyblwiW29iamVjdCBPYmplY3RdXCI9PT1jLmNhbGwodCl9ZnVuY3Rpb24gbCh0KXt2YXIgZT1wYXJzZUZsb2F0KFN0cmluZyh0KSk7cmV0dXJuIGU+PTAmJk1hdGguZmxvb3IoZSk9PT1lJiZpc0Zpbml0ZSh0KX1mdW5jdGlvbiBmKHQpe3JldHVybiByKHQpJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnRoZW4mJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuY2F0Y2h9ZnVuY3Rpb24gZCh0KXtyZXR1cm4gbnVsbD09dD9cIlwiOkFycmF5LmlzQXJyYXkodCl8fHUodCkmJnQudG9TdHJpbmc9PT1jP0pTT04uc3RyaW5naWZ5KHQsbnVsbCwyKTpTdHJpbmcodCl9ZnVuY3Rpb24gcCh0KXt2YXIgZT1wYXJzZUZsb2F0KHQpO3JldHVybiBpc05hTihlKT90OmV9ZnVuY3Rpb24gdih0LGUpe2Zvcih2YXIgbj1PYmplY3QuY3JlYXRlKG51bGwpLHI9dC5zcGxpdChcIixcIiksbz0wO288ci5sZW5ndGg7bysrKW5bcltvXV09ITA7cmV0dXJuIGU/ZnVuY3Rpb24odCl7cmV0dXJuIG5bdC50b0xvd2VyQ2FzZSgpXX06ZnVuY3Rpb24odCl7cmV0dXJuIG5bdF19fXZhciBoPXYoXCJzbG90LGNvbXBvbmVudFwiLCEwKSxtPXYoXCJrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpc1wiKTtmdW5jdGlvbiBnKHQsZSl7dmFyIG49dC5sZW5ndGg7aWYobil7aWYoZT09PXRbbi0xXSlyZXR1cm4gdm9pZCh0Lmxlbmd0aD1uLTEpO3ZhciByPXQuaW5kZXhPZihlKTtpZihyPi0xKXJldHVybiB0LnNwbGljZShyLDEpfX12YXIgeT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIF8odCxlKXtyZXR1cm4geS5jYWxsKHQsZSl9ZnVuY3Rpb24gYih0KXt2YXIgZT1PYmplY3QuY3JlYXRlKG51bGwpO3JldHVybiBmdW5jdGlvbihuKXtyZXR1cm4gZVtuXXx8KGVbbl09dChuKSl9fXZhciAkPS8tKFxcdykvZyx3PWIoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlcGxhY2UoJCwoZnVuY3Rpb24odCxlKXtyZXR1cm4gZT9lLnRvVXBwZXJDYXNlKCk6XCJcIn0pKX0pKSx4PWIoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSl9KSksQz0vXFxCKFtBLVpdKS9nLGs9YigoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVwbGFjZShDLFwiLSQxXCIpLnRvTG93ZXJDYXNlKCl9KSk7dmFyIFM9RnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ/ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5iaW5kKGUpfTpmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4obil7dmFyIHI9YXJndW1lbnRzLmxlbmd0aDtyZXR1cm4gcj9yPjE/dC5hcHBseShlLGFyZ3VtZW50cyk6dC5jYWxsKGUsbik6dC5jYWxsKGUpfXJldHVybiBuLl9sZW5ndGg9dC5sZW5ndGgsbn07ZnVuY3Rpb24gTyh0LGUpe2U9ZXx8MDtmb3IodmFyIG49dC5sZW5ndGgtZSxyPW5ldyBBcnJheShuKTtuLS07KXJbbl09dFtuK2VdO3JldHVybiByfWZ1bmN0aW9uIFQodCxlKXtmb3IodmFyIG4gaW4gZSl0W25dPWVbbl07cmV0dXJuIHR9ZnVuY3Rpb24gQSh0KXtmb3IodmFyIGU9e30sbj0wO248dC5sZW5ndGg7bisrKXRbbl0mJlQoZSx0W25dKTtyZXR1cm4gZX1mdW5jdGlvbiBqKHQsZSxuKXt9dmFyIEU9ZnVuY3Rpb24odCxlLG4pe3JldHVybiExfSxOPWZ1bmN0aW9uKHQpe3JldHVybiB0fTtmdW5jdGlvbiBQKHQsZSl7aWYodD09PWUpcmV0dXJuITA7dmFyIG49cyh0KSxyPXMoZSk7aWYoIW58fCFyKXJldHVybiFuJiYhciYmU3RyaW5nKHQpPT09U3RyaW5nKGUpO3RyeXt2YXIgbz1BcnJheS5pc0FycmF5KHQpLGk9QXJyYXkuaXNBcnJheShlKTtpZihvJiZpKXJldHVybiB0Lmxlbmd0aD09PWUubGVuZ3RoJiZ0LmV2ZXJ5KChmdW5jdGlvbih0LG4pe3JldHVybiBQKHQsZVtuXSl9KSk7aWYodCBpbnN0YW5jZW9mIERhdGUmJmUgaW5zdGFuY2VvZiBEYXRlKXJldHVybiB0LmdldFRpbWUoKT09PWUuZ2V0VGltZSgpO2lmKG98fGkpcmV0dXJuITE7dmFyIGE9T2JqZWN0LmtleXModCksYz1PYmplY3Qua2V5cyhlKTtyZXR1cm4gYS5sZW5ndGg9PT1jLmxlbmd0aCYmYS5ldmVyeSgoZnVuY3Rpb24obil7cmV0dXJuIFAodFtuXSxlW25dKX0pKX1jYXRjaCh0KXtyZXR1cm4hMX19ZnVuY3Rpb24gRCh0LGUpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKWlmKFAodFtuXSxlKSlyZXR1cm4gbjtyZXR1cm4tMX1mdW5jdGlvbiBNKHQpe3ZhciBlPSExO3JldHVybiBmdW5jdGlvbigpe2V8fChlPSEwLHQuYXBwbHkodGhpcyxhcmd1bWVudHMpKX19ZnVuY3Rpb24gSSh0LGUpe3JldHVybiB0PT09ZT8wPT09dCYmMS90IT0xL2U6dD09dHx8ZT09ZX12YXIgTD1cImRhdGEtc2VydmVyLXJlbmRlcmVkXCIsUj1bXCJjb21wb25lbnRcIixcImRpcmVjdGl2ZVwiLFwiZmlsdGVyXCJdLEY9W1wiYmVmb3JlQ3JlYXRlXCIsXCJjcmVhdGVkXCIsXCJiZWZvcmVNb3VudFwiLFwibW91bnRlZFwiLFwiYmVmb3JlVXBkYXRlXCIsXCJ1cGRhdGVkXCIsXCJiZWZvcmVEZXN0cm95XCIsXCJkZXN0cm95ZWRcIixcImFjdGl2YXRlZFwiLFwiZGVhY3RpdmF0ZWRcIixcImVycm9yQ2FwdHVyZWRcIixcInNlcnZlclByZWZldGNoXCIsXCJyZW5kZXJUcmFja2VkXCIsXCJyZW5kZXJUcmlnZ2VyZWRcIl0sSD17b3B0aW9uTWVyZ2VTdHJhdGVnaWVzOk9iamVjdC5jcmVhdGUobnVsbCksc2lsZW50OiExLHByb2R1Y3Rpb25UaXA6ITEsZGV2dG9vbHM6ITEscGVyZm9ybWFuY2U6ITEsZXJyb3JIYW5kbGVyOm51bGwsd2FybkhhbmRsZXI6bnVsbCxpZ25vcmVkRWxlbWVudHM6W10sa2V5Q29kZXM6T2JqZWN0LmNyZWF0ZShudWxsKSxpc1Jlc2VydmVkVGFnOkUsaXNSZXNlcnZlZEF0dHI6RSxpc1Vua25vd25FbGVtZW50OkUsZ2V0VGFnTmFtZXNwYWNlOmoscGFyc2VQbGF0Zm9ybVRhZ05hbWU6TixtdXN0VXNlUHJvcDpFLGFzeW5jOiEwLF9saWZlY3ljbGVIb29rczpGfSxCPS9hLXpBLVpcXHUwMEI3XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjAzRi1cXHUyMDQwXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZELztmdW5jdGlvbiBVKHQpe3ZhciBlPSh0K1wiXCIpLmNoYXJDb2RlQXQoMCk7cmV0dXJuIDM2PT09ZXx8OTU9PT1lfWZ1bmN0aW9uIHoodCxlLG4scil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bixlbnVtZXJhYmxlOiEhcix3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9KX12YXIgVj1uZXcgUmVnRXhwKFwiW15cIi5jb25jYXQoQi5zb3VyY2UsXCIuJF9cXFxcZF1cIikpO3ZhciBLPVwiX19wcm90b19fXCJpbnt9LEo9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyxxPUomJndpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksVz1xJiYvbXNpZXx0cmlkZW50Ly50ZXN0KHEpLFo9cSYmcS5pbmRleE9mKFwibXNpZSA5LjBcIik+MCxHPXEmJnEuaW5kZXhPZihcImVkZ2UvXCIpPjA7cSYmcS5pbmRleE9mKFwiYW5kcm9pZFwiKTt2YXIgWD1xJiYvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QocSk7cSYmL2Nocm9tZVxcL1xcZCsvLnRlc3QocSkscSYmL3BoYW50b21qcy8udGVzdChxKTt2YXIgWSxRPXEmJnEubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSx0dD17fS53YXRjaCxldD0hMTtpZihKKXRyeXt2YXIgbnQ9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KG50LFwicGFzc2l2ZVwiLHtnZXQ6ZnVuY3Rpb24oKXtldD0hMH19KSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRlc3QtcGFzc2l2ZVwiLG51bGwsbnQpfWNhdGNoKHQpe312YXIgcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwPT09WSYmKFk9IUomJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWwmJihnbG9iYWwucHJvY2VzcyYmXCJzZXJ2ZXJcIj09PWdsb2JhbC5wcm9jZXNzLmVudi5WVUVfRU5WKSksWX0sb3Q9SiYmd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187ZnVuY3Rpb24gaXQodCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmL25hdGl2ZSBjb2RlLy50ZXN0KHQudG9TdHJpbmcoKSl9dmFyIGF0LHN0PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJml0KFN5bWJvbCkmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBSZWZsZWN0JiZpdChSZWZsZWN0Lm93bktleXMpO2F0PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTZXQmJml0KFNldCk/U2V0OmZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMuc2V0PU9iamVjdC5jcmVhdGUobnVsbCl9cmV0dXJuIHQucHJvdG90eXBlLmhhcz1mdW5jdGlvbih0KXtyZXR1cm4hMD09PXRoaXMuc2V0W3RdfSx0LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7dGhpcy5zZXRbdF09ITB9LHQucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5zZXQ9T2JqZWN0LmNyZWF0ZShudWxsKX0sdH0oKTt2YXIgY3Q9bnVsbDtmdW5jdGlvbiB1dCh0KXt2b2lkIDA9PT10JiYodD1udWxsKSx0fHxjdCYmY3QuX3Njb3BlLm9mZigpLGN0PXQsdCYmdC5fc2NvcGUub24oKX12YXIgbHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxuLHIsbyxpLGEscyl7dGhpcy50YWc9dCx0aGlzLmRhdGE9ZSx0aGlzLmNoaWxkcmVuPW4sdGhpcy50ZXh0PXIsdGhpcy5lbG09byx0aGlzLm5zPXZvaWQgMCx0aGlzLmNvbnRleHQ9aSx0aGlzLmZuQ29udGV4dD12b2lkIDAsdGhpcy5mbk9wdGlvbnM9dm9pZCAwLHRoaXMuZm5TY29wZUlkPXZvaWQgMCx0aGlzLmtleT1lJiZlLmtleSx0aGlzLmNvbXBvbmVudE9wdGlvbnM9YSx0aGlzLmNvbXBvbmVudEluc3RhbmNlPXZvaWQgMCx0aGlzLnBhcmVudD12b2lkIDAsdGhpcy5yYXc9ITEsdGhpcy5pc1N0YXRpYz0hMSx0aGlzLmlzUm9vdEluc2VydD0hMCx0aGlzLmlzQ29tbWVudD0hMSx0aGlzLmlzQ2xvbmVkPSExLHRoaXMuaXNPbmNlPSExLHRoaXMuYXN5bmNGYWN0b3J5PXMsdGhpcy5hc3luY01ldGE9dm9pZCAwLHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyPSExfXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJjaGlsZFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZX0sZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITB9KSx0fSgpLGZ0PWZ1bmN0aW9uKHQpe3ZvaWQgMD09PXQmJih0PVwiXCIpO3ZhciBlPW5ldyBsdDtyZXR1cm4gZS50ZXh0PXQsZS5pc0NvbW1lbnQ9ITAsZX07ZnVuY3Rpb24gZHQodCl7cmV0dXJuIG5ldyBsdCh2b2lkIDAsdm9pZCAwLHZvaWQgMCxTdHJpbmcodCkpfWZ1bmN0aW9uIHB0KHQpe3ZhciBlPW5ldyBsdCh0LnRhZyx0LmRhdGEsdC5jaGlsZHJlbiYmdC5jaGlsZHJlbi5zbGljZSgpLHQudGV4dCx0LmVsbSx0LmNvbnRleHQsdC5jb21wb25lbnRPcHRpb25zLHQuYXN5bmNGYWN0b3J5KTtyZXR1cm4gZS5ucz10Lm5zLGUuaXNTdGF0aWM9dC5pc1N0YXRpYyxlLmtleT10LmtleSxlLmlzQ29tbWVudD10LmlzQ29tbWVudCxlLmZuQ29udGV4dD10LmZuQ29udGV4dCxlLmZuT3B0aW9ucz10LmZuT3B0aW9ucyxlLmZuU2NvcGVJZD10LmZuU2NvcGVJZCxlLmFzeW5jTWV0YT10LmFzeW5jTWV0YSxlLmlzQ2xvbmVkPSEwLGV9dmFyIHZ0PTAsaHQ9W10sbXQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5fcGVuZGluZz0hMSx0aGlzLmlkPXZ0KyssdGhpcy5zdWJzPVtdfXJldHVybiB0LnByb3RvdHlwZS5hZGRTdWI9ZnVuY3Rpb24odCl7dGhpcy5zdWJzLnB1c2godCl9LHQucHJvdG90eXBlLnJlbW92ZVN1Yj1mdW5jdGlvbih0KXt0aGlzLnN1YnNbdGhpcy5zdWJzLmluZGV4T2YodCldPW51bGwsdGhpcy5fcGVuZGluZ3x8KHRoaXMuX3BlbmRpbmc9ITAsaHQucHVzaCh0aGlzKSl9LHQucHJvdG90eXBlLmRlcGVuZD1mdW5jdGlvbihlKXt0LnRhcmdldCYmdC50YXJnZXQuYWRkRGVwKHRoaXMpfSx0LnByb3RvdHlwZS5ub3RpZnk9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuc3Vicy5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkpLG49MCxyPWUubGVuZ3RoO248cjtuKyspe2Vbbl0udXBkYXRlKCl9fSx0fSgpO210LnRhcmdldD1udWxsO3ZhciBndD1bXTtmdW5jdGlvbiB5dCh0KXtndC5wdXNoKHQpLG10LnRhcmdldD10fWZ1bmN0aW9uIF90KCl7Z3QucG9wKCksbXQudGFyZ2V0PWd0W2d0Lmxlbmd0aC0xXX12YXIgYnQ9QXJyYXkucHJvdG90eXBlLCR0PU9iamVjdC5jcmVhdGUoYnQpO1tcInB1c2hcIixcInBvcFwiLFwic2hpZnRcIixcInVuc2hpZnRcIixcInNwbGljZVwiLFwic29ydFwiLFwicmV2ZXJzZVwiXS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT1idFt0XTt6KCR0LHQsKGZ1bmN0aW9uKCl7Zm9yKHZhciBuPVtdLHI9MDtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKW5bcl09YXJndW1lbnRzW3JdO3ZhciBvLGk9ZS5hcHBseSh0aGlzLG4pLGE9dGhpcy5fX29iX187c3dpdGNoKHQpe2Nhc2VcInB1c2hcIjpjYXNlXCJ1bnNoaWZ0XCI6bz1uO2JyZWFrO2Nhc2VcInNwbGljZVwiOm89bi5zbGljZSgyKX1yZXR1cm4gbyYmYS5vYnNlcnZlQXJyYXkobyksYS5kZXAubm90aWZ5KCksaX0pKX0pKTt2YXIgd3Q9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoJHQpLHh0PXt9LEN0PSEwO2Z1bmN0aW9uIGt0KHQpe0N0PXR9dmFyIFN0PXtub3RpZnk6aixkZXBlbmQ6aixhZGRTdWI6aixyZW1vdmVTdWI6an0sT3Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsbixyKXtpZih2b2lkIDA9PT1uJiYobj0hMSksdm9pZCAwPT09ciYmKHI9ITEpLHRoaXMudmFsdWU9dCx0aGlzLnNoYWxsb3c9bix0aGlzLm1vY2s9cix0aGlzLmRlcD1yP1N0Om5ldyBtdCx0aGlzLnZtQ291bnQ9MCx6KHQsXCJfX29iX19cIix0aGlzKSxlKHQpKXtpZighcilpZihLKXQuX19wcm90b19fPSR0O2Vsc2UgZm9yKHZhciBvPTAsaT13dC5sZW5ndGg7bzxpO28rKyl7eih0LHM9d3Rbb10sJHRbc10pfW58fHRoaXMub2JzZXJ2ZUFycmF5KHQpfWVsc2V7dmFyIGE9T2JqZWN0LmtleXModCk7Zm9yKG89MDtvPGEubGVuZ3RoO28rKyl7dmFyIHM7QXQodCxzPWFbb10seHQsdm9pZCAwLG4scil9fX1yZXR1cm4gdC5wcm90b3R5cGUub2JzZXJ2ZUFycmF5PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49dC5sZW5ndGg7ZTxuO2UrKylUdCh0W2VdLCExLHRoaXMubW9jayl9LHR9KCk7ZnVuY3Rpb24gVHQodCxuLHIpe3JldHVybiB0JiZfKHQsXCJfX29iX19cIikmJnQuX19vYl9fIGluc3RhbmNlb2YgT3Q/dC5fX29iX186IUN0fHwhciYmcnQoKXx8IWUodCkmJiF1KHQpfHwhT2JqZWN0LmlzRXh0ZW5zaWJsZSh0KXx8dC5fX3Zfc2tpcHx8RnQodCl8fHQgaW5zdGFuY2VvZiBsdD92b2lkIDA6bmV3IE90KHQsbixyKX1mdW5jdGlvbiBBdCh0LG4scixvLGksYSl7dmFyIHM9bmV3IG10LGM9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG4pO2lmKCFjfHwhMSE9PWMuY29uZmlndXJhYmxlKXt2YXIgdT1jJiZjLmdldCxsPWMmJmMuc2V0O3UmJiFsfHxyIT09eHQmJjIhPT1hcmd1bWVudHMubGVuZ3RofHwocj10W25dKTt2YXIgZj0haSYmVHQociwhMSxhKTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7dmFyIG49dT91LmNhbGwodCk6cjtyZXR1cm4gbXQudGFyZ2V0JiYocy5kZXBlbmQoKSxmJiYoZi5kZXAuZGVwZW5kKCksZShuKSYmTnQobikpKSxGdChuKSYmIWk/bi52YWx1ZTpufSxzZXQ6ZnVuY3Rpb24oZSl7dmFyIG49dT91LmNhbGwodCk6cjtpZihJKG4sZSkpe2lmKGwpbC5jYWxsKHQsZSk7ZWxzZXtpZih1KXJldHVybjtpZighaSYmRnQobikmJiFGdChlKSlyZXR1cm4gdm9pZChuLnZhbHVlPWUpO3I9ZX1mPSFpJiZUdChlLCExLGEpLHMubm90aWZ5KCl9fX0pLHN9fWZ1bmN0aW9uIGp0KHQsbixyKXtpZighTHQodCkpe3ZhciBvPXQuX19vYl9fO3JldHVybiBlKHQpJiZsKG4pPyh0Lmxlbmd0aD1NYXRoLm1heCh0Lmxlbmd0aCxuKSx0LnNwbGljZShuLDEsciksbyYmIW8uc2hhbGxvdyYmby5tb2NrJiZUdChyLCExLCEwKSxyKTpuIGluIHQmJiEobiBpbiBPYmplY3QucHJvdG90eXBlKT8odFtuXT1yLHIpOnQuX2lzVnVlfHxvJiZvLnZtQ291bnQ/cjpvPyhBdChvLnZhbHVlLG4scix2b2lkIDAsby5zaGFsbG93LG8ubW9jayksby5kZXAubm90aWZ5KCkscik6KHRbbl09cixyKX19ZnVuY3Rpb24gRXQodCxuKXtpZihlKHQpJiZsKG4pKXQuc3BsaWNlKG4sMSk7ZWxzZXt2YXIgcj10Ll9fb2JfXzt0Ll9pc1Z1ZXx8ciYmci52bUNvdW50fHxMdCh0KXx8Xyh0LG4pJiYoZGVsZXRlIHRbbl0sciYmci5kZXAubm90aWZ5KCkpfX1mdW5jdGlvbiBOdCh0KXtmb3IodmFyIG49dm9pZCAwLHI9MCxvPXQubGVuZ3RoO3I8bztyKyspKG49dFtyXSkmJm4uX19vYl9fJiZuLl9fb2JfXy5kZXAuZGVwZW5kKCksZShuKSYmTnQobil9ZnVuY3Rpb24gUHQodCl7cmV0dXJuIER0KHQsITApLHoodCxcIl9fdl9pc1NoYWxsb3dcIiwhMCksdH1mdW5jdGlvbiBEdCh0LGUpe0x0KHQpfHxUdCh0LGUscnQoKSl9ZnVuY3Rpb24gTXQodCl7cmV0dXJuIEx0KHQpP010KHQuX192X3Jhdyk6ISghdHx8IXQuX19vYl9fKX1mdW5jdGlvbiBJdCh0KXtyZXR1cm4hKCF0fHwhdC5fX3ZfaXNTaGFsbG93KX1mdW5jdGlvbiBMdCh0KXtyZXR1cm4hKCF0fHwhdC5fX3ZfaXNSZWFkb25seSl9dmFyIFJ0PVwiX192X2lzUmVmXCI7ZnVuY3Rpb24gRnQodCl7cmV0dXJuISghdHx8ITAhPT10Ll9fdl9pc1JlZil9ZnVuY3Rpb24gSHQodCxlKXtpZihGdCh0KSlyZXR1cm4gdDt2YXIgbj17fTtyZXR1cm4geihuLFJ0LCEwKSx6KG4sXCJfX3ZfaXNTaGFsbG93XCIsZSkseihuLFwiZGVwXCIsQXQobixcInZhbHVlXCIsdCxudWxsLGUscnQoKSkpLG59ZnVuY3Rpb24gQnQodCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4se2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3ZhciB0PWVbbl07aWYoRnQodCkpcmV0dXJuIHQudmFsdWU7dmFyIHI9dCYmdC5fX29iX187cmV0dXJuIHImJnIuZGVwLmRlcGVuZCgpLHR9LHNldDpmdW5jdGlvbih0KXt2YXIgcj1lW25dO0Z0KHIpJiYhRnQodCk/ci52YWx1ZT10OmVbbl09dH19KX1mdW5jdGlvbiBVdCh0LGUsbil7dmFyIHI9dFtlXTtpZihGdChyKSlyZXR1cm4gcjt2YXIgbz17Z2V0IHZhbHVlKCl7dmFyIHI9dFtlXTtyZXR1cm4gdm9pZCAwPT09cj9uOnJ9LHNldCB2YWx1ZShuKXt0W2VdPW59fTtyZXR1cm4geihvLFJ0LCEwKSxvfWZ1bmN0aW9uIHp0KHQpe3JldHVybiBWdCh0LCExKX1mdW5jdGlvbiBWdCh0LGUpe2lmKCF1KHQpKXJldHVybiB0O2lmKEx0KHQpKXJldHVybiB0O3ZhciBuPWU/XCJfX3ZfcmF3VG9TaGFsbG93UmVhZG9ubHlcIjpcIl9fdl9yYXdUb1JlYWRvbmx5XCIscj10W25dO2lmKHIpcmV0dXJuIHI7dmFyIG89T2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpO3oodCxuLG8pLHoobyxcIl9fdl9pc1JlYWRvbmx5XCIsITApLHoobyxcIl9fdl9yYXdcIix0KSxGdCh0KSYmeihvLFJ0LCEwKSwoZXx8SXQodCkpJiZ6KG8sXCJfX3ZfaXNTaGFsbG93XCIsITApO2Zvcih2YXIgaT1PYmplY3Qua2V5cyh0KSxhPTA7YTxpLmxlbmd0aDthKyspS3Qobyx0LGlbYV0sZSk7cmV0dXJuIG99ZnVuY3Rpb24gS3QodCxlLG4scil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7dmFyIHQ9ZVtuXTtyZXR1cm4gcnx8IXUodCk/dDp6dCh0KX0sc2V0OmZ1bmN0aW9uKCl7fX0pfXZhciBKdD1iKChmdW5jdGlvbih0KXt2YXIgZT1cIiZcIj09PXQuY2hhckF0KDApLG49XCJ+XCI9PT0odD1lP3Quc2xpY2UoMSk6dCkuY2hhckF0KDApLHI9XCIhXCI9PT0odD1uP3Quc2xpY2UoMSk6dCkuY2hhckF0KDApO3JldHVybntuYW1lOnQ9cj90LnNsaWNlKDEpOnQsb25jZTpuLGNhcHR1cmU6cixwYXNzaXZlOmV9fSkpO2Z1bmN0aW9uIHF0KHQsbil7ZnVuY3Rpb24gcigpe3ZhciB0PXIuZm5zO2lmKCFlKHQpKXJldHVybiBkbih0LG51bGwsYXJndW1lbnRzLG4sXCJ2LW9uIGhhbmRsZXJcIik7Zm9yKHZhciBvPXQuc2xpY2UoKSxpPTA7aTxvLmxlbmd0aDtpKyspZG4ob1tpXSxudWxsLGFyZ3VtZW50cyxuLFwidi1vbiBoYW5kbGVyXCIpfXJldHVybiByLmZucz10LHJ9ZnVuY3Rpb24gV3QodCxlLHIsaSxhLHMpe3ZhciBjLHUsbCxmO2ZvcihjIGluIHQpdT10W2NdLGw9ZVtjXSxmPUp0KGMpLG4odSl8fChuKGwpPyhuKHUuZm5zKSYmKHU9dFtjXT1xdCh1LHMpKSxvKGYub25jZSkmJih1PXRbY109YShmLm5hbWUsdSxmLmNhcHR1cmUpKSxyKGYubmFtZSx1LGYuY2FwdHVyZSxmLnBhc3NpdmUsZi5wYXJhbXMpKTp1IT09bCYmKGwuZm5zPXUsdFtjXT1sKSk7Zm9yKGMgaW4gZSluKHRbY10pJiZpKChmPUp0KGMpKS5uYW1lLGVbY10sZi5jYXB0dXJlKX1mdW5jdGlvbiBadCh0LGUsaSl7dmFyIGE7dCBpbnN0YW5jZW9mIGx0JiYodD10LmRhdGEuaG9va3x8KHQuZGF0YS5ob29rPXt9KSk7dmFyIHM9dFtlXTtmdW5jdGlvbiBjKCl7aS5hcHBseSh0aGlzLGFyZ3VtZW50cyksZyhhLmZucyxjKX1uKHMpP2E9cXQoW2NdKTpyKHMuZm5zKSYmbyhzLm1lcmdlZCk/KGE9cykuZm5zLnB1c2goYyk6YT1xdChbcyxjXSksYS5tZXJnZWQ9ITAsdFtlXT1hfWZ1bmN0aW9uIEd0KHQsZSxuLG8saSl7aWYocihlKSl7aWYoXyhlLG4pKXJldHVybiB0W25dPWVbbl0saXx8ZGVsZXRlIGVbbl0sITA7aWYoXyhlLG8pKXJldHVybiB0W25dPWVbb10saXx8ZGVsZXRlIGVbb10sITB9cmV0dXJuITF9ZnVuY3Rpb24gWHQodCl7cmV0dXJuIGkodCk/W2R0KHQpXTplKHQpP1F0KHQpOnZvaWQgMH1mdW5jdGlvbiBZdCh0KXtyZXR1cm4gcih0KSYmcih0LnRleHQpJiYhMT09PXQuaXNDb21tZW50fWZ1bmN0aW9uIFF0KHQsYSl7dmFyIHMsYyx1LGwsZj1bXTtmb3Iocz0wO3M8dC5sZW5ndGg7cysrKW4oYz10W3NdKXx8XCJib29sZWFuXCI9PXR5cGVvZiBjfHwobD1mW3U9Zi5sZW5ndGgtMV0sZShjKT9jLmxlbmd0aD4wJiYoWXQoKGM9UXQoYyxcIlwiLmNvbmNhdChhfHxcIlwiLFwiX1wiKS5jb25jYXQocykpKVswXSkmJll0KGwpJiYoZlt1XT1kdChsLnRleHQrY1swXS50ZXh0KSxjLnNoaWZ0KCkpLGYucHVzaC5hcHBseShmLGMpKTppKGMpP1l0KGwpP2ZbdV09ZHQobC50ZXh0K2MpOlwiXCIhPT1jJiZmLnB1c2goZHQoYykpOll0KGMpJiZZdChsKT9mW3VdPWR0KGwudGV4dCtjLnRleHQpOihvKHQuX2lzVkxpc3QpJiZyKGMudGFnKSYmbihjLmtleSkmJnIoYSkmJihjLmtleT1cIl9fdmxpc3RcIi5jb25jYXQoYSxcIl9cIikuY29uY2F0KHMsXCJfX1wiKSksZi5wdXNoKGMpKSk7cmV0dXJuIGZ9ZnVuY3Rpb24gdGUodCxuLGMsdSxsLGYpe3JldHVybihlKGMpfHxpKGMpKSYmKGw9dSx1PWMsYz12b2lkIDApLG8oZikmJihsPTIpLGZ1bmN0aW9uKHQsbixvLGksYyl7aWYocihvKSYmcihvLl9fb2JfXykpcmV0dXJuIGZ0KCk7cihvKSYmcihvLmlzKSYmKG49by5pcyk7aWYoIW4pcmV0dXJuIGZ0KCk7ZShpKSYmYShpWzBdKSYmKChvPW98fHt9KS5zY29wZWRTbG90cz17ZGVmYXVsdDppWzBdfSxpLmxlbmd0aD0wKTsyPT09Yz9pPVh0KGkpOjE9PT1jJiYoaT1mdW5jdGlvbih0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKylpZihlKHRbbl0pKXJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLHQpO3JldHVybiB0fShpKSk7dmFyIHUsbDtpZihcInN0cmluZ1wiPT10eXBlb2Ygbil7dmFyIGY9dm9pZCAwO2w9dC4kdm5vZGUmJnQuJHZub2RlLm5zfHxILmdldFRhZ05hbWVzcGFjZShuKSx1PUguaXNSZXNlcnZlZFRhZyhuKT9uZXcgbHQoSC5wYXJzZVBsYXRmb3JtVGFnTmFtZShuKSxvLGksdm9pZCAwLHZvaWQgMCx0KTpvJiZvLnByZXx8IXIoZj15cih0LiRvcHRpb25zLFwiY29tcG9uZW50c1wiLG4pKT9uZXcgbHQobixvLGksdm9pZCAwLHZvaWQgMCx0KTpjcihmLG8sdCxpLG4pfWVsc2UgdT1jcihuLG8sdCxpKTtyZXR1cm4gZSh1KT91OnIodSk/KHIobCkmJmVlKHUsbCkscihvKSYmZnVuY3Rpb24odCl7cyh0LnN0eWxlKSYmQm4odC5zdHlsZSk7cyh0LmNsYXNzKSYmQm4odC5jbGFzcyl9KG8pLHUpOmZ0KCl9KHQsbixjLHUsbCl9ZnVuY3Rpb24gZWUodCxlLGkpe2lmKHQubnM9ZSxcImZvcmVpZ25PYmplY3RcIj09PXQudGFnJiYoZT12b2lkIDAsaT0hMCkscih0LmNoaWxkcmVuKSlmb3IodmFyIGE9MCxzPXQuY2hpbGRyZW4ubGVuZ3RoO2E8czthKyspe3ZhciBjPXQuY2hpbGRyZW5bYV07cihjLnRhZykmJihuKGMubnMpfHxvKGkpJiZcInN2Z1wiIT09Yy50YWcpJiZlZShjLGUsaSl9fWZ1bmN0aW9uIG5lKHQsbil7dmFyIG8saSxhLGMsdT1udWxsO2lmKGUodCl8fFwic3RyaW5nXCI9PXR5cGVvZiB0KWZvcih1PW5ldyBBcnJheSh0Lmxlbmd0aCksbz0wLGk9dC5sZW5ndGg7bzxpO28rKyl1W29dPW4odFtvXSxvKTtlbHNlIGlmKFwibnVtYmVyXCI9PXR5cGVvZiB0KWZvcih1PW5ldyBBcnJheSh0KSxvPTA7bzx0O28rKyl1W29dPW4obysxLG8pO2Vsc2UgaWYocyh0KSlpZihzdCYmdFtTeW1ib2wuaXRlcmF0b3JdKXt1PVtdO2Zvcih2YXIgbD10W1N5bWJvbC5pdGVyYXRvcl0oKSxmPWwubmV4dCgpOyFmLmRvbmU7KXUucHVzaChuKGYudmFsdWUsdS5sZW5ndGgpKSxmPWwubmV4dCgpfWVsc2UgZm9yKGE9T2JqZWN0LmtleXModCksdT1uZXcgQXJyYXkoYS5sZW5ndGgpLG89MCxpPWEubGVuZ3RoO288aTtvKyspYz1hW29dLHVbb109bih0W2NdLGMsbyk7cmV0dXJuIHIodSl8fCh1PVtdKSx1Ll9pc1ZMaXN0PSEwLHV9ZnVuY3Rpb24gcmUodCxlLG4scil7dmFyIG8saT10aGlzLiRzY29wZWRTbG90c1t0XTtpPyhuPW58fHt9LHImJihuPVQoVCh7fSxyKSxuKSksbz1pKG4pfHwoYShlKT9lKCk6ZSkpOm89dGhpcy4kc2xvdHNbdF18fChhKGUpP2UoKTplKTt2YXIgcz1uJiZuLnNsb3Q7cmV0dXJuIHM/dGhpcy4kY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIse3Nsb3Q6c30sbyk6b31mdW5jdGlvbiBvZSh0KXtyZXR1cm4geXIodGhpcy4kb3B0aW9ucyxcImZpbHRlcnNcIix0KXx8Tn1mdW5jdGlvbiBpZSh0LG4pe3JldHVybiBlKHQpPy0xPT09dC5pbmRleE9mKG4pOnQhPT1ufWZ1bmN0aW9uIGFlKHQsZSxuLHIsbyl7dmFyIGk9SC5rZXlDb2Rlc1tlXXx8bjtyZXR1cm4gbyYmciYmIUgua2V5Q29kZXNbZV0/aWUobyxyKTppP2llKGksdCk6cj9rKHIpIT09ZTp2b2lkIDA9PT10fWZ1bmN0aW9uIHNlKHQsbixyLG8saSl7aWYocilpZihzKHIpKXtlKHIpJiYocj1BKHIpKTt2YXIgYT12b2lkIDAsYz1mdW5jdGlvbihlKXtpZihcImNsYXNzXCI9PT1lfHxcInN0eWxlXCI9PT1lfHxtKGUpKWE9dDtlbHNle3ZhciBzPXQuYXR0cnMmJnQuYXR0cnMudHlwZTthPW98fEgubXVzdFVzZVByb3AobixzLGUpP3QuZG9tUHJvcHN8fCh0LmRvbVByb3BzPXt9KTp0LmF0dHJzfHwodC5hdHRycz17fSl9dmFyIGM9dyhlKSx1PWsoZSk7YyBpbiBhfHx1IGluIGF8fChhW2VdPXJbZV0saSYmKCh0Lm9ufHwodC5vbj17fSkpW1widXBkYXRlOlwiLmNvbmNhdChlKV09ZnVuY3Rpb24odCl7cltlXT10fSkpfTtmb3IodmFyIHUgaW4gciljKHUpfWVsc2U7cmV0dXJuIHR9ZnVuY3Rpb24gY2UodCxlKXt2YXIgbj10aGlzLl9zdGF0aWNUcmVlc3x8KHRoaXMuX3N0YXRpY1RyZWVzPVtdKSxyPW5bdF07cmV0dXJuIHImJiFlfHxsZShyPW5bdF09dGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbdF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSx0aGlzLl9jLHRoaXMpLFwiX19zdGF0aWNfX1wiLmNvbmNhdCh0KSwhMSkscn1mdW5jdGlvbiB1ZSh0LGUsbil7cmV0dXJuIGxlKHQsXCJfX29uY2VfX1wiLmNvbmNhdChlKS5jb25jYXQobj9cIl9cIi5jb25jYXQobik6XCJcIiksITApLHR9ZnVuY3Rpb24gbGUodCxuLHIpe2lmKGUodCkpZm9yKHZhciBvPTA7bzx0Lmxlbmd0aDtvKyspdFtvXSYmXCJzdHJpbmdcIiE9dHlwZW9mIHRbb10mJmZlKHRbb10sXCJcIi5jb25jYXQobixcIl9cIikuY29uY2F0KG8pLHIpO2Vsc2UgZmUodCxuLHIpfWZ1bmN0aW9uIGZlKHQsZSxuKXt0LmlzU3RhdGljPSEwLHQua2V5PWUsdC5pc09uY2U9bn1mdW5jdGlvbiBkZSh0LGUpe2lmKGUpaWYodShlKSl7dmFyIG49dC5vbj10Lm9uP1Qoe30sdC5vbik6e307Zm9yKHZhciByIGluIGUpe3ZhciBvPW5bcl0saT1lW3JdO25bcl09bz9bXS5jb25jYXQobyxpKTppfX1lbHNlO3JldHVybiB0fWZ1bmN0aW9uIHBlKHQsbixyLG8pe249bnx8eyRzdGFibGU6IXJ9O2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7aSsrKXt2YXIgYT10W2ldO2UoYSk/cGUoYSxuLHIpOmEmJihhLnByb3h5JiYoYS5mbi5wcm94eT0hMCksblthLmtleV09YS5mbil9cmV0dXJuIG8mJihuLiRrZXk9byksbn1mdW5jdGlvbiB2ZSh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bis9Mil7dmFyIHI9ZVtuXTtcInN0cmluZ1wiPT10eXBlb2YgciYmciYmKHRbZVtuXV09ZVtuKzFdKX1yZXR1cm4gdH1mdW5jdGlvbiBoZSh0LGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0P2UrdDp0fWZ1bmN0aW9uIG1lKHQpe3QuX289dWUsdC5fbj1wLHQuX3M9ZCx0Ll9sPW5lLHQuX3Q9cmUsdC5fcT1QLHQuX2k9RCx0Ll9tPWNlLHQuX2Y9b2UsdC5faz1hZSx0Ll9iPXNlLHQuX3Y9ZHQsdC5fZT1mdCx0Ll91PXBlLHQuX2c9ZGUsdC5fZD12ZSx0Ll9wPWhlfWZ1bmN0aW9uIGdlKHQsZSl7aWYoIXR8fCF0Lmxlbmd0aClyZXR1cm57fTtmb3IodmFyIG49e30scj0wLG89dC5sZW5ndGg7cjxvO3IrKyl7dmFyIGk9dFtyXSxhPWkuZGF0YTtpZihhJiZhLmF0dHJzJiZhLmF0dHJzLnNsb3QmJmRlbGV0ZSBhLmF0dHJzLnNsb3QsaS5jb250ZXh0IT09ZSYmaS5mbkNvbnRleHQhPT1lfHwhYXx8bnVsbD09YS5zbG90KShuLmRlZmF1bHR8fChuLmRlZmF1bHQ9W10pKS5wdXNoKGkpO2Vsc2V7dmFyIHM9YS5zbG90LGM9bltzXXx8KG5bc109W10pO1widGVtcGxhdGVcIj09PWkudGFnP2MucHVzaC5hcHBseShjLGkuY2hpbGRyZW58fFtdKTpjLnB1c2goaSl9fWZvcih2YXIgdSBpbiBuKW5bdV0uZXZlcnkoeWUpJiZkZWxldGUgblt1XTtyZXR1cm4gbn1mdW5jdGlvbiB5ZSh0KXtyZXR1cm4gdC5pc0NvbW1lbnQmJiF0LmFzeW5jRmFjdG9yeXx8XCIgXCI9PT10LnRleHR9ZnVuY3Rpb24gX2UodCl7cmV0dXJuIHQuaXNDb21tZW50JiZ0LmFzeW5jRmFjdG9yeX1mdW5jdGlvbiBiZShlLG4scixvKXt2YXIgaSxhPU9iamVjdC5rZXlzKHIpLmxlbmd0aD4wLHM9bj8hIW4uJHN0YWJsZTohYSxjPW4mJm4uJGtleTtpZihuKXtpZihuLl9ub3JtYWxpemVkKXJldHVybiBuLl9ub3JtYWxpemVkO2lmKHMmJm8mJm8hPT10JiZjPT09by4ka2V5JiYhYSYmIW8uJGhhc05vcm1hbClyZXR1cm4gbztmb3IodmFyIHUgaW4gaT17fSxuKW5bdV0mJlwiJFwiIT09dVswXSYmKGlbdV09JGUoZSxyLHUsblt1XSkpfWVsc2UgaT17fTtmb3IodmFyIGwgaW4gcilsIGluIGl8fChpW2xdPXdlKHIsbCkpO3JldHVybiBuJiZPYmplY3QuaXNFeHRlbnNpYmxlKG4pJiYobi5fbm9ybWFsaXplZD1pKSx6KGksXCIkc3RhYmxlXCIscykseihpLFwiJGtleVwiLGMpLHooaSxcIiRoYXNOb3JtYWxcIixhKSxpfWZ1bmN0aW9uICRlKHQsbixyLG8pe3ZhciBpPWZ1bmN0aW9uKCl7dmFyIG49Y3Q7dXQodCk7dmFyIHI9YXJndW1lbnRzLmxlbmd0aD9vLmFwcGx5KG51bGwsYXJndW1lbnRzKTpvKHt9KSxpPShyPXImJlwib2JqZWN0XCI9PXR5cGVvZiByJiYhZShyKT9bcl06WHQocikpJiZyWzBdO3JldHVybiB1dChuKSxyJiYoIWl8fDE9PT1yLmxlbmd0aCYmaS5pc0NvbW1lbnQmJiFfZShpKSk/dm9pZCAwOnJ9O3JldHVybiBvLnByb3h5JiZPYmplY3QuZGVmaW5lUHJvcGVydHkobixyLHtnZXQ6aSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGl9ZnVuY3Rpb24gd2UodCxlKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdFtlXX19ZnVuY3Rpb24geGUoZSl7cmV0dXJue2dldCBhdHRycygpe2lmKCFlLl9hdHRyc1Byb3h5KXt2YXIgbj1lLl9hdHRyc1Byb3h5PXt9O3oobixcIl92X2F0dHJfcHJveHlcIiwhMCksQ2UobixlLiRhdHRycyx0LGUsXCIkYXR0cnNcIil9cmV0dXJuIGUuX2F0dHJzUHJveHl9LGdldCBsaXN0ZW5lcnMoKXtlLl9saXN0ZW5lcnNQcm94eXx8Q2UoZS5fbGlzdGVuZXJzUHJveHk9e30sZS4kbGlzdGVuZXJzLHQsZSxcIiRsaXN0ZW5lcnNcIik7cmV0dXJuIGUuX2xpc3RlbmVyc1Byb3h5fSxnZXQgc2xvdHMoKXtyZXR1cm4gZnVuY3Rpb24odCl7dC5fc2xvdHNQcm94eXx8U2UodC5fc2xvdHNQcm94eT17fSx0LiRzY29wZWRTbG90cyk7cmV0dXJuIHQuX3Nsb3RzUHJveHl9KGUpfSxlbWl0OlMoZS4kZW1pdCxlKSxleHBvc2U6ZnVuY3Rpb24odCl7dCYmT2JqZWN0LmtleXModCkuZm9yRWFjaCgoZnVuY3Rpb24obil7cmV0dXJuIEJ0KGUsdCxuKX0pKX19fWZ1bmN0aW9uIENlKHQsZSxuLHIsbyl7dmFyIGk9ITE7Zm9yKHZhciBhIGluIGUpYSBpbiB0P2VbYV0hPT1uW2FdJiYoaT0hMCk6KGk9ITAsa2UodCxhLHIsbykpO2Zvcih2YXIgYSBpbiB0KWEgaW4gZXx8KGk9ITAsZGVsZXRlIHRbYV0pO3JldHVybiBpfWZ1bmN0aW9uIGtlKHQsZSxuLHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBuW3JdW2VdfX0pfWZ1bmN0aW9uIFNlKHQsZSl7Zm9yKHZhciBuIGluIGUpdFtuXT1lW25dO2Zvcih2YXIgbiBpbiB0KW4gaW4gZXx8ZGVsZXRlIHRbbl19ZnVuY3Rpb24gT2UoKXt2YXIgdD1jdDtyZXR1cm4gdC5fc2V0dXBDb250ZXh0fHwodC5fc2V0dXBDb250ZXh0PXhlKHQpKX12YXIgVGUsQWU9bnVsbDtmdW5jdGlvbiBqZSh0LGUpe3JldHVybih0Ll9fZXNNb2R1bGV8fHN0JiZcIk1vZHVsZVwiPT09dFtTeW1ib2wudG9TdHJpbmdUYWddKSYmKHQ9dC5kZWZhdWx0KSxzKHQpP2UuZXh0ZW5kKHQpOnR9ZnVuY3Rpb24gRWUodCl7aWYoZSh0KSlmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtpZihyKG8pJiYocihvLmNvbXBvbmVudE9wdGlvbnMpfHxfZShvKSkpcmV0dXJuIG99fWZ1bmN0aW9uIE5lKHQsZSl7VGUuJG9uKHQsZSl9ZnVuY3Rpb24gUGUodCxlKXtUZS4kb2ZmKHQsZSl9ZnVuY3Rpb24gRGUodCxlKXt2YXIgbj1UZTtyZXR1cm4gZnVuY3Rpb24gcigpe3ZhciBvPWUuYXBwbHkobnVsbCxhcmd1bWVudHMpO251bGwhPT1vJiZuLiRvZmYodCxyKX19ZnVuY3Rpb24gTWUodCxlLG4pe1RlPXQsV3QoZSxufHx7fSxOZSxQZSxEZSx0KSxUZT12b2lkIDB9dmFyIEllPW51bGw7ZnVuY3Rpb24gTGUodCl7dmFyIGU9SWU7cmV0dXJuIEllPXQsZnVuY3Rpb24oKXtJZT1lfX1mdW5jdGlvbiBSZSh0KXtmb3IoO3QmJih0PXQuJHBhcmVudCk7KWlmKHQuX2luYWN0aXZlKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIEZlKHQsZSl7aWYoZSl7aWYodC5fZGlyZWN0SW5hY3RpdmU9ITEsUmUodCkpcmV0dXJufWVsc2UgaWYodC5fZGlyZWN0SW5hY3RpdmUpcmV0dXJuO2lmKHQuX2luYWN0aXZlfHxudWxsPT09dC5faW5hY3RpdmUpe3QuX2luYWN0aXZlPSExO2Zvcih2YXIgbj0wO248dC4kY2hpbGRyZW4ubGVuZ3RoO24rKylGZSh0LiRjaGlsZHJlbltuXSk7QmUodCxcImFjdGl2YXRlZFwiKX19ZnVuY3Rpb24gSGUodCxlKXtpZighKGUmJih0Ll9kaXJlY3RJbmFjdGl2ZT0hMCxSZSh0KSl8fHQuX2luYWN0aXZlKSl7dC5faW5hY3RpdmU9ITA7Zm9yKHZhciBuPTA7bjx0LiRjaGlsZHJlbi5sZW5ndGg7bisrKUhlKHQuJGNoaWxkcmVuW25dKTtCZSh0LFwiZGVhY3RpdmF0ZWRcIil9fWZ1bmN0aW9uIEJlKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPSEwKSx5dCgpO3ZhciBvPWN0O3ImJnV0KHQpO3ZhciBpPXQuJG9wdGlvbnNbZV0sYT1cIlwiLmNvbmNhdChlLFwiIGhvb2tcIik7aWYoaSlmb3IodmFyIHM9MCxjPWkubGVuZ3RoO3M8YztzKyspZG4oaVtzXSx0LG58fG51bGwsdCxhKTt0Ll9oYXNIb29rRXZlbnQmJnQuJGVtaXQoXCJob29rOlwiK2UpLHImJnV0KG8pLF90KCl9dmFyIFVlPVtdLHplPVtdLFZlPXt9LEtlPSExLEplPSExLHFlPTA7dmFyIFdlPTAsWmU9RGF0ZS5ub3c7aWYoSiYmIVcpe3ZhciBHZT13aW5kb3cucGVyZm9ybWFuY2U7R2UmJlwiZnVuY3Rpb25cIj09dHlwZW9mIEdlLm5vdyYmWmUoKT5kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpLnRpbWVTdGFtcCYmKFplPWZ1bmN0aW9uKCl7cmV0dXJuIEdlLm5vdygpfSl9dmFyIFhlPWZ1bmN0aW9uKHQsZSl7aWYodC5wb3N0KXtpZighZS5wb3N0KXJldHVybiAxfWVsc2UgaWYoZS5wb3N0KXJldHVybi0xO3JldHVybiB0LmlkLWUuaWR9O2Z1bmN0aW9uIFllKCl7dmFyIHQsZTtmb3IoV2U9WmUoKSxKZT0hMCxVZS5zb3J0KFhlKSxxZT0wO3FlPFVlLmxlbmd0aDtxZSsrKSh0PVVlW3FlXSkuYmVmb3JlJiZ0LmJlZm9yZSgpLGU9dC5pZCxWZVtlXT1udWxsLHQucnVuKCk7dmFyIG49emUuc2xpY2UoKSxyPVVlLnNsaWNlKCk7cWU9VWUubGVuZ3RoPXplLmxlbmd0aD0wLFZlPXt9LEtlPUplPSExLGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV0uX2luYWN0aXZlPSEwLEZlKHRbZV0sITApfShuKSxmdW5jdGlvbih0KXt2YXIgZT10Lmxlbmd0aDtmb3IoO2UtLTspe3ZhciBuPXRbZV0scj1uLnZtO3ImJnIuX3dhdGNoZXI9PT1uJiZyLl9pc01vdW50ZWQmJiFyLl9pc0Rlc3Ryb3llZCYmQmUocixcInVwZGF0ZWRcIil9fShyKSxmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8aHQubGVuZ3RoO3QrKyl7dmFyIGU9aHRbdF07ZS5zdWJzPWUuc3Vicy5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkpLGUuX3BlbmRpbmc9ITF9aHQubGVuZ3RoPTB9KCksb3QmJkguZGV2dG9vbHMmJm90LmVtaXQoXCJmbHVzaFwiKX1mdW5jdGlvbiBRZSh0KXt2YXIgZT10LmlkO2lmKG51bGw9PVZlW2VdJiYodCE9PW10LnRhcmdldHx8IXQubm9SZWN1cnNlKSl7aWYoVmVbZV09ITAsSmUpe2Zvcih2YXIgbj1VZS5sZW5ndGgtMTtuPnFlJiZVZVtuXS5pZD50LmlkOyluLS07VWUuc3BsaWNlKG4rMSwwLHQpfWVsc2UgVWUucHVzaCh0KTtLZXx8KEtlPSEwLENuKFllKSl9fXZhciB0bj1cIndhdGNoZXJcIixlbj1cIlwiLmNvbmNhdCh0bixcIiBjYWxsYmFja1wiKSxubj1cIlwiLmNvbmNhdCh0bixcIiBnZXR0ZXJcIikscm49XCJcIi5jb25jYXQodG4sXCIgY2xlYW51cFwiKTtmdW5jdGlvbiBvbih0LGUpe3JldHVybiBjbih0LG51bGwse2ZsdXNoOlwicG9zdFwifSl9dmFyIGFuLHNuPXt9O2Z1bmN0aW9uIGNuKG4scixvKXt2YXIgaT12b2lkIDA9PT1vP3Q6byxzPWkuaW1tZWRpYXRlLGM9aS5kZWVwLHU9aS5mbHVzaCxsPXZvaWQgMD09PXU/XCJwcmVcIjp1O2kub25UcmFjayxpLm9uVHJpZ2dlcjt2YXIgZixkLHA9Y3Qsdj1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPW51bGwpLGRuKHQsbnVsbCxuLHAsZSl9LGg9ITEsbT0hMTtpZihGdChuKT8oZj1mdW5jdGlvbigpe3JldHVybiBuLnZhbHVlfSxoPUl0KG4pKTpNdChuKT8oZj1mdW5jdGlvbigpe3JldHVybiBuLl9fb2JfXy5kZXAuZGVwZW5kKCksbn0sYz0hMCk6ZShuKT8obT0hMCxoPW4uc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIE10KHQpfHxJdCh0KX0pKSxmPWZ1bmN0aW9uKCl7cmV0dXJuIG4ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gRnQodCk/dC52YWx1ZTpNdCh0KT9Cbih0KTphKHQpP3YodCxubik6dm9pZCAwfSkpfSk6Zj1hKG4pP3I/ZnVuY3Rpb24oKXtyZXR1cm4gdihuLG5uKX06ZnVuY3Rpb24oKXtpZighcHx8IXAuX2lzRGVzdHJveWVkKXJldHVybiBkJiZkKCksdihuLHRuLFt5XSl9OmosciYmYyl7dmFyIGc9ZjtmPWZ1bmN0aW9uKCl7cmV0dXJuIEJuKGcoKSl9fXZhciB5PWZ1bmN0aW9uKHQpe2Q9Xy5vblN0b3A9ZnVuY3Rpb24oKXt2KHQscm4pfX07aWYocnQoKSlyZXR1cm4geT1qLHI/cyYmdihyLGVuLFtmKCksbT9bXTp2b2lkIDAseV0pOmYoKSxqO3ZhciBfPW5ldyBWbihjdCxmLGose2xhenk6ITB9KTtfLm5vUmVjdXJzZT0hcjt2YXIgYj1tP1tdOnNuO3JldHVybiBfLnJ1bj1mdW5jdGlvbigpe2lmKF8uYWN0aXZlKWlmKHIpe3ZhciB0PV8uZ2V0KCk7KGN8fGh8fChtP3Quc29tZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gSSh0LGJbZV0pfSkpOkkodCxiKSkpJiYoZCYmZCgpLHYocixlbixbdCxiPT09c24/dm9pZCAwOmIseV0pLGI9dCl9ZWxzZSBfLmdldCgpfSxcInN5bmNcIj09PWw/Xy51cGRhdGU9Xy5ydW46XCJwb3N0XCI9PT1sPyhfLnBvc3Q9ITAsXy51cGRhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gUWUoXyl9KTpfLnVwZGF0ZT1mdW5jdGlvbigpe2lmKHAmJnA9PT1jdCYmIXAuX2lzTW91bnRlZCl7dmFyIHQ9cC5fcHJlV2F0Y2hlcnN8fChwLl9wcmVXYXRjaGVycz1bXSk7dC5pbmRleE9mKF8pPDAmJnQucHVzaChfKX1lbHNlIFFlKF8pfSxyP3M/Xy5ydW4oKTpiPV8uZ2V0KCk6XCJwb3N0XCI9PT1sJiZwP3AuJG9uY2UoXCJob29rOm1vdW50ZWRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gXy5nZXQoKX0pKTpfLmdldCgpLGZ1bmN0aW9uKCl7Xy50ZWFyZG93bigpfX12YXIgdW49ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3ZvaWQgMD09PXQmJih0PSExKSx0aGlzLmRldGFjaGVkPXQsdGhpcy5hY3RpdmU9ITAsdGhpcy5lZmZlY3RzPVtdLHRoaXMuY2xlYW51cHM9W10sdGhpcy5wYXJlbnQ9YW4sIXQmJmFuJiYodGhpcy5pbmRleD0oYW4uc2NvcGVzfHwoYW4uc2NvcGVzPVtdKSkucHVzaCh0aGlzKS0xKX1yZXR1cm4gdC5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKHQpe2lmKHRoaXMuYWN0aXZlKXt2YXIgZT1hbjt0cnl7cmV0dXJuIGFuPXRoaXMsdCgpfWZpbmFsbHl7YW49ZX19fSx0LnByb3RvdHlwZS5vbj1mdW5jdGlvbigpe2FuPXRoaXN9LHQucHJvdG90eXBlLm9mZj1mdW5jdGlvbigpe2FuPXRoaXMucGFyZW50fSx0LnByb3RvdHlwZS5zdG9wPWZ1bmN0aW9uKHQpe2lmKHRoaXMuYWN0aXZlKXt2YXIgZT12b2lkIDAsbj12b2lkIDA7Zm9yKGU9MCxuPXRoaXMuZWZmZWN0cy5sZW5ndGg7ZTxuO2UrKyl0aGlzLmVmZmVjdHNbZV0udGVhcmRvd24oKTtmb3IoZT0wLG49dGhpcy5jbGVhbnVwcy5sZW5ndGg7ZTxuO2UrKyl0aGlzLmNsZWFudXBzW2VdKCk7aWYodGhpcy5zY29wZXMpZm9yKGU9MCxuPXRoaXMuc2NvcGVzLmxlbmd0aDtlPG47ZSsrKXRoaXMuc2NvcGVzW2VdLnN0b3AoITApO2lmKCF0aGlzLmRldGFjaGVkJiZ0aGlzLnBhcmVudCYmIXQpe3ZhciByPXRoaXMucGFyZW50LnNjb3Blcy5wb3AoKTtyJiZyIT09dGhpcyYmKHRoaXMucGFyZW50LnNjb3Blc1t0aGlzLmluZGV4XT1yLHIuaW5kZXg9dGhpcy5pbmRleCl9dGhpcy5wYXJlbnQ9dm9pZCAwLHRoaXMuYWN0aXZlPSExfX0sdH0oKTtmdW5jdGlvbiBsbih0KXt2YXIgZT10Ll9wcm92aWRlZCxuPXQuJHBhcmVudCYmdC4kcGFyZW50Ll9wcm92aWRlZDtyZXR1cm4gbj09PWU/dC5fcHJvdmlkZWQ9T2JqZWN0LmNyZWF0ZShuKTplfWZ1bmN0aW9uIGZuKHQsZSxuKXt5dCgpO3RyeXtpZihlKWZvcih2YXIgcj1lO3I9ci4kcGFyZW50Oyl7dmFyIG89ci4kb3B0aW9ucy5lcnJvckNhcHR1cmVkO2lmKG8pZm9yKHZhciBpPTA7aTxvLmxlbmd0aDtpKyspdHJ5e2lmKCExPT09b1tpXS5jYWxsKHIsdCxlLG4pKXJldHVybn1jYXRjaCh0KXtwbih0LHIsXCJlcnJvckNhcHR1cmVkIGhvb2tcIil9fXBuKHQsZSxuKX1maW5hbGx5e190KCl9fWZ1bmN0aW9uIGRuKHQsZSxuLHIsbyl7dmFyIGk7dHJ5eyhpPW4/dC5hcHBseShlLG4pOnQuY2FsbChlKSkmJiFpLl9pc1Z1ZSYmZihpKSYmIWkuX2hhbmRsZWQmJihpLmNhdGNoKChmdW5jdGlvbih0KXtyZXR1cm4gZm4odCxyLG8rXCIgKFByb21pc2UvYXN5bmMpXCIpfSkpLGkuX2hhbmRsZWQ9ITApfWNhdGNoKHQpe2ZuKHQscixvKX1yZXR1cm4gaX1mdW5jdGlvbiBwbih0LGUsbil7aWYoSC5lcnJvckhhbmRsZXIpdHJ5e3JldHVybiBILmVycm9ySGFuZGxlci5jYWxsKG51bGwsdCxlLG4pfWNhdGNoKGUpe2UhPT10JiZ2bihlKX12bih0KX1mdW5jdGlvbiB2bih0LGUsbil7aWYoIUp8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBjb25zb2xlKXRocm93IHQ7Y29uc29sZS5lcnJvcih0KX12YXIgaG4sbW49ITEsZ249W10seW49ITE7ZnVuY3Rpb24gX24oKXt5bj0hMTt2YXIgdD1nbi5zbGljZSgwKTtnbi5sZW5ndGg9MDtmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdKCl9aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFByb21pc2UmJml0KFByb21pc2UpKXt2YXIgYm49UHJvbWlzZS5yZXNvbHZlKCk7aG49ZnVuY3Rpb24oKXtibi50aGVuKF9uKSxYJiZzZXRUaW1lb3V0KGopfSxtbj0hMH1lbHNlIGlmKFd8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBNdXRhdGlvbk9ic2VydmVyfHwhaXQoTXV0YXRpb25PYnNlcnZlcikmJlwiW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdXCIhPT1NdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkpaG49XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNldEltbWVkaWF0ZSYmaXQoc2V0SW1tZWRpYXRlKT9mdW5jdGlvbigpe3NldEltbWVkaWF0ZShfbil9OmZ1bmN0aW9uKCl7c2V0VGltZW91dChfbiwwKX07ZWxzZXt2YXIgJG49MSx3bj1uZXcgTXV0YXRpb25PYnNlcnZlcihfbikseG49ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKCRuKSk7d24ub2JzZXJ2ZSh4bix7Y2hhcmFjdGVyRGF0YTohMH0pLGhuPWZ1bmN0aW9uKCl7JG49KCRuKzEpJTIseG4uZGF0YT1TdHJpbmcoJG4pfSxtbj0hMH1mdW5jdGlvbiBDbih0LGUpe3ZhciBuO2lmKGduLnB1c2goKGZ1bmN0aW9uKCl7aWYodCl0cnl7dC5jYWxsKGUpfWNhdGNoKHQpe2ZuKHQsZSxcIm5leHRUaWNrXCIpfWVsc2UgbiYmbihlKX0pKSx5bnx8KHluPSEwLGhuKCkpLCF0JiZcInVuZGVmaW5lZFwiIT10eXBlb2YgUHJvbWlzZSlyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHQpe249dH0pKX1mdW5jdGlvbiBrbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxuKXtpZih2b2lkIDA9PT1uJiYobj1jdCksbilyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3ZhciByPXQuJG9wdGlvbnM7cltlXT12cihyW2VdLG4pfShuLHQsZSl9fXZhciBTbj1rbihcImJlZm9yZU1vdW50XCIpLE9uPWtuKFwibW91bnRlZFwiKSxUbj1rbihcImJlZm9yZVVwZGF0ZVwiKSxBbj1rbihcInVwZGF0ZWRcIiksam49a24oXCJiZWZvcmVEZXN0cm95XCIpLEVuPWtuKFwiZGVzdHJveWVkXCIpLE5uPWtuKFwiYWN0aXZhdGVkXCIpLFBuPWtuKFwiZGVhY3RpdmF0ZWRcIiksRG49a24oXCJzZXJ2ZXJQcmVmZXRjaFwiKSxNbj1rbihcInJlbmRlclRyYWNrZWRcIiksSW49a24oXCJyZW5kZXJUcmlnZ2VyZWRcIiksTG49a24oXCJlcnJvckNhcHR1cmVkXCIpO3ZhciBSbj1cIjIuNy4xNFwiO3ZhciBGbj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCx2ZXJzaW9uOlJuLGRlZmluZUNvbXBvbmVudDpmdW5jdGlvbih0KXtyZXR1cm4gdH0scmVmOmZ1bmN0aW9uKHQpe3JldHVybiBIdCh0LCExKX0sc2hhbGxvd1JlZjpmdW5jdGlvbih0KXtyZXR1cm4gSHQodCwhMCl9LGlzUmVmOkZ0LHRvUmVmOlV0LHRvUmVmczpmdW5jdGlvbih0KXt2YXIgbj1lKHQpP25ldyBBcnJheSh0Lmxlbmd0aCk6e307Zm9yKHZhciByIGluIHQpbltyXT1VdCh0LHIpO3JldHVybiBufSx1bnJlZjpmdW5jdGlvbih0KXtyZXR1cm4gRnQodCk/dC52YWx1ZTp0fSxwcm94eVJlZnM6ZnVuY3Rpb24odCl7aWYoTXQodCkpcmV0dXJuIHQ7Zm9yKHZhciBlPXt9LG49T2JqZWN0LmtleXModCkscj0wO3I8bi5sZW5ndGg7cisrKUJ0KGUsdCxuW3JdKTtyZXR1cm4gZX0sY3VzdG9tUmVmOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBtdCxuPXQoKGZ1bmN0aW9uKCl7ZS5kZXBlbmQoKX0pLChmdW5jdGlvbigpe2Uubm90aWZ5KCl9KSkscj1uLmdldCxvPW4uc2V0LGk9e2dldCB2YWx1ZSgpe3JldHVybiByKCl9LHNldCB2YWx1ZSh0KXtvKHQpfX07cmV0dXJuIHooaSxSdCwhMCksaX0sdHJpZ2dlclJlZjpmdW5jdGlvbih0KXt0LmRlcCYmdC5kZXAubm90aWZ5KCl9LHJlYWN0aXZlOmZ1bmN0aW9uKHQpe3JldHVybiBEdCh0LCExKSx0fSxpc1JlYWN0aXZlOk10LGlzUmVhZG9ubHk6THQsaXNTaGFsbG93Okl0LGlzUHJveHk6ZnVuY3Rpb24odCl7cmV0dXJuIE10KHQpfHxMdCh0KX0sc2hhbGxvd1JlYWN0aXZlOlB0LG1hcmtSYXc6ZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5pc0V4dGVuc2libGUodCkmJnoodCxcIl9fdl9za2lwXCIsITApLHR9LHRvUmF3OmZ1bmN0aW9uIHQoZSl7dmFyIG49ZSYmZS5fX3ZfcmF3O3JldHVybiBuP3Qobik6ZX0scmVhZG9ubHk6enQsc2hhbGxvd1JlYWRvbmx5OmZ1bmN0aW9uKHQpe3JldHVybiBWdCh0LCEwKX0sY29tcHV0ZWQ6ZnVuY3Rpb24odCxlKXt2YXIgbixyLG89YSh0KTtvPyhuPXQscj1qKToobj10LmdldCxyPXQuc2V0KTt2YXIgaT1ydCgpP251bGw6bmV3IFZuKGN0LG4saix7bGF6eTohMH0pLHM9e2VmZmVjdDppLGdldCB2YWx1ZSgpe3JldHVybiBpPyhpLmRpcnR5JiZpLmV2YWx1YXRlKCksbXQudGFyZ2V0JiZpLmRlcGVuZCgpLGkudmFsdWUpOm4oKX0sc2V0IHZhbHVlKHQpe3IodCl9fTtyZXR1cm4geihzLFJ0LCEwKSx6KHMsXCJfX3ZfaXNSZWFkb25seVwiLG8pLHN9LHdhdGNoOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gY24odCxlLG4pfSx3YXRjaEVmZmVjdDpmdW5jdGlvbih0LGUpe3JldHVybiBjbih0LG51bGwsZSl9LHdhdGNoUG9zdEVmZmVjdDpvbix3YXRjaFN5bmNFZmZlY3Q6ZnVuY3Rpb24odCxlKXtyZXR1cm4gY24odCxudWxsLHtmbHVzaDpcInN5bmNcIn0pfSxFZmZlY3RTY29wZTp1bixlZmZlY3RTY29wZTpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IHVuKHQpfSxvblNjb3BlRGlzcG9zZTpmdW5jdGlvbih0KXthbiYmYW4uY2xlYW51cHMucHVzaCh0KX0sZ2V0Q3VycmVudFNjb3BlOmZ1bmN0aW9uKCl7cmV0dXJuIGFufSxwcm92aWRlOmZ1bmN0aW9uKHQsZSl7Y3QmJihsbihjdClbdF09ZSl9LGluamVjdDpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49ITEpO3ZhciByPWN0O2lmKHIpe3ZhciBvPXIuJHBhcmVudCYmci4kcGFyZW50Ll9wcm92aWRlZDtpZihvJiZ0IGluIG8pcmV0dXJuIG9bdF07aWYoYXJndW1lbnRzLmxlbmd0aD4xKXJldHVybiBuJiZhKGUpP2UuY2FsbChyKTplfX0saDpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHRlKGN0LHQsZSxuLDIsITApfSxnZXRDdXJyZW50SW5zdGFuY2U6ZnVuY3Rpb24oKXtyZXR1cm4gY3QmJntwcm94eTpjdH19LHVzZVNsb3RzOmZ1bmN0aW9uKCl7cmV0dXJuIE9lKCkuc2xvdHN9LHVzZUF0dHJzOmZ1bmN0aW9uKCl7cmV0dXJuIE9lKCkuYXR0cnN9LHVzZUxpc3RlbmVyczpmdW5jdGlvbigpe3JldHVybiBPZSgpLmxpc3RlbmVyc30sbWVyZ2VEZWZhdWx0czpmdW5jdGlvbih0LG4pe3ZhciByPWUodCk/dC5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbZV09e30sdH0pLHt9KTp0O2Zvcih2YXIgbyBpbiBuKXt2YXIgaT1yW29dO2k/ZShpKXx8YShpKT9yW29dPXt0eXBlOmksZGVmYXVsdDpuW29dfTppLmRlZmF1bHQ9bltvXTpudWxsPT09aSYmKHJbb109e2RlZmF1bHQ6bltvXX0pfXJldHVybiByfSxuZXh0VGljazpDbixzZXQ6anQsZGVsOkV0LHVzZUNzc01vZHVsZTpmdW5jdGlvbihlKXtyZXR1cm4gdH0sdXNlQ3NzVmFyczpmdW5jdGlvbih0KXtpZihKKXt2YXIgZT1jdDtlJiZvbigoZnVuY3Rpb24oKXt2YXIgbj1lLiRlbCxyPXQoZSxlLl9zZXR1cFByb3h5KTtpZihuJiYxPT09bi5ub2RlVHlwZSl7dmFyIG89bi5zdHlsZTtmb3IodmFyIGkgaW4gcilvLnNldFByb3BlcnR5KFwiLS1cIi5jb25jYXQoaSkscltpXSl9fSkpfX0sZGVmaW5lQXN5bmNDb21wb25lbnQ6ZnVuY3Rpb24odCl7YSh0KSYmKHQ9e2xvYWRlcjp0fSk7dmFyIGU9dC5sb2FkZXIsbj10LmxvYWRpbmdDb21wb25lbnQscj10LmVycm9yQ29tcG9uZW50LG89dC5kZWxheSxpPXZvaWQgMD09PW8/MjAwOm8scz10LnRpbWVvdXQ7dC5zdXNwZW5zaWJsZTt2YXIgYz10Lm9uRXJyb3IsdT1udWxsLGw9MCxmPWZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIHV8fCh0PXU9ZSgpLmNhdGNoKChmdW5jdGlvbih0KXtpZih0PXQgaW5zdGFuY2VvZiBFcnJvcj90Om5ldyBFcnJvcihTdHJpbmcodCkpLGMpcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihlLG4pe2ModCwoZnVuY3Rpb24oKXtyZXR1cm4gZSgobCsrLHU9bnVsbCxmKCkpKX0pLChmdW5jdGlvbigpe3JldHVybiBuKHQpfSksbCsxKX0pKTt0aHJvdyB0fSkpLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiB0IT09dSYmdT91OihlJiYoZS5fX2VzTW9kdWxlfHxcIk1vZHVsZVwiPT09ZVtTeW1ib2wudG9TdHJpbmdUYWddKSYmKGU9ZS5kZWZhdWx0KSxlKX0pKSl9O3JldHVybiBmdW5jdGlvbigpe3JldHVybntjb21wb25lbnQ6ZigpLGRlbGF5OmksdGltZW91dDpzLGVycm9yOnIsbG9hZGluZzpufX19LG9uQmVmb3JlTW91bnQ6U24sb25Nb3VudGVkOk9uLG9uQmVmb3JlVXBkYXRlOlRuLG9uVXBkYXRlZDpBbixvbkJlZm9yZVVubW91bnQ6am4sb25Vbm1vdW50ZWQ6RW4sb25BY3RpdmF0ZWQ6Tm4sb25EZWFjdGl2YXRlZDpQbixvblNlcnZlclByZWZldGNoOkRuLG9uUmVuZGVyVHJhY2tlZDpNbixvblJlbmRlclRyaWdnZXJlZDpJbixvbkVycm9yQ2FwdHVyZWQ6ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT1jdCksTG4odCxlKX19KSxIbj1uZXcgYXQ7ZnVuY3Rpb24gQm4odCl7cmV0dXJuIFVuKHQsSG4pLEhuLmNsZWFyKCksdH1mdW5jdGlvbiBVbih0LG4pe3ZhciByLG8saT1lKHQpO2lmKCEoIWkmJiFzKHQpfHx0Ll9fdl9za2lwfHxPYmplY3QuaXNGcm96ZW4odCl8fHQgaW5zdGFuY2VvZiBsdCkpe2lmKHQuX19vYl9fKXt2YXIgYT10Ll9fb2JfXy5kZXAuaWQ7aWYobi5oYXMoYSkpcmV0dXJuO24uYWRkKGEpfWlmKGkpZm9yKHI9dC5sZW5ndGg7ci0tOylVbih0W3JdLG4pO2Vsc2UgaWYoRnQodCkpVW4odC52YWx1ZSxuKTtlbHNlIGZvcihyPShvPU9iamVjdC5rZXlzKHQpKS5sZW5ndGg7ci0tOylVbih0W29bcl1dLG4pfX12YXIgem49MCxWbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLG4scixvKXshZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT1hbiksZSYmZS5hY3RpdmUmJmUuZWZmZWN0cy5wdXNoKHQpfSh0aGlzLGFuJiYhYW4uX3ZtP2FuOnQ/dC5fc2NvcGU6dm9pZCAwKSwodGhpcy52bT10KSYmbyYmKHQuX3dhdGNoZXI9dGhpcykscj8odGhpcy5kZWVwPSEhci5kZWVwLHRoaXMudXNlcj0hIXIudXNlcix0aGlzLmxhenk9ISFyLmxhenksdGhpcy5zeW5jPSEhci5zeW5jLHRoaXMuYmVmb3JlPXIuYmVmb3JlKTp0aGlzLmRlZXA9dGhpcy51c2VyPXRoaXMubGF6eT10aGlzLnN5bmM9ITEsdGhpcy5jYj1uLHRoaXMuaWQ9Kyt6bix0aGlzLmFjdGl2ZT0hMCx0aGlzLnBvc3Q9ITEsdGhpcy5kaXJ0eT10aGlzLmxhenksdGhpcy5kZXBzPVtdLHRoaXMubmV3RGVwcz1bXSx0aGlzLmRlcElkcz1uZXcgYXQsdGhpcy5uZXdEZXBJZHM9bmV3IGF0LHRoaXMuZXhwcmVzc2lvbj1cIlwiLGEoZSk/dGhpcy5nZXR0ZXI9ZToodGhpcy5nZXR0ZXI9ZnVuY3Rpb24odCl7aWYoIVYudGVzdCh0KSl7dmFyIGU9dC5zcGxpdChcIi5cIik7cmV0dXJuIGZ1bmN0aW9uKHQpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXtpZighdClyZXR1cm47dD10W2Vbbl1dfXJldHVybiB0fX19KGUpLHRoaXMuZ2V0dGVyfHwodGhpcy5nZXR0ZXI9aikpLHRoaXMudmFsdWU9dGhpcy5sYXp5P3ZvaWQgMDp0aGlzLmdldCgpfXJldHVybiB0LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXt2YXIgdDt5dCh0aGlzKTt2YXIgZT10aGlzLnZtO3RyeXt0PXRoaXMuZ2V0dGVyLmNhbGwoZSxlKX1jYXRjaCh0KXtpZighdGhpcy51c2VyKXRocm93IHQ7Zm4odCxlLCdnZXR0ZXIgZm9yIHdhdGNoZXIgXCInLmNvbmNhdCh0aGlzLmV4cHJlc3Npb24sJ1wiJykpfWZpbmFsbHl7dGhpcy5kZWVwJiZCbih0KSxfdCgpLHRoaXMuY2xlYW51cERlcHMoKX1yZXR1cm4gdH0sdC5wcm90b3R5cGUuYWRkRGVwPWZ1bmN0aW9uKHQpe3ZhciBlPXQuaWQ7dGhpcy5uZXdEZXBJZHMuaGFzKGUpfHwodGhpcy5uZXdEZXBJZHMuYWRkKGUpLHRoaXMubmV3RGVwcy5wdXNoKHQpLHRoaXMuZGVwSWRzLmhhcyhlKXx8dC5hZGRTdWIodGhpcykpfSx0LnByb3RvdHlwZS5jbGVhbnVwRGVwcz1mdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmRlcHMubGVuZ3RoO3QtLTspe3ZhciBlPXRoaXMuZGVwc1t0XTt0aGlzLm5ld0RlcElkcy5oYXMoZS5pZCl8fGUucmVtb3ZlU3ViKHRoaXMpfXZhciBuPXRoaXMuZGVwSWRzO3RoaXMuZGVwSWRzPXRoaXMubmV3RGVwSWRzLHRoaXMubmV3RGVwSWRzPW4sdGhpcy5uZXdEZXBJZHMuY2xlYXIoKSxuPXRoaXMuZGVwcyx0aGlzLmRlcHM9dGhpcy5uZXdEZXBzLHRoaXMubmV3RGVwcz1uLHRoaXMubmV3RGVwcy5sZW5ndGg9MH0sdC5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy5sYXp5P3RoaXMuZGlydHk9ITA6dGhpcy5zeW5jP3RoaXMucnVuKCk6UWUodGhpcyl9LHQucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe2lmKHRoaXMuYWN0aXZlKXt2YXIgdD10aGlzLmdldCgpO2lmKHQhPT10aGlzLnZhbHVlfHxzKHQpfHx0aGlzLmRlZXApe3ZhciBlPXRoaXMudmFsdWU7aWYodGhpcy52YWx1ZT10LHRoaXMudXNlcil7dmFyIG49J2NhbGxiYWNrIGZvciB3YXRjaGVyIFwiJy5jb25jYXQodGhpcy5leHByZXNzaW9uLCdcIicpO2RuKHRoaXMuY2IsdGhpcy52bSxbdCxlXSx0aGlzLnZtLG4pfWVsc2UgdGhpcy5jYi5jYWxsKHRoaXMudm0sdCxlKX19fSx0LnByb3RvdHlwZS5ldmFsdWF0ZT1mdW5jdGlvbigpe3RoaXMudmFsdWU9dGhpcy5nZXQoKSx0aGlzLmRpcnR5PSExfSx0LnByb3RvdHlwZS5kZXBlbmQ9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5kZXBzLmxlbmd0aDt0LS07KXRoaXMuZGVwc1t0XS5kZXBlbmQoKX0sdC5wcm90b3R5cGUudGVhcmRvd249ZnVuY3Rpb24oKXtpZih0aGlzLnZtJiYhdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCYmZyh0aGlzLnZtLl9zY29wZS5lZmZlY3RzLHRoaXMpLHRoaXMuYWN0aXZlKXtmb3IodmFyIHQ9dGhpcy5kZXBzLmxlbmd0aDt0LS07KXRoaXMuZGVwc1t0XS5yZW1vdmVTdWIodGhpcyk7dGhpcy5hY3RpdmU9ITEsdGhpcy5vblN0b3AmJnRoaXMub25TdG9wKCl9fSx0fSgpLEtuPXtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6aixzZXQ6an07ZnVuY3Rpb24gSm4odCxlLG4pe0tuLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzW2VdW25dfSxLbi5zZXQ9ZnVuY3Rpb24odCl7dGhpc1tlXVtuXT10fSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLEtuKX1mdW5jdGlvbiBxbih0KXt2YXIgbj10LiRvcHRpb25zO2lmKG4ucHJvcHMmJmZ1bmN0aW9uKHQsZSl7dmFyIG49dC4kb3B0aW9ucy5wcm9wc0RhdGF8fHt9LHI9dC5fcHJvcHM9UHQoe30pLG89dC4kb3B0aW9ucy5fcHJvcEtleXM9W107dC4kcGFyZW50JiZrdCghMSk7dmFyIGk9ZnVuY3Rpb24oaSl7by5wdXNoKGkpO3ZhciBhPV9yKGksZSxuLHQpO0F0KHIsaSxhKSxpIGluIHR8fEpuKHQsXCJfcHJvcHNcIixpKX07Zm9yKHZhciBhIGluIGUpaShhKTtrdCghMCl9KHQsbi5wcm9wcyksZnVuY3Rpb24odCl7dmFyIGU9dC4kb3B0aW9ucyxuPWUuc2V0dXA7aWYobil7dmFyIHI9dC5fc2V0dXBDb250ZXh0PXhlKHQpO3V0KHQpLHl0KCk7dmFyIG89ZG4obixudWxsLFt0Ll9wcm9wc3x8UHQoe30pLHJdLHQsXCJzZXR1cFwiKTtpZihfdCgpLHV0KCksYShvKSllLnJlbmRlcj1vO2Vsc2UgaWYocyhvKSlpZih0Ll9zZXR1cFN0YXRlPW8sby5fX3NmYyl7dmFyIGk9dC5fc2V0dXBQcm94eT17fTtmb3IodmFyIGMgaW4gbylcIl9fc2ZjXCIhPT1jJiZCdChpLG8sYyl9ZWxzZSBmb3IodmFyIGMgaW4gbylVKGMpfHxCdCh0LG8sYyl9fSh0KSxuLm1ldGhvZHMmJmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuIGluIHQuJG9wdGlvbnMucHJvcHMsZSl0W25dPVwiZnVuY3Rpb25cIiE9dHlwZW9mIGVbbl0/ajpTKGVbbl0sdCl9KHQsbi5tZXRob2RzKSxuLmRhdGEpIWZ1bmN0aW9uKHQpe3ZhciBlPXQuJG9wdGlvbnMuZGF0YTt1KGU9dC5fZGF0YT1hKGUpP2Z1bmN0aW9uKHQsZSl7eXQoKTt0cnl7cmV0dXJuIHQuY2FsbChlLGUpfWNhdGNoKHQpe3JldHVybiBmbih0LGUsXCJkYXRhKClcIikse319ZmluYWxseXtfdCgpfX0oZSx0KTplfHx7fSl8fChlPXt9KTt2YXIgbj1PYmplY3Qua2V5cyhlKSxyPXQuJG9wdGlvbnMucHJvcHM7dC4kb3B0aW9ucy5tZXRob2RzO3ZhciBvPW4ubGVuZ3RoO2Zvcig7by0tOyl7dmFyIGk9bltvXTtyJiZfKHIsaSl8fFUoaSl8fEpuKHQsXCJfZGF0YVwiLGkpfXZhciBzPVR0KGUpO3MmJnMudm1Db3VudCsrfSh0KTtlbHNle3ZhciByPVR0KHQuX2RhdGE9e30pO3ImJnIudm1Db3VudCsrfW4uY29tcHV0ZWQmJmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5fY29tcHV0ZWRXYXRjaGVycz1PYmplY3QuY3JlYXRlKG51bGwpLHI9cnQoKTtmb3IodmFyIG8gaW4gZSl7dmFyIGk9ZVtvXSxzPWEoaSk/aTppLmdldDtyfHwobltvXT1uZXcgVm4odCxzfHxqLGosV24pKSxvIGluIHR8fFpuKHQsbyxpKX19KHQsbi5jb21wdXRlZCksbi53YXRjaCYmbi53YXRjaCE9PXR0JiZmdW5jdGlvbih0LG4pe2Zvcih2YXIgciBpbiBuKXt2YXIgbz1uW3JdO2lmKGUobykpZm9yKHZhciBpPTA7aTxvLmxlbmd0aDtpKyspWW4odCxyLG9baV0pO2Vsc2UgWW4odCxyLG8pfX0odCxuLndhdGNoKX12YXIgV249e2xhenk6ITB9O2Z1bmN0aW9uIFpuKHQsZSxuKXt2YXIgcj0hcnQoKTthKG4pPyhLbi5nZXQ9cj9HbihlKTpYbihuKSxLbi5zZXQ9aik6KEtuLmdldD1uLmdldD9yJiYhMSE9PW4uY2FjaGU/R24oZSk6WG4obi5nZXQpOmosS24uc2V0PW4uc2V0fHxqKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLEtuKX1mdW5jdGlvbiBHbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT10aGlzLl9jb21wdXRlZFdhdGNoZXJzJiZ0aGlzLl9jb21wdXRlZFdhdGNoZXJzW3RdO2lmKGUpcmV0dXJuIGUuZGlydHkmJmUuZXZhbHVhdGUoKSxtdC50YXJnZXQmJmUuZGVwZW5kKCksZS52YWx1ZX19ZnVuY3Rpb24gWG4odCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuY2FsbCh0aGlzLHRoaXMpfX1mdW5jdGlvbiBZbih0LGUsbixyKXtyZXR1cm4gdShuKSYmKHI9bixuPW4uaGFuZGxlciksXCJzdHJpbmdcIj09dHlwZW9mIG4mJihuPXRbbl0pLHQuJHdhdGNoKGUsbixyKX1mdW5jdGlvbiBRbih0LGUpe2lmKHQpe2Zvcih2YXIgbj1PYmplY3QuY3JlYXRlKG51bGwpLHI9c3Q/UmVmbGVjdC5vd25LZXlzKHQpOk9iamVjdC5rZXlzKHQpLG89MDtvPHIubGVuZ3RoO28rKyl7dmFyIGk9cltvXTtpZihcIl9fb2JfX1wiIT09aSl7dmFyIHM9dFtpXS5mcm9tO2lmKHMgaW4gZS5fcHJvdmlkZWQpbltpXT1lLl9wcm92aWRlZFtzXTtlbHNlIGlmKFwiZGVmYXVsdFwiaW4gdFtpXSl7dmFyIGM9dFtpXS5kZWZhdWx0O25baV09YShjKT9jLmNhbGwoZSk6Y319fXJldHVybiBufX12YXIgdHI9MDtmdW5jdGlvbiBlcih0KXt2YXIgZT10Lm9wdGlvbnM7aWYodC5zdXBlcil7dmFyIG49ZXIodC5zdXBlcik7aWYobiE9PXQuc3VwZXJPcHRpb25zKXt0LnN1cGVyT3B0aW9ucz1uO3ZhciByPWZ1bmN0aW9uKHQpe3ZhciBlLG49dC5vcHRpb25zLHI9dC5zZWFsZWRPcHRpb25zO2Zvcih2YXIgbyBpbiBuKW5bb10hPT1yW29dJiYoZXx8KGU9e30pLGVbb109bltvXSk7cmV0dXJuIGV9KHQpO3ImJlQodC5leHRlbmRPcHRpb25zLHIpLChlPXQub3B0aW9ucz1ncihuLHQuZXh0ZW5kT3B0aW9ucykpLm5hbWUmJihlLmNvbXBvbmVudHNbZS5uYW1lXT10KX19cmV0dXJuIGV9ZnVuY3Rpb24gbnIobixyLGksYSxzKXt2YXIgYyx1PXRoaXMsbD1zLm9wdGlvbnM7XyhhLFwiX3VpZFwiKT8oYz1PYmplY3QuY3JlYXRlKGEpKS5fb3JpZ2luYWw9YTooYz1hLGE9YS5fb3JpZ2luYWwpO3ZhciBmPW8obC5fY29tcGlsZWQpLGQ9IWY7dGhpcy5kYXRhPW4sdGhpcy5wcm9wcz1yLHRoaXMuY2hpbGRyZW49aSx0aGlzLnBhcmVudD1hLHRoaXMubGlzdGVuZXJzPW4ub258fHQsdGhpcy5pbmplY3Rpb25zPVFuKGwuaW5qZWN0LGEpLHRoaXMuc2xvdHM9ZnVuY3Rpb24oKXtyZXR1cm4gdS4kc2xvdHN8fGJlKGEsbi5zY29wZWRTbG90cyx1LiRzbG90cz1nZShpLGEpKSx1LiRzbG90c30sT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJzY29wZWRTbG90c1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBiZShhLG4uc2NvcGVkU2xvdHMsdGhpcy5zbG90cygpKX19KSxmJiYodGhpcy4kb3B0aW9ucz1sLHRoaXMuJHNsb3RzPXRoaXMuc2xvdHMoKSx0aGlzLiRzY29wZWRTbG90cz1iZShhLG4uc2NvcGVkU2xvdHMsdGhpcy4kc2xvdHMpKSxsLl9zY29wZUlkP3RoaXMuX2M9ZnVuY3Rpb24odCxuLHIsbyl7dmFyIGk9dGUoYyx0LG4scixvLGQpO3JldHVybiBpJiYhZShpKSYmKGkuZm5TY29wZUlkPWwuX3Njb3BlSWQsaS5mbkNvbnRleHQ9YSksaX06dGhpcy5fYz1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gdGUoYyx0LGUsbixyLGQpfX1mdW5jdGlvbiBycih0LGUsbixyLG8pe3ZhciBpPXB0KHQpO3JldHVybiBpLmZuQ29udGV4dD1uLGkuZm5PcHRpb25zPXIsZS5zbG90JiYoKGkuZGF0YXx8KGkuZGF0YT17fSkpLnNsb3Q9ZS5zbG90KSxpfWZ1bmN0aW9uIG9yKHQsZSl7Zm9yKHZhciBuIGluIGUpdFt3KG4pXT1lW25dfWZ1bmN0aW9uIGlyKHQpe3JldHVybiB0Lm5hbWV8fHQuX19uYW1lfHx0Ll9jb21wb25lbnRUYWd9bWUobnIucHJvdG90eXBlKTt2YXIgYXI9e2luaXQ6ZnVuY3Rpb24odCxlKXtpZih0LmNvbXBvbmVudEluc3RhbmNlJiYhdC5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQmJnQuZGF0YS5rZWVwQWxpdmUpe3ZhciBuPXQ7YXIucHJlcGF0Y2gobixuKX1lbHNleyh0LmNvbXBvbmVudEluc3RhbmNlPWZ1bmN0aW9uKHQsZSl7dmFyIG49e19pc0NvbXBvbmVudDohMCxfcGFyZW50Vm5vZGU6dCxwYXJlbnQ6ZX0sbz10LmRhdGEuaW5saW5lVGVtcGxhdGU7cihvKSYmKG4ucmVuZGVyPW8ucmVuZGVyLG4uc3RhdGljUmVuZGVyRm5zPW8uc3RhdGljUmVuZGVyRm5zKTtyZXR1cm4gbmV3IHQuY29tcG9uZW50T3B0aW9ucy5DdG9yKG4pfSh0LEllKSkuJG1vdW50KGU/dC5lbG06dm9pZCAwLGUpfX0scHJlcGF0Y2g6ZnVuY3Rpb24oZSxuKXt2YXIgcj1uLmNvbXBvbmVudE9wdGlvbnM7IWZ1bmN0aW9uKGUsbixyLG8saSl7dmFyIGE9by5kYXRhLnNjb3BlZFNsb3RzLHM9ZS4kc2NvcGVkU2xvdHMsYz0hIShhJiYhYS4kc3RhYmxlfHxzIT09dCYmIXMuJHN0YWJsZXx8YSYmZS4kc2NvcGVkU2xvdHMuJGtleSE9PWEuJGtleXx8IWEmJmUuJHNjb3BlZFNsb3RzLiRrZXkpLHU9ISEoaXx8ZS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW58fGMpLGw9ZS4kdm5vZGU7ZS4kb3B0aW9ucy5fcGFyZW50Vm5vZGU9byxlLiR2bm9kZT1vLGUuX3Zub2RlJiYoZS5fdm5vZGUucGFyZW50PW8pLGUuJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuPWk7dmFyIGY9by5kYXRhLmF0dHJzfHx0O2UuX2F0dHJzUHJveHkmJkNlKGUuX2F0dHJzUHJveHksZixsLmRhdGEmJmwuZGF0YS5hdHRyc3x8dCxlLFwiJGF0dHJzXCIpJiYodT0hMCksZS4kYXR0cnM9ZixyPXJ8fHQ7dmFyIGQ9ZS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO2lmKGUuX2xpc3RlbmVyc1Byb3h5JiZDZShlLl9saXN0ZW5lcnNQcm94eSxyLGR8fHQsZSxcIiRsaXN0ZW5lcnNcIiksZS4kbGlzdGVuZXJzPWUuJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycz1yLE1lKGUscixkKSxuJiZlLiRvcHRpb25zLnByb3BzKXtrdCghMSk7Zm9yKHZhciBwPWUuX3Byb3BzLHY9ZS4kb3B0aW9ucy5fcHJvcEtleXN8fFtdLGg9MDtoPHYubGVuZ3RoO2grKyl7dmFyIG09dltoXSxnPWUuJG9wdGlvbnMucHJvcHM7cFttXT1fcihtLGcsbixlKX1rdCghMCksZS4kb3B0aW9ucy5wcm9wc0RhdGE9bn11JiYoZS4kc2xvdHM9Z2UoaSxvLmNvbnRleHQpLGUuJGZvcmNlVXBkYXRlKCkpfShuLmNvbXBvbmVudEluc3RhbmNlPWUuY29tcG9uZW50SW5zdGFuY2Usci5wcm9wc0RhdGEsci5saXN0ZW5lcnMsbixyLmNoaWxkcmVuKX0saW5zZXJ0OmZ1bmN0aW9uKHQpe3ZhciBlLG49dC5jb250ZXh0LHI9dC5jb21wb25lbnRJbnN0YW5jZTtyLl9pc01vdW50ZWR8fChyLl9pc01vdW50ZWQ9ITAsQmUocixcIm1vdW50ZWRcIikpLHQuZGF0YS5rZWVwQWxpdmUmJihuLl9pc01vdW50ZWQ/KChlPXIpLl9pbmFjdGl2ZT0hMSx6ZS5wdXNoKGUpKTpGZShyLCEwKSl9LGRlc3Ryb3k6ZnVuY3Rpb24odCl7dmFyIGU9dC5jb21wb25lbnRJbnN0YW5jZTtlLl9pc0Rlc3Ryb3llZHx8KHQuZGF0YS5rZWVwQWxpdmU/SGUoZSwhMCk6ZS4kZGVzdHJveSgpKX19LHNyPU9iamVjdC5rZXlzKGFyKTtmdW5jdGlvbiBjcihpLGEsYyx1LGwpe2lmKCFuKGkpKXt2YXIgZD1jLiRvcHRpb25zLl9iYXNlO2lmKHMoaSkmJihpPWQuZXh0ZW5kKGkpKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBpKXt2YXIgcDtpZihuKGkuY2lkKSYmKGk9ZnVuY3Rpb24odCxlKXtpZihvKHQuZXJyb3IpJiZyKHQuZXJyb3JDb21wKSlyZXR1cm4gdC5lcnJvckNvbXA7aWYocih0LnJlc29sdmVkKSlyZXR1cm4gdC5yZXNvbHZlZDt2YXIgaT1BZTtpZihpJiZyKHQub3duZXJzKSYmLTE9PT10Lm93bmVycy5pbmRleE9mKGkpJiZ0Lm93bmVycy5wdXNoKGkpLG8odC5sb2FkaW5nKSYmcih0LmxvYWRpbmdDb21wKSlyZXR1cm4gdC5sb2FkaW5nQ29tcDtpZihpJiYhcih0Lm93bmVycykpe3ZhciBhPXQub3duZXJzPVtpXSxjPSEwLHU9bnVsbCxsPW51bGw7aS4kb24oXCJob29rOmRlc3Ryb3llZFwiLChmdW5jdGlvbigpe3JldHVybiBnKGEsaSl9KSk7dmFyIGQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj1hLmxlbmd0aDtlPG47ZSsrKWFbZV0uJGZvcmNlVXBkYXRlKCk7dCYmKGEubGVuZ3RoPTAsbnVsbCE9PXUmJihjbGVhclRpbWVvdXQodSksdT1udWxsKSxudWxsIT09bCYmKGNsZWFyVGltZW91dChsKSxsPW51bGwpKX0scD1NKChmdW5jdGlvbihuKXt0LnJlc29sdmVkPWplKG4sZSksYz9hLmxlbmd0aD0wOmQoITApfSkpLHY9TSgoZnVuY3Rpb24oZSl7cih0LmVycm9yQ29tcCkmJih0LmVycm9yPSEwLGQoITApKX0pKSxoPXQocCx2KTtyZXR1cm4gcyhoKSYmKGYoaCk/bih0LnJlc29sdmVkKSYmaC50aGVuKHAsdik6ZihoLmNvbXBvbmVudCkmJihoLmNvbXBvbmVudC50aGVuKHAsdikscihoLmVycm9yKSYmKHQuZXJyb3JDb21wPWplKGguZXJyb3IsZSkpLHIoaC5sb2FkaW5nKSYmKHQubG9hZGluZ0NvbXA9amUoaC5sb2FkaW5nLGUpLDA9PT1oLmRlbGF5P3QubG9hZGluZz0hMDp1PXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7dT1udWxsLG4odC5yZXNvbHZlZCkmJm4odC5lcnJvcikmJih0LmxvYWRpbmc9ITAsZCghMSkpfSksaC5kZWxheXx8MjAwKSkscihoLnRpbWVvdXQpJiYobD1zZXRUaW1lb3V0KChmdW5jdGlvbigpe2w9bnVsbCxuKHQucmVzb2x2ZWQpJiZ2KG51bGwpfSksaC50aW1lb3V0KSkpKSxjPSExLHQubG9hZGluZz90LmxvYWRpbmdDb21wOnQucmVzb2x2ZWR9fShwPWksZCksdm9pZCAwPT09aSkpcmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsbyl7dmFyIGk9ZnQoKTtyZXR1cm4gaS5hc3luY0ZhY3Rvcnk9dCxpLmFzeW5jTWV0YT17ZGF0YTplLGNvbnRleHQ6bixjaGlsZHJlbjpyLHRhZzpvfSxpfShwLGEsYyx1LGwpO2E9YXx8e30sZXIoaSkscihhLm1vZGVsKSYmZnVuY3Rpb24odCxuKXt2YXIgbz10Lm1vZGVsJiZ0Lm1vZGVsLnByb3B8fFwidmFsdWVcIixpPXQubW9kZWwmJnQubW9kZWwuZXZlbnR8fFwiaW5wdXRcIjsobi5hdHRyc3x8KG4uYXR0cnM9e30pKVtvXT1uLm1vZGVsLnZhbHVlO3ZhciBhPW4ub258fChuLm9uPXt9KSxzPWFbaV0sYz1uLm1vZGVsLmNhbGxiYWNrO3Iocyk/KGUocyk/LTE9PT1zLmluZGV4T2YoYyk6cyE9PWMpJiYoYVtpXT1bY10uY29uY2F0KHMpKTphW2ldPWN9KGkub3B0aW9ucyxhKTt2YXIgdj1mdW5jdGlvbih0LGUsbyl7dmFyIGk9ZS5vcHRpb25zLnByb3BzO2lmKCFuKGkpKXt2YXIgYT17fSxzPXQuYXR0cnMsYz10LnByb3BzO2lmKHIocyl8fHIoYykpZm9yKHZhciB1IGluIGkpe3ZhciBsPWsodSk7R3QoYSxjLHUsbCwhMCl8fEd0KGEscyx1LGwsITEpfXJldHVybiBhfX0oYSxpKTtpZihvKGkub3B0aW9ucy5mdW5jdGlvbmFsKSlyZXR1cm4gZnVuY3Rpb24obixvLGksYSxzKXt2YXIgYz1uLm9wdGlvbnMsdT17fSxsPWMucHJvcHM7aWYocihsKSlmb3IodmFyIGYgaW4gbCl1W2ZdPV9yKGYsbCxvfHx0KTtlbHNlIHIoaS5hdHRycykmJm9yKHUsaS5hdHRycykscihpLnByb3BzKSYmb3IodSxpLnByb3BzKTt2YXIgZD1uZXcgbnIoaSx1LHMsYSxuKSxwPWMucmVuZGVyLmNhbGwobnVsbCxkLl9jLGQpO2lmKHAgaW5zdGFuY2VvZiBsdClyZXR1cm4gcnIocCxpLGQucGFyZW50LGMpO2lmKGUocCkpe2Zvcih2YXIgdj1YdChwKXx8W10saD1uZXcgQXJyYXkodi5sZW5ndGgpLG09MDttPHYubGVuZ3RoO20rKyloW21dPXJyKHZbbV0saSxkLnBhcmVudCxjKTtyZXR1cm4gaH19KGksdixhLGMsdSk7dmFyIGg9YS5vbjtpZihhLm9uPWEubmF0aXZlT24sbyhpLm9wdGlvbnMuYWJzdHJhY3QpKXt2YXIgbT1hLnNsb3Q7YT17fSxtJiYoYS5zbG90PW0pfSFmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5ob29rfHwodC5ob29rPXt9KSxuPTA7bjxzci5sZW5ndGg7bisrKXt2YXIgcj1zcltuXSxvPWVbcl0saT1hcltyXTtvPT09aXx8byYmby5fbWVyZ2VkfHwoZVtyXT1vP3VyKGksbyk6aSl9fShhKTt2YXIgeT1pcihpLm9wdGlvbnMpfHxsO3JldHVybiBuZXcgbHQoXCJ2dWUtY29tcG9uZW50LVwiLmNvbmNhdChpLmNpZCkuY29uY2F0KHk/XCItXCIuY29uY2F0KHkpOlwiXCIpLGEsdm9pZCAwLHZvaWQgMCx2b2lkIDAsYyx7Q3RvcjppLHByb3BzRGF0YTp2LGxpc3RlbmVyczpoLHRhZzpsLGNoaWxkcmVuOnV9LHApfX19ZnVuY3Rpb24gdXIodCxlKXt2YXIgbj1mdW5jdGlvbihuLHIpe3QobixyKSxlKG4scil9O3JldHVybiBuLl9tZXJnZWQ9ITAsbn12YXIgbHI9aixmcj1ILm9wdGlvbk1lcmdlU3RyYXRlZ2llcztmdW5jdGlvbiBkcih0LGUsbil7aWYodm9pZCAwPT09biYmKG49ITApLCFlKXJldHVybiB0O2Zvcih2YXIgcixvLGksYT1zdD9SZWZsZWN0Lm93bktleXMoZSk6T2JqZWN0LmtleXMoZSkscz0wO3M8YS5sZW5ndGg7cysrKVwiX19vYl9fXCIhPT0ocj1hW3NdKSYmKG89dFtyXSxpPWVbcl0sbiYmXyh0LHIpP28hPT1pJiZ1KG8pJiZ1KGkpJiZkcihvLGkpOmp0KHQscixpKSk7cmV0dXJuIHR9ZnVuY3Rpb24gcHIodCxlLG4pe3JldHVybiBuP2Z1bmN0aW9uKCl7dmFyIHI9YShlKT9lLmNhbGwobixuKTplLG89YSh0KT90LmNhbGwobixuKTp0O3JldHVybiByP2RyKHIsbyk6b306ZT90P2Z1bmN0aW9uKCl7cmV0dXJuIGRyKGEoZSk/ZS5jYWxsKHRoaXMsdGhpcyk6ZSxhKHQpP3QuY2FsbCh0aGlzLHRoaXMpOnQpfTplOnR9ZnVuY3Rpb24gdnIodCxuKXt2YXIgcj1uP3Q/dC5jb25jYXQobik6ZShuKT9uOltuXTp0O3JldHVybiByP2Z1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDtuKyspLTE9PT1lLmluZGV4T2YodFtuXSkmJmUucHVzaCh0W25dKTtyZXR1cm4gZX0ocik6cn1mdW5jdGlvbiBocih0LGUsbixyKXt2YXIgbz1PYmplY3QuY3JlYXRlKHR8fG51bGwpO3JldHVybiBlP1QobyxlKTpvfWZyLmRhdGE9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBuP3ByKHQsZSxuKTplJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6cHIodCxlKX0sRi5mb3JFYWNoKChmdW5jdGlvbih0KXtmclt0XT12cn0pKSxSLmZvckVhY2goKGZ1bmN0aW9uKHQpe2ZyW3QrXCJzXCJdPWhyfSkpLGZyLndhdGNoPWZ1bmN0aW9uKHQsbixyLG8pe2lmKHQ9PT10dCYmKHQ9dm9pZCAwKSxuPT09dHQmJihuPXZvaWQgMCksIW4pcmV0dXJuIE9iamVjdC5jcmVhdGUodHx8bnVsbCk7aWYoIXQpcmV0dXJuIG47dmFyIGk9e307Zm9yKHZhciBhIGluIFQoaSx0KSxuKXt2YXIgcz1pW2FdLGM9blthXTtzJiYhZShzKSYmKHM9W3NdKSxpW2FdPXM/cy5jb25jYXQoYyk6ZShjKT9jOltjXX1yZXR1cm4gaX0sZnIucHJvcHM9ZnIubWV0aG9kcz1mci5pbmplY3Q9ZnIuY29tcHV0ZWQ9ZnVuY3Rpb24odCxlLG4scil7aWYoIXQpcmV0dXJuIGU7dmFyIG89T2JqZWN0LmNyZWF0ZShudWxsKTtyZXR1cm4gVChvLHQpLGUmJlQobyxlKSxvfSxmci5wcm92aWRlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ/ZnVuY3Rpb24oKXt2YXIgbj1PYmplY3QuY3JlYXRlKG51bGwpO3JldHVybiBkcihuLGEodCk/dC5jYWxsKHRoaXMpOnQpLGUmJmRyKG4sYShlKT9lLmNhbGwodGhpcyk6ZSwhMSksbn06ZX07dmFyIG1yPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWU/dDplfTtmdW5jdGlvbiBncih0LG4scil7aWYoYShuKSYmKG49bi5vcHRpb25zKSxmdW5jdGlvbih0LG4pe3ZhciByPXQucHJvcHM7aWYocil7dmFyIG8saSxhPXt9O2lmKGUocikpZm9yKG89ci5sZW5ndGg7by0tOylcInN0cmluZ1wiPT10eXBlb2YoaT1yW29dKSYmKGFbdyhpKV09e3R5cGU6bnVsbH0pO2Vsc2UgaWYodShyKSlmb3IodmFyIHMgaW4gcilpPXJbc10sYVt3KHMpXT11KGkpP2k6e3R5cGU6aX07dC5wcm9wcz1hfX0obiksZnVuY3Rpb24odCxuKXt2YXIgcj10LmluamVjdDtpZihyKXt2YXIgbz10LmluamVjdD17fTtpZihlKHIpKWZvcih2YXIgaT0wO2k8ci5sZW5ndGg7aSsrKW9bcltpXV09e2Zyb206cltpXX07ZWxzZSBpZih1KHIpKWZvcih2YXIgYSBpbiByKXt2YXIgcz1yW2FdO29bYV09dShzKT9UKHtmcm9tOmF9LHMpOntmcm9tOnN9fX19KG4pLGZ1bmN0aW9uKHQpe3ZhciBlPXQuZGlyZWN0aXZlcztpZihlKWZvcih2YXIgbiBpbiBlKXt2YXIgcj1lW25dO2EocikmJihlW25dPXtiaW5kOnIsdXBkYXRlOnJ9KX19KG4pLCFuLl9iYXNlJiYobi5leHRlbmRzJiYodD1ncih0LG4uZXh0ZW5kcyxyKSksbi5taXhpbnMpKWZvcih2YXIgbz0wLGk9bi5taXhpbnMubGVuZ3RoO288aTtvKyspdD1ncih0LG4ubWl4aW5zW29dLHIpO3ZhciBzLGM9e307Zm9yKHMgaW4gdClsKHMpO2ZvcihzIGluIG4pXyh0LHMpfHxsKHMpO2Z1bmN0aW9uIGwoZSl7dmFyIG89ZnJbZV18fG1yO2NbZV09byh0W2VdLG5bZV0scixlKX1yZXR1cm4gY31mdW5jdGlvbiB5cih0LGUsbixyKXtpZihcInN0cmluZ1wiPT10eXBlb2Ygbil7dmFyIG89dFtlXTtpZihfKG8sbikpcmV0dXJuIG9bbl07dmFyIGk9dyhuKTtpZihfKG8saSkpcmV0dXJuIG9baV07dmFyIGE9eChpKTtyZXR1cm4gXyhvLGEpP29bYV06b1tuXXx8b1tpXXx8b1thXX19ZnVuY3Rpb24gX3IodCxlLG4scil7dmFyIG89ZVt0XSxpPSFfKG4sdCkscz1uW3RdLGM9eHIoQm9vbGVhbixvLnR5cGUpO2lmKGM+LTEpaWYoaSYmIV8obyxcImRlZmF1bHRcIikpcz0hMTtlbHNlIGlmKFwiXCI9PT1zfHxzPT09ayh0KSl7dmFyIHU9eHIoU3RyaW5nLG8udHlwZSk7KHU8MHx8Yzx1KSYmKHM9ITApfWlmKHZvaWQgMD09PXMpe3M9ZnVuY3Rpb24odCxlLG4pe2lmKCFfKGUsXCJkZWZhdWx0XCIpKXJldHVybjt2YXIgcj1lLmRlZmF1bHQ7aWYodCYmdC4kb3B0aW9ucy5wcm9wc0RhdGEmJnZvaWQgMD09PXQuJG9wdGlvbnMucHJvcHNEYXRhW25dJiZ2b2lkIDAhPT10Ll9wcm9wc1tuXSlyZXR1cm4gdC5fcHJvcHNbbl07cmV0dXJuIGEocikmJlwiRnVuY3Rpb25cIiE9PSRyKGUudHlwZSk/ci5jYWxsKHQpOnJ9KHIsbyx0KTt2YXIgbD1DdDtrdCghMCksVHQocyksa3QobCl9cmV0dXJuIHN9dmFyIGJyPS9eXFxzKmZ1bmN0aW9uIChcXHcrKS87ZnVuY3Rpb24gJHIodCl7dmFyIGU9dCYmdC50b1N0cmluZygpLm1hdGNoKGJyKTtyZXR1cm4gZT9lWzFdOlwiXCJ9ZnVuY3Rpb24gd3IodCxlKXtyZXR1cm4gJHIodCk9PT0kcihlKX1mdW5jdGlvbiB4cih0LG4pe2lmKCFlKG4pKXJldHVybiB3cihuLHQpPzA6LTE7Zm9yKHZhciByPTAsbz1uLmxlbmd0aDtyPG87cisrKWlmKHdyKG5bcl0sdCkpcmV0dXJuIHI7cmV0dXJuLTF9ZnVuY3Rpb24gQ3IodCl7dGhpcy5faW5pdCh0KX1mdW5jdGlvbiBrcih0KXt0LmNpZD0wO3ZhciBlPTE7dC5leHRlbmQ9ZnVuY3Rpb24odCl7dD10fHx7fTt2YXIgbj10aGlzLHI9bi5jaWQsbz10Ll9DdG9yfHwodC5fQ3Rvcj17fSk7aWYob1tyXSlyZXR1cm4gb1tyXTt2YXIgaT1pcih0KXx8aXIobi5vcHRpb25zKSxhPWZ1bmN0aW9uKHQpe3RoaXMuX2luaXQodCl9O3JldHVybihhLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKG4ucHJvdG90eXBlKSkuY29uc3RydWN0b3I9YSxhLmNpZD1lKyssYS5vcHRpb25zPWdyKG4ub3B0aW9ucyx0KSxhLnN1cGVyPW4sYS5vcHRpb25zLnByb3BzJiZmdW5jdGlvbih0KXt2YXIgZT10Lm9wdGlvbnMucHJvcHM7Zm9yKHZhciBuIGluIGUpSm4odC5wcm90b3R5cGUsXCJfcHJvcHNcIixuKX0oYSksYS5vcHRpb25zLmNvbXB1dGVkJiZmdW5jdGlvbih0KXt2YXIgZT10Lm9wdGlvbnMuY29tcHV0ZWQ7Zm9yKHZhciBuIGluIGUpWm4odC5wcm90b3R5cGUsbixlW25dKX0oYSksYS5leHRlbmQ9bi5leHRlbmQsYS5taXhpbj1uLm1peGluLGEudXNlPW4udXNlLFIuZm9yRWFjaCgoZnVuY3Rpb24odCl7YVt0XT1uW3RdfSkpLGkmJihhLm9wdGlvbnMuY29tcG9uZW50c1tpXT1hKSxhLnN1cGVyT3B0aW9ucz1uLm9wdGlvbnMsYS5leHRlbmRPcHRpb25zPXQsYS5zZWFsZWRPcHRpb25zPVQoe30sYS5vcHRpb25zKSxvW3JdPWEsYX19ZnVuY3Rpb24gU3IodCl7cmV0dXJuIHQmJihpcih0LkN0b3Iub3B0aW9ucyl8fHQudGFnKX1mdW5jdGlvbiBPcih0LG4pe3JldHVybiBlKHQpP3QuaW5kZXhPZihuKT4tMTpcInN0cmluZ1wiPT10eXBlb2YgdD90LnNwbGl0KFwiLFwiKS5pbmRleE9mKG4pPi0xOihyPXQsXCJbb2JqZWN0IFJlZ0V4cF1cIj09PWMuY2FsbChyKSYmdC50ZXN0KG4pKTt2YXIgcn1mdW5jdGlvbiBUcih0LGUpe3ZhciBuPXQuY2FjaGUscj10LmtleXMsbz10Ll92bm9kZTtmb3IodmFyIGkgaW4gbil7dmFyIGE9bltpXTtpZihhKXt2YXIgcz1hLm5hbWU7cyYmIWUocykmJkFyKG4saSxyLG8pfX19ZnVuY3Rpb24gQXIodCxlLG4scil7dmFyIG89dFtlXTshb3x8ciYmby50YWc9PT1yLnRhZ3x8by5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpLHRbZV09bnVsbCxnKG4sZSl9IWZ1bmN0aW9uKGUpe2UucHJvdG90eXBlLl9pbml0PWZ1bmN0aW9uKGUpe3ZhciBuPXRoaXM7bi5fdWlkPXRyKyssbi5faXNWdWU9ITAsbi5fX3Zfc2tpcD0hMCxuLl9zY29wZT1uZXcgdW4oITApLG4uX3Njb3BlLl92bT0hMCxlJiZlLl9pc0NvbXBvbmVudD9mdW5jdGlvbih0LGUpe3ZhciBuPXQuJG9wdGlvbnM9T2JqZWN0LmNyZWF0ZSh0LmNvbnN0cnVjdG9yLm9wdGlvbnMpLHI9ZS5fcGFyZW50Vm5vZGU7bi5wYXJlbnQ9ZS5wYXJlbnQsbi5fcGFyZW50Vm5vZGU9cjt2YXIgbz1yLmNvbXBvbmVudE9wdGlvbnM7bi5wcm9wc0RhdGE9by5wcm9wc0RhdGEsbi5fcGFyZW50TGlzdGVuZXJzPW8ubGlzdGVuZXJzLG4uX3JlbmRlckNoaWxkcmVuPW8uY2hpbGRyZW4sbi5fY29tcG9uZW50VGFnPW8udGFnLGUucmVuZGVyJiYobi5yZW5kZXI9ZS5yZW5kZXIsbi5zdGF0aWNSZW5kZXJGbnM9ZS5zdGF0aWNSZW5kZXJGbnMpfShuLGUpOm4uJG9wdGlvbnM9Z3IoZXIobi5jb25zdHJ1Y3RvciksZXx8e30sbiksbi5fcmVuZGVyUHJveHk9bixuLl9zZWxmPW4sZnVuY3Rpb24odCl7dmFyIGU9dC4kb3B0aW9ucyxuPWUucGFyZW50O2lmKG4mJiFlLmFic3RyYWN0KXtmb3IoO24uJG9wdGlvbnMuYWJzdHJhY3QmJm4uJHBhcmVudDspbj1uLiRwYXJlbnQ7bi4kY2hpbGRyZW4ucHVzaCh0KX10LiRwYXJlbnQ9bix0LiRyb290PW4/bi4kcm9vdDp0LHQuJGNoaWxkcmVuPVtdLHQuJHJlZnM9e30sdC5fcHJvdmlkZWQ9bj9uLl9wcm92aWRlZDpPYmplY3QuY3JlYXRlKG51bGwpLHQuX3dhdGNoZXI9bnVsbCx0Ll9pbmFjdGl2ZT1udWxsLHQuX2RpcmVjdEluYWN0aXZlPSExLHQuX2lzTW91bnRlZD0hMSx0Ll9pc0Rlc3Ryb3llZD0hMSx0Ll9pc0JlaW5nRGVzdHJveWVkPSExfShuKSxmdW5jdGlvbih0KXt0Ll9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0Ll9oYXNIb29rRXZlbnQ9ITE7dmFyIGU9dC4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO2UmJk1lKHQsZSl9KG4pLGZ1bmN0aW9uKGUpe2UuX3Zub2RlPW51bGwsZS5fc3RhdGljVHJlZXM9bnVsbDt2YXIgbj1lLiRvcHRpb25zLHI9ZS4kdm5vZGU9bi5fcGFyZW50Vm5vZGUsbz1yJiZyLmNvbnRleHQ7ZS4kc2xvdHM9Z2Uobi5fcmVuZGVyQ2hpbGRyZW4sbyksZS4kc2NvcGVkU2xvdHM9cj9iZShlLiRwYXJlbnQsci5kYXRhLnNjb3BlZFNsb3RzLGUuJHNsb3RzKTp0LGUuX2M9ZnVuY3Rpb24odCxuLHIsbyl7cmV0dXJuIHRlKGUsdCxuLHIsbywhMSl9LGUuJGNyZWF0ZUVsZW1lbnQ9ZnVuY3Rpb24odCxuLHIsbyl7cmV0dXJuIHRlKGUsdCxuLHIsbywhMCl9O3ZhciBpPXImJnIuZGF0YTtBdChlLFwiJGF0dHJzXCIsaSYmaS5hdHRyc3x8dCxudWxsLCEwKSxBdChlLFwiJGxpc3RlbmVyc1wiLG4uX3BhcmVudExpc3RlbmVyc3x8dCxudWxsLCEwKX0obiksQmUobixcImJlZm9yZUNyZWF0ZVwiLHZvaWQgMCwhMSksZnVuY3Rpb24odCl7dmFyIGU9UW4odC4kb3B0aW9ucy5pbmplY3QsdCk7ZSYmKGt0KCExKSxPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChmdW5jdGlvbihuKXtBdCh0LG4sZVtuXSl9KSksa3QoITApKX0obikscW4obiksZnVuY3Rpb24odCl7dmFyIGU9dC4kb3B0aW9ucy5wcm92aWRlO2lmKGUpe3ZhciBuPWEoZSk/ZS5jYWxsKHQpOmU7aWYoIXMobikpcmV0dXJuO2Zvcih2YXIgcj1sbih0KSxvPXN0P1JlZmxlY3Qub3duS2V5cyhuKTpPYmplY3Qua2V5cyhuKSxpPTA7aTxvLmxlbmd0aDtpKyspe3ZhciBjPW9baV07T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsYyxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sYykpfX19KG4pLEJlKG4sXCJjcmVhdGVkXCIpLG4uJG9wdGlvbnMuZWwmJm4uJG1vdW50KG4uJG9wdGlvbnMuZWwpfX0oQ3IpLGZ1bmN0aW9uKHQpe3ZhciBlPXtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZGF0YX19LG49e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wcm9wc319O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIiRkYXRhXCIsZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiJHByb3BzXCIsbiksdC5wcm90b3R5cGUuJHNldD1qdCx0LnByb3RvdHlwZS4kZGVsZXRlPUV0LHQucHJvdG90eXBlLiR3YXRjaD1mdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcztpZih1KGUpKXJldHVybiBZbihyLHQsZSxuKTsobj1ufHx7fSkudXNlcj0hMDt2YXIgbz1uZXcgVm4ocix0LGUsbik7aWYobi5pbW1lZGlhdGUpe3ZhciBpPSdjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXCInLmNvbmNhdChvLmV4cHJlc3Npb24sJ1wiJyk7eXQoKSxkbihlLHIsW28udmFsdWVdLHIsaSksX3QoKX1yZXR1cm4gZnVuY3Rpb24oKXtvLnRlYXJkb3duKCl9fX0oQ3IpLGZ1bmN0aW9uKHQpe3ZhciBuPS9eaG9vazovO3QucHJvdG90eXBlLiRvbj1mdW5jdGlvbih0LHIpe3ZhciBvPXRoaXM7aWYoZSh0KSlmb3IodmFyIGk9MCxhPXQubGVuZ3RoO2k8YTtpKyspby4kb24odFtpXSxyKTtlbHNlKG8uX2V2ZW50c1t0XXx8KG8uX2V2ZW50c1t0XT1bXSkpLnB1c2gociksbi50ZXN0KHQpJiYoby5faGFzSG9va0V2ZW50PSEwKTtyZXR1cm4gb30sdC5wcm90b3R5cGUuJG9uY2U9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO2Z1bmN0aW9uIHIoKXtuLiRvZmYodCxyKSxlLmFwcGx5KG4sYXJndW1lbnRzKX1yZXR1cm4gci5mbj1lLG4uJG9uKHQsciksbn0sdC5wcm90b3R5cGUuJG9mZj1mdW5jdGlvbih0LG4pe3ZhciByPXRoaXM7aWYoIWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHIuX2V2ZW50cz1PYmplY3QuY3JlYXRlKG51bGwpLHI7aWYoZSh0KSl7Zm9yKHZhciBvPTAsaT10Lmxlbmd0aDtvPGk7bysrKXIuJG9mZih0W29dLG4pO3JldHVybiByfXZhciBhLHM9ci5fZXZlbnRzW3RdO2lmKCFzKXJldHVybiByO2lmKCFuKXJldHVybiByLl9ldmVudHNbdF09bnVsbCxyO2Zvcih2YXIgYz1zLmxlbmd0aDtjLS07KWlmKChhPXNbY10pPT09bnx8YS5mbj09PW4pe3Muc3BsaWNlKGMsMSk7YnJlYWt9cmV0dXJuIHJ9LHQucHJvdG90eXBlLiRlbWl0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj1lLl9ldmVudHNbdF07aWYobil7bj1uLmxlbmd0aD4xP08obik6bjtmb3IodmFyIHI9Tyhhcmd1bWVudHMsMSksbz0nZXZlbnQgaGFuZGxlciBmb3IgXCInLmNvbmNhdCh0LCdcIicpLGk9MCxhPW4ubGVuZ3RoO2k8YTtpKyspZG4obltpXSxlLHIsZSxvKX1yZXR1cm4gZX19KENyKSxmdW5jdGlvbih0KXt0LnByb3RvdHlwZS5fdXBkYXRlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcyxyPW4uJGVsLG89bi5fdm5vZGUsaT1MZShuKTtuLl92bm9kZT10LG4uJGVsPW8/bi5fX3BhdGNoX18obyx0KTpuLl9fcGF0Y2hfXyhuLiRlbCx0LGUsITEpLGkoKSxyJiYoci5fX3Z1ZV9fPW51bGwpLG4uJGVsJiYobi4kZWwuX192dWVfXz1uKTtmb3IodmFyIGE9bjthJiZhLiR2bm9kZSYmYS4kcGFyZW50JiZhLiR2bm9kZT09PWEuJHBhcmVudC5fdm5vZGU7KWEuJHBhcmVudC4kZWw9YS4kZWwsYT1hLiRwYXJlbnR9LHQucHJvdG90eXBlLiRmb3JjZVVwZGF0ZT1mdW5jdGlvbigpe3RoaXMuX3dhdGNoZXImJnRoaXMuX3dhdGNoZXIudXBkYXRlKCl9LHQucHJvdG90eXBlLiRkZXN0cm95PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZighdC5faXNCZWluZ0Rlc3Ryb3llZCl7QmUodCxcImJlZm9yZURlc3Ryb3lcIiksdC5faXNCZWluZ0Rlc3Ryb3llZD0hMDt2YXIgZT10LiRwYXJlbnQ7IWV8fGUuX2lzQmVpbmdEZXN0cm95ZWR8fHQuJG9wdGlvbnMuYWJzdHJhY3R8fGcoZS4kY2hpbGRyZW4sdCksdC5fc2NvcGUuc3RvcCgpLHQuX2RhdGEuX19vYl9fJiZ0Ll9kYXRhLl9fb2JfXy52bUNvdW50LS0sdC5faXNEZXN0cm95ZWQ9ITAsdC5fX3BhdGNoX18odC5fdm5vZGUsbnVsbCksQmUodCxcImRlc3Ryb3llZFwiKSx0LiRvZmYoKSx0LiRlbCYmKHQuJGVsLl9fdnVlX189bnVsbCksdC4kdm5vZGUmJih0LiR2bm9kZS5wYXJlbnQ9bnVsbCl9fX0oQ3IpLGZ1bmN0aW9uKHQpe21lKHQucHJvdG90eXBlKSx0LnByb3RvdHlwZS4kbmV4dFRpY2s9ZnVuY3Rpb24odCl7cmV0dXJuIENuKHQsdGhpcyl9LHQucHJvdG90eXBlLl9yZW5kZXI9ZnVuY3Rpb24oKXt2YXIgdCxuPXRoaXMscj1uLiRvcHRpb25zLG89ci5yZW5kZXIsaT1yLl9wYXJlbnRWbm9kZTtpJiZuLl9pc01vdW50ZWQmJihuLiRzY29wZWRTbG90cz1iZShuLiRwYXJlbnQsaS5kYXRhLnNjb3BlZFNsb3RzLG4uJHNsb3RzLG4uJHNjb3BlZFNsb3RzKSxuLl9zbG90c1Byb3h5JiZTZShuLl9zbG90c1Byb3h5LG4uJHNjb3BlZFNsb3RzKSksbi4kdm5vZGU9aTt0cnl7dXQobiksQWU9bix0PW8uY2FsbChuLl9yZW5kZXJQcm94eSxuLiRjcmVhdGVFbGVtZW50KX1jYXRjaChlKXtmbihlLG4sXCJyZW5kZXJcIiksdD1uLl92bm9kZX1maW5hbGx5e0FlPW51bGwsdXQoKX1yZXR1cm4gZSh0KSYmMT09PXQubGVuZ3RoJiYodD10WzBdKSx0IGluc3RhbmNlb2YgbHR8fCh0PWZ0KCkpLHQucGFyZW50PWksdH19KENyKTt2YXIganI9W1N0cmluZyxSZWdFeHAsQXJyYXldLEVyPXtuYW1lOlwia2VlcC1hbGl2ZVwiLGFic3RyYWN0OiEwLHByb3BzOntpbmNsdWRlOmpyLGV4Y2x1ZGU6anIsbWF4OltTdHJpbmcsTnVtYmVyXX0sbWV0aG9kczp7Y2FjaGVWTm9kZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10LmNhY2hlLG49dC5rZXlzLHI9dC52bm9kZVRvQ2FjaGUsbz10LmtleVRvQ2FjaGU7aWYocil7dmFyIGk9ci50YWcsYT1yLmNvbXBvbmVudEluc3RhbmNlLHM9ci5jb21wb25lbnRPcHRpb25zO2Vbb109e25hbWU6U3IocyksdGFnOmksY29tcG9uZW50SW5zdGFuY2U6YX0sbi5wdXNoKG8pLHRoaXMubWF4JiZuLmxlbmd0aD5wYXJzZUludCh0aGlzLm1heCkmJkFyKGUsblswXSxuLHRoaXMuX3Zub2RlKSx0aGlzLnZub2RlVG9DYWNoZT1udWxsfX19LGNyZWF0ZWQ6ZnVuY3Rpb24oKXt0aGlzLmNhY2hlPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5rZXlzPVtdfSxkZXN0cm95ZWQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5jYWNoZSlBcih0aGlzLmNhY2hlLHQsdGhpcy5rZXlzKX0sbW91bnRlZDpmdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5jYWNoZVZOb2RlKCksdGhpcy4kd2F0Y2goXCJpbmNsdWRlXCIsKGZ1bmN0aW9uKGUpe1RyKHQsKGZ1bmN0aW9uKHQpe3JldHVybiBPcihlLHQpfSkpfSkpLHRoaXMuJHdhdGNoKFwiZXhjbHVkZVwiLChmdW5jdGlvbihlKXtUcih0LChmdW5jdGlvbih0KXtyZXR1cm4hT3IoZSx0KX0pKX0pKX0sdXBkYXRlZDpmdW5jdGlvbigpe3RoaXMuY2FjaGVWTm9kZSgpfSxyZW5kZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLiRzbG90cy5kZWZhdWx0LGU9RWUodCksbj1lJiZlLmNvbXBvbmVudE9wdGlvbnM7aWYobil7dmFyIHI9U3Iobiksbz10aGlzLmluY2x1ZGUsaT10aGlzLmV4Y2x1ZGU7aWYobyYmKCFyfHwhT3IobyxyKSl8fGkmJnImJk9yKGkscikpcmV0dXJuIGU7dmFyIGE9dGhpcy5jYWNoZSxzPXRoaXMua2V5cyxjPW51bGw9PWUua2V5P24uQ3Rvci5jaWQrKG4udGFnP1wiOjpcIi5jb25jYXQobi50YWcpOlwiXCIpOmUua2V5O2FbY10/KGUuY29tcG9uZW50SW5zdGFuY2U9YVtjXS5jb21wb25lbnRJbnN0YW5jZSxnKHMsYykscy5wdXNoKGMpKToodGhpcy52bm9kZVRvQ2FjaGU9ZSx0aGlzLmtleVRvQ2FjaGU9YyksZS5kYXRhLmtlZXBBbGl2ZT0hMH1yZXR1cm4gZXx8dCYmdFswXX19LE5yPXtLZWVwQWxpdmU6RXJ9OyFmdW5jdGlvbih0KXt2YXIgZT17Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEh9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImNvbmZpZ1wiLGUpLHQudXRpbD17d2FybjpscixleHRlbmQ6VCxtZXJnZU9wdGlvbnM6Z3IsZGVmaW5lUmVhY3RpdmU6QXR9LHQuc2V0PWp0LHQuZGVsZXRlPUV0LHQubmV4dFRpY2s9Q24sdC5vYnNlcnZhYmxlPWZ1bmN0aW9uKHQpe3JldHVybiBUdCh0KSx0fSx0Lm9wdGlvbnM9T2JqZWN0LmNyZWF0ZShudWxsKSxSLmZvckVhY2goKGZ1bmN0aW9uKGUpe3Qub3B0aW9uc1tlK1wic1wiXT1PYmplY3QuY3JlYXRlKG51bGwpfSkpLHQub3B0aW9ucy5fYmFzZT10LFQodC5vcHRpb25zLmNvbXBvbmVudHMsTnIpLGZ1bmN0aW9uKHQpe3QudXNlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX2luc3RhbGxlZFBsdWdpbnN8fCh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zPVtdKTtpZihlLmluZGV4T2YodCk+LTEpcmV0dXJuIHRoaXM7dmFyIG49Tyhhcmd1bWVudHMsMSk7cmV0dXJuIG4udW5zaGlmdCh0aGlzKSxhKHQuaW5zdGFsbCk/dC5pbnN0YWxsLmFwcGx5KHQsbik6YSh0KSYmdC5hcHBseShudWxsLG4pLGUucHVzaCh0KSx0aGlzfX0odCksZnVuY3Rpb24odCl7dC5taXhpbj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25zPWdyKHRoaXMub3B0aW9ucyx0KSx0aGlzfX0odCksa3IodCksZnVuY3Rpb24odCl7Ui5mb3JFYWNoKChmdW5jdGlvbihlKXt0W2VdPWZ1bmN0aW9uKHQsbil7cmV0dXJuIG4/KFwiY29tcG9uZW50XCI9PT1lJiZ1KG4pJiYobi5uYW1lPW4ubmFtZXx8dCxuPXRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQobikpLFwiZGlyZWN0aXZlXCI9PT1lJiZhKG4pJiYobj17YmluZDpuLHVwZGF0ZTpufSksdGhpcy5vcHRpb25zW2UrXCJzXCJdW3RdPW4sbik6dGhpcy5vcHRpb25zW2UrXCJzXCJdW3RdfX0pKX0odCl9KENyKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3IucHJvdG90eXBlLFwiJGlzU2VydmVyXCIse2dldDpydH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDci5wcm90b3R5cGUsXCIkc3NyQ29udGV4dFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kdm5vZGUmJnRoaXMuJHZub2RlLnNzckNvbnRleHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KENyLFwiRnVuY3Rpb25hbFJlbmRlckNvbnRleHRcIix7dmFsdWU6bnJ9KSxDci52ZXJzaW9uPVJuO3ZhciBQcj12KFwic3R5bGUsY2xhc3NcIiksRHI9dihcImlucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3NcIiksTXI9ZnVuY3Rpb24odCxlLG4pe3JldHVyblwidmFsdWVcIj09PW4mJkRyKHQpJiZcImJ1dHRvblwiIT09ZXx8XCJzZWxlY3RlZFwiPT09biYmXCJvcHRpb25cIj09PXR8fFwiY2hlY2tlZFwiPT09biYmXCJpbnB1dFwiPT09dHx8XCJtdXRlZFwiPT09biYmXCJ2aWRlb1wiPT09dH0sSXI9dihcImNvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVja1wiKSxMcj12KFwiZXZlbnRzLGNhcmV0LHR5cGluZyxwbGFpbnRleHQtb25seVwiKSxScj12KFwiYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSxkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSxtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LHJlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlXCIpLEZyPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLEhyPWZ1bmN0aW9uKHQpe3JldHVyblwiOlwiPT09dC5jaGFyQXQoNSkmJlwieGxpbmtcIj09PXQuc2xpY2UoMCw1KX0sQnI9ZnVuY3Rpb24odCl7cmV0dXJuIEhyKHQpP3Quc2xpY2UoNix0Lmxlbmd0aCk6XCJcIn0sVXI9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXR8fCExPT09dH07ZnVuY3Rpb24genIodCl7Zm9yKHZhciBlPXQuZGF0YSxuPXQsbz10O3Ioby5jb21wb25lbnRJbnN0YW5jZSk7KShvPW8uY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKSYmby5kYXRhJiYoZT1WcihvLmRhdGEsZSkpO2Zvcig7cihuPW4ucGFyZW50KTspbiYmbi5kYXRhJiYoZT1WcihlLG4uZGF0YSkpO3JldHVybiBmdW5jdGlvbih0LGUpe2lmKHIodCl8fHIoZSkpcmV0dXJuIEtyKHQsSnIoZSkpO3JldHVyblwiXCJ9KGUuc3RhdGljQ2xhc3MsZS5jbGFzcyl9ZnVuY3Rpb24gVnIodCxlKXtyZXR1cm57c3RhdGljQ2xhc3M6S3IodC5zdGF0aWNDbGFzcyxlLnN0YXRpY0NsYXNzKSxjbGFzczpyKHQuY2xhc3MpP1t0LmNsYXNzLGUuY2xhc3NdOmUuY2xhc3N9fWZ1bmN0aW9uIEtyKHQsZSl7cmV0dXJuIHQ/ZT90K1wiIFwiK2U6dDplfHxcIlwifWZ1bmN0aW9uIEpyKHQpe3JldHVybiBBcnJheS5pc0FycmF5KHQpP2Z1bmN0aW9uKHQpe2Zvcih2YXIgZSxuPVwiXCIsbz0wLGk9dC5sZW5ndGg7bzxpO28rKylyKGU9SnIodFtvXSkpJiZcIlwiIT09ZSYmKG4mJihuKz1cIiBcIiksbis9ZSk7cmV0dXJuIG59KHQpOnModCk/ZnVuY3Rpb24odCl7dmFyIGU9XCJcIjtmb3IodmFyIG4gaW4gdCl0W25dJiYoZSYmKGUrPVwiIFwiKSxlKz1uKTtyZXR1cm4gZX0odCk6XCJzdHJpbmdcIj09dHlwZW9mIHQ/dDpcIlwifXZhciBxcj17c3ZnOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixtYXRoOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwifSxXcj12KFwiaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLGRpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLGEsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSxzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbyxlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0cixidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLG91dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LGNvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3RcIiksWnI9dihcInN2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSxmb3JlaWdub2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybixwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3XCIsITApLEdyPWZ1bmN0aW9uKHQpe3JldHVybiBXcih0KXx8WnIodCl9O2Z1bmN0aW9uIFhyKHQpe3JldHVybiBacih0KT9cInN2Z1wiOlwibWF0aFwiPT09dD9cIm1hdGhcIjp2b2lkIDB9dmFyIFlyPU9iamVjdC5jcmVhdGUobnVsbCk7dmFyIFFyPXYoXCJ0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybFwiKTtmdW5jdGlvbiB0byh0KXtpZihcInN0cmluZ1wiPT10eXBlb2YgdCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0KTtyZXR1cm4gZXx8ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKX1yZXR1cm4gdH12YXIgZW89T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsY3JlYXRlRWxlbWVudDpmdW5jdGlvbih0LGUpe3ZhciBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodCk7cmV0dXJuXCJzZWxlY3RcIiE9PXR8fGUuZGF0YSYmZS5kYXRhLmF0dHJzJiZ2b2lkIDAhPT1lLmRhdGEuYXR0cnMubXVsdGlwbGUmJm4uc2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIixcIm11bHRpcGxlXCIpLG59LGNyZWF0ZUVsZW1lbnROUzpmdW5jdGlvbih0LGUpe3JldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMocXJbdF0sZSl9LGNyZWF0ZVRleHROb2RlOmZ1bmN0aW9uKHQpe3JldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0KX0sY3JlYXRlQ29tbWVudDpmdW5jdGlvbih0KXtyZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0KX0saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKHQsZSxuKXt0Lmluc2VydEJlZm9yZShlLG4pfSxyZW1vdmVDaGlsZDpmdW5jdGlvbih0LGUpe3QucmVtb3ZlQ2hpbGQoZSl9LGFwcGVuZENoaWxkOmZ1bmN0aW9uKHQsZSl7dC5hcHBlbmRDaGlsZChlKX0scGFyZW50Tm9kZTpmdW5jdGlvbih0KXtyZXR1cm4gdC5wYXJlbnROb2RlfSxuZXh0U2libGluZzpmdW5jdGlvbih0KXtyZXR1cm4gdC5uZXh0U2libGluZ30sdGFnTmFtZTpmdW5jdGlvbih0KXtyZXR1cm4gdC50YWdOYW1lfSxzZXRUZXh0Q29udGVudDpmdW5jdGlvbih0LGUpe3QudGV4dENvbnRlbnQ9ZX0sc2V0U3R5bGVTY29wZTpmdW5jdGlvbih0LGUpe3Quc2V0QXR0cmlidXRlKGUsXCJcIil9fSksbm89e2NyZWF0ZTpmdW5jdGlvbih0LGUpe3JvKGUpfSx1cGRhdGU6ZnVuY3Rpb24odCxlKXt0LmRhdGEucmVmIT09ZS5kYXRhLnJlZiYmKHJvKHQsITApLHJvKGUpKX0sZGVzdHJveTpmdW5jdGlvbih0KXtybyh0LCEwKX19O2Z1bmN0aW9uIHJvKHQsbil7dmFyIG89dC5kYXRhLnJlZjtpZihyKG8pKXt2YXIgaT10LmNvbnRleHQscz10LmNvbXBvbmVudEluc3RhbmNlfHx0LmVsbSxjPW4/bnVsbDpzLHU9bj92b2lkIDA6cztpZihhKG8pKWRuKG8saSxbY10saSxcInRlbXBsYXRlIHJlZiBmdW5jdGlvblwiKTtlbHNle3ZhciBsPXQuZGF0YS5yZWZJbkZvcixmPVwic3RyaW5nXCI9PXR5cGVvZiBvfHxcIm51bWJlclwiPT10eXBlb2YgbyxkPUZ0KG8pLHA9aS4kcmVmcztpZihmfHxkKWlmKGwpe3ZhciB2PWY/cFtvXTpvLnZhbHVlO24/ZSh2KSYmZyh2LHMpOmUodik/di5pbmNsdWRlcyhzKXx8di5wdXNoKHMpOmY/KHBbb109W3NdLG9vKGksbyxwW29dKSk6by52YWx1ZT1bc119ZWxzZSBpZihmKXtpZihuJiZwW29dIT09cylyZXR1cm47cFtvXT11LG9vKGksbyxjKX1lbHNlIGlmKGQpe2lmKG4mJm8udmFsdWUhPT1zKXJldHVybjtvLnZhbHVlPWN9fX19ZnVuY3Rpb24gb28odCxlLG4pe3ZhciByPXQuX3NldHVwU3RhdGU7ciYmXyhyLGUpJiYoRnQocltlXSk/cltlXS52YWx1ZT1uOnJbZV09bil9dmFyIGlvPW5ldyBsdChcIlwiLHt9LFtdKSxhbz1bXCJjcmVhdGVcIixcImFjdGl2YXRlXCIsXCJ1cGRhdGVcIixcInJlbW92ZVwiLFwiZGVzdHJveVwiXTtmdW5jdGlvbiBzbyh0LGUpe3JldHVybiB0LmtleT09PWUua2V5JiZ0LmFzeW5jRmFjdG9yeT09PWUuYXN5bmNGYWN0b3J5JiYodC50YWc9PT1lLnRhZyYmdC5pc0NvbW1lbnQ9PT1lLmlzQ29tbWVudCYmcih0LmRhdGEpPT09cihlLmRhdGEpJiZmdW5jdGlvbih0LGUpe2lmKFwiaW5wdXRcIiE9PXQudGFnKXJldHVybiEwO3ZhciBuLG89cihuPXQuZGF0YSkmJnIobj1uLmF0dHJzKSYmbi50eXBlLGk9cihuPWUuZGF0YSkmJnIobj1uLmF0dHJzKSYmbi50eXBlO3JldHVybiBvPT09aXx8UXIobykmJlFyKGkpfSh0LGUpfHxvKHQuaXNBc3luY1BsYWNlaG9sZGVyKSYmbihlLmFzeW5jRmFjdG9yeS5lcnJvcikpfWZ1bmN0aW9uIGNvKHQsZSxuKXt2YXIgbyxpLGE9e307Zm9yKG89ZTtvPD1uOysrbylyKGk9dFtvXS5rZXkpJiYoYVtpXT1vKTtyZXR1cm4gYX12YXIgdW89e2NyZWF0ZTpsbyx1cGRhdGU6bG8sZGVzdHJveTpmdW5jdGlvbih0KXtsbyh0LGlvKX19O2Z1bmN0aW9uIGxvKHQsZSl7KHQuZGF0YS5kaXJlY3RpdmVzfHxlLmRhdGEuZGlyZWN0aXZlcykmJmZ1bmN0aW9uKHQsZSl7dmFyIG4scixvLGk9dD09PWlvLGE9ZT09PWlvLHM9cG8odC5kYXRhLmRpcmVjdGl2ZXMsdC5jb250ZXh0KSxjPXBvKGUuZGF0YS5kaXJlY3RpdmVzLGUuY29udGV4dCksdT1bXSxsPVtdO2ZvcihuIGluIGMpcj1zW25dLG89Y1tuXSxyPyhvLm9sZFZhbHVlPXIudmFsdWUsby5vbGRBcmc9ci5hcmcsaG8obyxcInVwZGF0ZVwiLGUsdCksby5kZWYmJm8uZGVmLmNvbXBvbmVudFVwZGF0ZWQmJmwucHVzaChvKSk6KGhvKG8sXCJiaW5kXCIsZSx0KSxvLmRlZiYmby5kZWYuaW5zZXJ0ZWQmJnUucHVzaChvKSk7aWYodS5sZW5ndGgpe3ZhciBmPWZ1bmN0aW9uKCl7Zm9yKHZhciBuPTA7bjx1Lmxlbmd0aDtuKyspaG8odVtuXSxcImluc2VydGVkXCIsZSx0KX07aT9adChlLFwiaW5zZXJ0XCIsZik6ZigpfWwubGVuZ3RoJiZadChlLFwicG9zdHBhdGNoXCIsKGZ1bmN0aW9uKCl7Zm9yKHZhciBuPTA7bjxsLmxlbmd0aDtuKyspaG8obFtuXSxcImNvbXBvbmVudFVwZGF0ZWRcIixlLHQpfSkpO2lmKCFpKWZvcihuIGluIHMpY1tuXXx8aG8oc1tuXSxcInVuYmluZFwiLHQsdCxhKX0odCxlKX12YXIgZm89T2JqZWN0LmNyZWF0ZShudWxsKTtmdW5jdGlvbiBwbyh0LGUpe3ZhciBuLHIsbz1PYmplY3QuY3JlYXRlKG51bGwpO2lmKCF0KXJldHVybiBvO2ZvcihuPTA7bjx0Lmxlbmd0aDtuKyspe2lmKChyPXRbbl0pLm1vZGlmaWVyc3x8KHIubW9kaWZpZXJzPWZvKSxvW3ZvKHIpXT1yLGUuX3NldHVwU3RhdGUmJmUuX3NldHVwU3RhdGUuX19zZmMpe3ZhciBpPXIuZGVmfHx5cihlLFwiX3NldHVwU3RhdGVcIixcInYtXCIrci5uYW1lKTtyLmRlZj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpP3tiaW5kOmksdXBkYXRlOml9Oml9ci5kZWY9ci5kZWZ8fHlyKGUuJG9wdGlvbnMsXCJkaXJlY3RpdmVzXCIsci5uYW1lKX1yZXR1cm4gb31mdW5jdGlvbiB2byh0KXtyZXR1cm4gdC5yYXdOYW1lfHxcIlwiLmNvbmNhdCh0Lm5hbWUsXCIuXCIpLmNvbmNhdChPYmplY3Qua2V5cyh0Lm1vZGlmaWVyc3x8e30pLmpvaW4oXCIuXCIpKX1mdW5jdGlvbiBobyh0LGUsbixyLG8pe3ZhciBpPXQuZGVmJiZ0LmRlZltlXTtpZihpKXRyeXtpKG4uZWxtLHQsbixyLG8pfWNhdGNoKHIpe2ZuKHIsbi5jb250ZXh0LFwiZGlyZWN0aXZlIFwiLmNvbmNhdCh0Lm5hbWUsXCIgXCIpLmNvbmNhdChlLFwiIGhvb2tcIikpfX12YXIgbW89W25vLHVvXTtmdW5jdGlvbiBnbyh0LGUpe3ZhciBpPWUuY29tcG9uZW50T3B0aW9ucztpZighKHIoaSkmJiExPT09aS5DdG9yLm9wdGlvbnMuaW5oZXJpdEF0dHJzfHxuKHQuZGF0YS5hdHRycykmJm4oZS5kYXRhLmF0dHJzKSkpe3ZhciBhLHMsYz1lLmVsbSx1PXQuZGF0YS5hdHRyc3x8e30sbD1lLmRhdGEuYXR0cnN8fHt9O2ZvcihhIGluKHIobC5fX29iX18pfHxvKGwuX3ZfYXR0cl9wcm94eSkpJiYobD1lLmRhdGEuYXR0cnM9VCh7fSxsKSksbClzPWxbYV0sdVthXSE9PXMmJnlvKGMsYSxzLGUuZGF0YS5wcmUpO2ZvcihhIGluKFd8fEcpJiZsLnZhbHVlIT09dS52YWx1ZSYmeW8oYyxcInZhbHVlXCIsbC52YWx1ZSksdSluKGxbYV0pJiYoSHIoYSk/Yy5yZW1vdmVBdHRyaWJ1dGVOUyhGcixCcihhKSk6SXIoYSl8fGMucmVtb3ZlQXR0cmlidXRlKGEpKX19ZnVuY3Rpb24geW8odCxlLG4scil7cnx8dC50YWdOYW1lLmluZGV4T2YoXCItXCIpPi0xP19vKHQsZSxuKTpScihlKT9VcihuKT90LnJlbW92ZUF0dHJpYnV0ZShlKToobj1cImFsbG93ZnVsbHNjcmVlblwiPT09ZSYmXCJFTUJFRFwiPT09dC50YWdOYW1lP1widHJ1ZVwiOmUsdC5zZXRBdHRyaWJ1dGUoZSxuKSk6SXIoZSk/dC5zZXRBdHRyaWJ1dGUoZSxmdW5jdGlvbih0LGUpe3JldHVybiBVcihlKXx8XCJmYWxzZVwiPT09ZT9cImZhbHNlXCI6XCJjb250ZW50ZWRpdGFibGVcIj09PXQmJkxyKGUpP2U6XCJ0cnVlXCJ9KGUsbikpOkhyKGUpP1VyKG4pP3QucmVtb3ZlQXR0cmlidXRlTlMoRnIsQnIoZSkpOnQuc2V0QXR0cmlidXRlTlMoRnIsZSxuKTpfbyh0LGUsbil9ZnVuY3Rpb24gX28odCxlLG4pe2lmKFVyKG4pKXQucmVtb3ZlQXR0cmlidXRlKGUpO2Vsc2V7aWYoVyYmIVomJlwiVEVYVEFSRUFcIj09PXQudGFnTmFtZSYmXCJwbGFjZWhvbGRlclwiPT09ZSYmXCJcIiE9PW4mJiF0Ll9faWVwaCl7dmFyIHI9ZnVuY3Rpb24oZSl7ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSx0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLHIpfTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLHIpLHQuX19pZXBoPSEwfXQuc2V0QXR0cmlidXRlKGUsbil9fXZhciBibz17Y3JlYXRlOmdvLHVwZGF0ZTpnb307ZnVuY3Rpb24gJG8odCxlKXt2YXIgbz1lLmVsbSxpPWUuZGF0YSxhPXQuZGF0YTtpZighKG4oaS5zdGF0aWNDbGFzcykmJm4oaS5jbGFzcykmJihuKGEpfHxuKGEuc3RhdGljQ2xhc3MpJiZuKGEuY2xhc3MpKSkpe3ZhciBzPXpyKGUpLGM9by5fdHJhbnNpdGlvbkNsYXNzZXM7cihjKSYmKHM9S3IocyxKcihjKSkpLHMhPT1vLl9wcmV2Q2xhc3MmJihvLnNldEF0dHJpYnV0ZShcImNsYXNzXCIscyksby5fcHJldkNsYXNzPXMpfX12YXIgd28seG8sQ28sa28sU28sT28sVG89e2NyZWF0ZTokbyx1cGRhdGU6JG99LEFvPS9bXFx3KS4rXFwtXyRcXF1dLztmdW5jdGlvbiBqbyh0KXt2YXIgZSxuLHIsbyxpLGE9ITEscz0hMSxjPSExLHU9ITEsbD0wLGY9MCxkPTAscD0wO2ZvcihyPTA7cjx0Lmxlbmd0aDtyKyspaWYobj1lLGU9dC5jaGFyQ29kZUF0KHIpLGEpMzk9PT1lJiY5MiE9PW4mJihhPSExKTtlbHNlIGlmKHMpMzQ9PT1lJiY5MiE9PW4mJihzPSExKTtlbHNlIGlmKGMpOTY9PT1lJiY5MiE9PW4mJihjPSExKTtlbHNlIGlmKHUpNDc9PT1lJiY5MiE9PW4mJih1PSExKTtlbHNlIGlmKDEyNCE9PWV8fDEyND09PXQuY2hhckNvZGVBdChyKzEpfHwxMjQ9PT10LmNoYXJDb2RlQXQoci0xKXx8bHx8Znx8ZCl7c3dpdGNoKGUpe2Nhc2UgMzQ6cz0hMDticmVhaztjYXNlIDM5OmE9ITA7YnJlYWs7Y2FzZSA5NjpjPSEwO2JyZWFrO2Nhc2UgNDA6ZCsrO2JyZWFrO2Nhc2UgNDE6ZC0tO2JyZWFrO2Nhc2UgOTE6ZisrO2JyZWFrO2Nhc2UgOTM6Zi0tO2JyZWFrO2Nhc2UgMTIzOmwrKzticmVhaztjYXNlIDEyNTpsLS19aWYoNDc9PT1lKXtmb3IodmFyIHY9ci0xLGg9dm9pZCAwO3Y+PTAmJlwiIFwiPT09KGg9dC5jaGFyQXQodikpO3YtLSk7aCYmQW8udGVzdChoKXx8KHU9ITApfX1lbHNlIHZvaWQgMD09PW8/KHA9cisxLG89dC5zbGljZSgwLHIpLnRyaW0oKSk6bSgpO2Z1bmN0aW9uIG0oKXsoaXx8KGk9W10pKS5wdXNoKHQuc2xpY2UocCxyKS50cmltKCkpLHA9cisxfWlmKHZvaWQgMD09PW8/bz10LnNsaWNlKDAscikudHJpbSgpOjAhPT1wJiZtKCksaSlmb3Iocj0wO3I8aS5sZW5ndGg7cisrKW89RW8obyxpW3JdKTtyZXR1cm4gb31mdW5jdGlvbiBFbyh0LGUpe3ZhciBuPWUuaW5kZXhPZihcIihcIik7aWYobjwwKXJldHVybidfZihcIicuY29uY2F0KGUsJ1wiKSgnKS5jb25jYXQodCxcIilcIik7dmFyIHI9ZS5zbGljZSgwLG4pLG89ZS5zbGljZShuKzEpO3JldHVybidfZihcIicuY29uY2F0KHIsJ1wiKSgnKS5jb25jYXQodCkuY29uY2F0KFwiKVwiIT09bz9cIixcIitvOm8pfWZ1bmN0aW9uIE5vKHQsZSl7Y29uc29sZS5lcnJvcihcIltWdWUgY29tcGlsZXJdOiBcIi5jb25jYXQodCkpfWZ1bmN0aW9uIFBvKHQsZSl7cmV0dXJuIHQ/dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0W2VdfSkpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHR9KSk6W119ZnVuY3Rpb24gRG8odCxlLG4scixvKXsodC5wcm9wc3x8KHQucHJvcHM9W10pKS5wdXNoKHpvKHtuYW1lOmUsdmFsdWU6bixkeW5hbWljOm99LHIpKSx0LnBsYWluPSExfWZ1bmN0aW9uIE1vKHQsZSxuLHIsbyl7KG8/dC5keW5hbWljQXR0cnN8fCh0LmR5bmFtaWNBdHRycz1bXSk6dC5hdHRyc3x8KHQuYXR0cnM9W10pKS5wdXNoKHpvKHtuYW1lOmUsdmFsdWU6bixkeW5hbWljOm99LHIpKSx0LnBsYWluPSExfWZ1bmN0aW9uIElvKHQsZSxuLHIpe3QuYXR0cnNNYXBbZV09bix0LmF0dHJzTGlzdC5wdXNoKHpvKHtuYW1lOmUsdmFsdWU6bn0scikpfWZ1bmN0aW9uIExvKHQsZSxuLHIsbyxpLGEscyl7KHQuZGlyZWN0aXZlc3x8KHQuZGlyZWN0aXZlcz1bXSkpLnB1c2goem8oe25hbWU6ZSxyYXdOYW1lOm4sdmFsdWU6cixhcmc6byxpc0R5bmFtaWNBcmc6aSxtb2RpZmllcnM6YX0scykpLHQucGxhaW49ITF9ZnVuY3Rpb24gUm8odCxlLG4pe3JldHVybiBuP1wiX3AoXCIuY29uY2F0KGUsJyxcIicpLmNvbmNhdCh0LCdcIiknKTp0K2V9ZnVuY3Rpb24gRm8oZSxuLHIsbyxpLGEscyxjKXt2YXIgdTsobz1vfHx0KS5yaWdodD9jP249XCIoXCIuY29uY2F0KG4sXCIpPT09J2NsaWNrJz8nY29udGV4dG1lbnUnOihcIikuY29uY2F0KG4sXCIpXCIpOlwiY2xpY2tcIj09PW4mJihuPVwiY29udGV4dG1lbnVcIixkZWxldGUgby5yaWdodCk6by5taWRkbGUmJihjP249XCIoXCIuY29uY2F0KG4sXCIpPT09J2NsaWNrJz8nbW91c2V1cCc6KFwiKS5jb25jYXQobixcIilcIik6XCJjbGlja1wiPT09biYmKG49XCJtb3VzZXVwXCIpKSxvLmNhcHR1cmUmJihkZWxldGUgby5jYXB0dXJlLG49Um8oXCIhXCIsbixjKSksby5vbmNlJiYoZGVsZXRlIG8ub25jZSxuPVJvKFwiflwiLG4sYykpLG8ucGFzc2l2ZSYmKGRlbGV0ZSBvLnBhc3NpdmUsbj1SbyhcIiZcIixuLGMpKSxvLm5hdGl2ZT8oZGVsZXRlIG8ubmF0aXZlLHU9ZS5uYXRpdmVFdmVudHN8fChlLm5hdGl2ZUV2ZW50cz17fSkpOnU9ZS5ldmVudHN8fChlLmV2ZW50cz17fSk7dmFyIGw9em8oe3ZhbHVlOnIudHJpbSgpLGR5bmFtaWM6Y30scyk7byE9PXQmJihsLm1vZGlmaWVycz1vKTt2YXIgZj11W25dO0FycmF5LmlzQXJyYXkoZik/aT9mLnVuc2hpZnQobCk6Zi5wdXNoKGwpOnVbbl09Zj9pP1tsLGZdOltmLGxdOmwsZS5wbGFpbj0hMX1mdW5jdGlvbiBIbyh0LGUsbil7dmFyIHI9Qm8odCxcIjpcIitlKXx8Qm8odCxcInYtYmluZDpcIitlKTtpZihudWxsIT1yKXJldHVybiBqbyhyKTtpZighMSE9PW4pe3ZhciBvPUJvKHQsZSk7aWYobnVsbCE9bylyZXR1cm4gSlNPTi5zdHJpbmdpZnkobyl9fWZ1bmN0aW9uIEJvKHQsZSxuKXt2YXIgcjtpZihudWxsIT0ocj10LmF0dHJzTWFwW2VdKSlmb3IodmFyIG89dC5hdHRyc0xpc3QsaT0wLGE9by5sZW5ndGg7aTxhO2krKylpZihvW2ldLm5hbWU9PT1lKXtvLnNwbGljZShpLDEpO2JyZWFrfXJldHVybiBuJiZkZWxldGUgdC5hdHRyc01hcFtlXSxyfWZ1bmN0aW9uIFVvKHQsZSl7Zm9yKHZhciBuPXQuYXR0cnNMaXN0LHI9MCxvPW4ubGVuZ3RoO3I8bztyKyspe3ZhciBpPW5bcl07aWYoZS50ZXN0KGkubmFtZSkpcmV0dXJuIG4uc3BsaWNlKHIsMSksaX19ZnVuY3Rpb24gem8odCxlKXtyZXR1cm4gZSYmKG51bGwhPWUuc3RhcnQmJih0LnN0YXJ0PWUuc3RhcnQpLG51bGwhPWUuZW5kJiYodC5lbmQ9ZS5lbmQpKSx0fWZ1bmN0aW9uIFZvKHQsZSxuKXt2YXIgcj1ufHx7fSxvPXIubnVtYmVyLGk9XCIkJHZcIixhPWk7ci50cmltJiYoYT1cIih0eXBlb2YgXCIuY29uY2F0KGksXCIgPT09ICdzdHJpbmcnXCIpK1wiPyBcIi5jb25jYXQoaSxcIi50cmltKClcIikrXCI6IFwiLmNvbmNhdChpLFwiKVwiKSksbyYmKGE9XCJfbihcIi5jb25jYXQoYSxcIilcIikpO3ZhciBzPUtvKGUsYSk7dC5tb2RlbD17dmFsdWU6XCIoXCIuY29uY2F0KGUsXCIpXCIpLGV4cHJlc3Npb246SlNPTi5zdHJpbmdpZnkoZSksY2FsbGJhY2s6XCJmdW5jdGlvbiAoXCIuY29uY2F0KGksXCIpIHtcIikuY29uY2F0KHMsXCJ9XCIpfX1mdW5jdGlvbiBLbyh0LGUpe3ZhciBuPWZ1bmN0aW9uKHQpe2lmKHQ9dC50cmltKCksd289dC5sZW5ndGgsdC5pbmRleE9mKFwiW1wiKTwwfHx0Lmxhc3RJbmRleE9mKFwiXVwiKTx3by0xKXJldHVybihrbz10Lmxhc3RJbmRleE9mKFwiLlwiKSk+LTE/e2V4cDp0LnNsaWNlKDAsa28pLGtleTonXCInK3Quc2xpY2Uoa28rMSkrJ1wiJ306e2V4cDp0LGtleTpudWxsfTt4bz10LGtvPVNvPU9vPTA7Zm9yKDshcW8oKTspV28oQ289Sm8oKSk/R28oQ28pOjkxPT09Q28mJlpvKENvKTtyZXR1cm57ZXhwOnQuc2xpY2UoMCxTbyksa2V5OnQuc2xpY2UoU28rMSxPbyl9fSh0KTtyZXR1cm4gbnVsbD09PW4ua2V5P1wiXCIuY29uY2F0KHQsXCI9XCIpLmNvbmNhdChlKTpcIiRzZXQoXCIuY29uY2F0KG4uZXhwLFwiLCBcIikuY29uY2F0KG4ua2V5LFwiLCBcIikuY29uY2F0KGUsXCIpXCIpfWZ1bmN0aW9uIEpvKCl7cmV0dXJuIHhvLmNoYXJDb2RlQXQoKytrbyl9ZnVuY3Rpb24gcW8oKXtyZXR1cm4ga28+PXdvfWZ1bmN0aW9uIFdvKHQpe3JldHVybiAzND09PXR8fDM5PT09dH1mdW5jdGlvbiBabyh0KXt2YXIgZT0xO2ZvcihTbz1rbzshcW8oKTspaWYoV28odD1KbygpKSlHbyh0KTtlbHNlIGlmKDkxPT09dCYmZSsrLDkzPT09dCYmZS0tLDA9PT1lKXtPbz1rbzticmVha319ZnVuY3Rpb24gR28odCl7Zm9yKHZhciBlPXQ7IXFvKCkmJih0PUpvKCkpIT09ZTspO312YXIgWG8sWW89XCJfX3JcIjtmdW5jdGlvbiBRbyh0LGUsbil7dmFyIHI9WG87cmV0dXJuIGZ1bmN0aW9uIG8oKXt2YXIgaT1lLmFwcGx5KG51bGwsYXJndW1lbnRzKTtudWxsIT09aSYmbmkodCxvLG4scil9fXZhciB0aT1tbiYmIShRJiZOdW1iZXIoUVsxXSk8PTUzKTtmdW5jdGlvbiBlaSh0LGUsbixyKXtpZih0aSl7dmFyIG89V2UsaT1lO2U9aS5fd3JhcHBlcj1mdW5jdGlvbih0KXtpZih0LnRhcmdldD09PXQuY3VycmVudFRhcmdldHx8dC50aW1lU3RhbXA+PW98fHQudGltZVN0YW1wPD0wfHx0LnRhcmdldC5vd25lckRvY3VtZW50IT09ZG9jdW1lbnQpcmV0dXJuIGkuYXBwbHkodGhpcyxhcmd1bWVudHMpfX1Yby5hZGRFdmVudExpc3RlbmVyKHQsZSxldD97Y2FwdHVyZTpuLHBhc3NpdmU6cn06bil9ZnVuY3Rpb24gbmkodCxlLG4scil7KHJ8fFhvKS5yZW1vdmVFdmVudExpc3RlbmVyKHQsZS5fd3JhcHBlcnx8ZSxuKX1mdW5jdGlvbiByaSh0LGUpe2lmKCFuKHQuZGF0YS5vbil8fCFuKGUuZGF0YS5vbikpe3ZhciBvPWUuZGF0YS5vbnx8e30saT10LmRhdGEub258fHt9O1hvPWUuZWxtfHx0LmVsbSxmdW5jdGlvbih0KXtpZihyKHQuX19yKSl7dmFyIGU9Vz9cImNoYW5nZVwiOlwiaW5wdXRcIjt0W2VdPVtdLmNvbmNhdCh0Ll9fcix0W2VdfHxbXSksZGVsZXRlIHQuX19yfXIodC5fX2MpJiYodC5jaGFuZ2U9W10uY29uY2F0KHQuX19jLHQuY2hhbmdlfHxbXSksZGVsZXRlIHQuX19jKX0obyksV3QobyxpLGVpLG5pLFFvLGUuY29udGV4dCksWG89dm9pZCAwfX12YXIgb2ksaWk9e2NyZWF0ZTpyaSx1cGRhdGU6cmksZGVzdHJveTpmdW5jdGlvbih0KXtyZXR1cm4gcmkodCxpbyl9fTtmdW5jdGlvbiBhaSh0LGUpe2lmKCFuKHQuZGF0YS5kb21Qcm9wcyl8fCFuKGUuZGF0YS5kb21Qcm9wcykpe3ZhciBpLGEscz1lLmVsbSxjPXQuZGF0YS5kb21Qcm9wc3x8e30sdT1lLmRhdGEuZG9tUHJvcHN8fHt9O2ZvcihpIGluKHIodS5fX29iX18pfHxvKHUuX3ZfYXR0cl9wcm94eSkpJiYodT1lLmRhdGEuZG9tUHJvcHM9VCh7fSx1KSksYylpIGluIHV8fChzW2ldPVwiXCIpO2ZvcihpIGluIHUpe2lmKGE9dVtpXSxcInRleHRDb250ZW50XCI9PT1pfHxcImlubmVySFRNTFwiPT09aSl7aWYoZS5jaGlsZHJlbiYmKGUuY2hpbGRyZW4ubGVuZ3RoPTApLGE9PT1jW2ldKWNvbnRpbnVlOzE9PT1zLmNoaWxkTm9kZXMubGVuZ3RoJiZzLnJlbW92ZUNoaWxkKHMuY2hpbGROb2Rlc1swXSl9aWYoXCJ2YWx1ZVwiPT09aSYmXCJQUk9HUkVTU1wiIT09cy50YWdOYW1lKXtzLl92YWx1ZT1hO3ZhciBsPW4oYSk/XCJcIjpTdHJpbmcoYSk7c2kocyxsKSYmKHMudmFsdWU9bCl9ZWxzZSBpZihcImlubmVySFRNTFwiPT09aSYmWnIocy50YWdOYW1lKSYmbihzLmlubmVySFRNTCkpeyhvaT1vaXx8ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkuaW5uZXJIVE1MPVwiPHN2Zz5cIi5jb25jYXQoYSxcIjwvc3ZnPlwiKTtmb3IodmFyIGY9b2kuZmlyc3RDaGlsZDtzLmZpcnN0Q2hpbGQ7KXMucmVtb3ZlQ2hpbGQocy5maXJzdENoaWxkKTtmb3IoO2YuZmlyc3RDaGlsZDspcy5hcHBlbmRDaGlsZChmLmZpcnN0Q2hpbGQpfWVsc2UgaWYoYSE9PWNbaV0pdHJ5e3NbaV09YX1jYXRjaCh0KXt9fX19ZnVuY3Rpb24gc2kodCxlKXtyZXR1cm4hdC5jb21wb3NpbmcmJihcIk9QVElPTlwiPT09dC50YWdOYW1lfHxmdW5jdGlvbih0LGUpe3ZhciBuPSEwO3RyeXtuPWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQhPT10fWNhdGNoKHQpe31yZXR1cm4gbiYmdC52YWx1ZSE9PWV9KHQsZSl8fGZ1bmN0aW9uKHQsZSl7dmFyIG49dC52YWx1ZSxvPXQuX3ZNb2RpZmllcnM7aWYocihvKSl7aWYoby5udW1iZXIpcmV0dXJuIHAobikhPT1wKGUpO2lmKG8udHJpbSlyZXR1cm4gbi50cmltKCkhPT1lLnRyaW0oKX1yZXR1cm4gbiE9PWV9KHQsZSkpfXZhciBjaT17Y3JlYXRlOmFpLHVwZGF0ZTphaX0sdWk9YigoZnVuY3Rpb24odCl7dmFyIGU9e30sbj0vOiguKykvO3JldHVybiB0LnNwbGl0KC87KD8hW14oXSpcXCkpL2cpLmZvckVhY2goKGZ1bmN0aW9uKHQpe2lmKHQpe3ZhciByPXQuc3BsaXQobik7ci5sZW5ndGg+MSYmKGVbclswXS50cmltKCldPXJbMV0udHJpbSgpKX19KSksZX0pKTtmdW5jdGlvbiBsaSh0KXt2YXIgZT1maSh0LnN0eWxlKTtyZXR1cm4gdC5zdGF0aWNTdHlsZT9UKHQuc3RhdGljU3R5bGUsZSk6ZX1mdW5jdGlvbiBmaSh0KXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0KT9BKHQpOlwic3RyaW5nXCI9PXR5cGVvZiB0P3VpKHQpOnR9dmFyIGRpLHBpPS9eLS0vLHZpPS9cXHMqIWltcG9ydGFudCQvLGhpPWZ1bmN0aW9uKHQsZSxuKXtpZihwaS50ZXN0KGUpKXQuc3R5bGUuc2V0UHJvcGVydHkoZSxuKTtlbHNlIGlmKHZpLnRlc3QobikpdC5zdHlsZS5zZXRQcm9wZXJ0eShrKGUpLG4ucmVwbGFjZSh2aSxcIlwiKSxcImltcG9ydGFudFwiKTtlbHNle3ZhciByPWdpKGUpO2lmKEFycmF5LmlzQXJyYXkobikpZm9yKHZhciBvPTAsaT1uLmxlbmd0aDtvPGk7bysrKXQuc3R5bGVbcl09bltvXTtlbHNlIHQuc3R5bGVbcl09bn19LG1pPVtcIldlYmtpdFwiLFwiTW96XCIsXCJtc1wiXSxnaT1iKChmdW5jdGlvbih0KXtpZihkaT1kaXx8ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKS5zdHlsZSxcImZpbHRlclwiIT09KHQ9dyh0KSkmJnQgaW4gZGkpcmV0dXJuIHQ7Zm9yKHZhciBlPXQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrdC5zbGljZSgxKSxuPTA7bjxtaS5sZW5ndGg7bisrKXt2YXIgcj1taVtuXStlO2lmKHIgaW4gZGkpcmV0dXJuIHJ9fSkpO2Z1bmN0aW9uIHlpKHQsZSl7dmFyIG89ZS5kYXRhLGk9dC5kYXRhO2lmKCEobihvLnN0YXRpY1N0eWxlKSYmbihvLnN0eWxlKSYmbihpLnN0YXRpY1N0eWxlKSYmbihpLnN0eWxlKSkpe3ZhciBhLHMsYz1lLmVsbSx1PWkuc3RhdGljU3R5bGUsbD1pLm5vcm1hbGl6ZWRTdHlsZXx8aS5zdHlsZXx8e30sZj11fHxsLGQ9ZmkoZS5kYXRhLnN0eWxlKXx8e307ZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZT1yKGQuX19vYl9fKT9UKHt9LGQpOmQ7dmFyIHA9ZnVuY3Rpb24odCxlKXt2YXIgbixyPXt9O2lmKGUpZm9yKHZhciBvPXQ7by5jb21wb25lbnRJbnN0YW5jZTspKG89by5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpJiZvLmRhdGEmJihuPWxpKG8uZGF0YSkpJiZUKHIsbik7KG49bGkodC5kYXRhKSkmJlQocixuKTtmb3IodmFyIGk9dDtpPWkucGFyZW50OylpLmRhdGEmJihuPWxpKGkuZGF0YSkpJiZUKHIsbik7cmV0dXJuIHJ9KGUsITApO2ZvcihzIGluIGYpbihwW3NdKSYmaGkoYyxzLFwiXCIpO2ZvcihzIGluIHApKGE9cFtzXSkhPT1mW3NdJiZoaShjLHMsbnVsbD09YT9cIlwiOmEpfX12YXIgX2k9e2NyZWF0ZTp5aSx1cGRhdGU6eWl9LGJpPS9cXHMrLztmdW5jdGlvbiAkaSh0LGUpe2lmKGUmJihlPWUudHJpbSgpKSlpZih0LmNsYXNzTGlzdCllLmluZGV4T2YoXCIgXCIpPi0xP2Uuc3BsaXQoYmkpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiB0LmNsYXNzTGlzdC5hZGQoZSl9KSk6dC5jbGFzc0xpc3QuYWRkKGUpO2Vsc2V7dmFyIG49XCIgXCIuY29uY2F0KHQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIil8fFwiXCIsXCIgXCIpO24uaW5kZXhPZihcIiBcIitlK1wiIFwiKTwwJiZ0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsKG4rZSkudHJpbSgpKX19ZnVuY3Rpb24gd2kodCxlKXtpZihlJiYoZT1lLnRyaW0oKSkpaWYodC5jbGFzc0xpc3QpZS5pbmRleE9mKFwiIFwiKT4tMT9lLnNwbGl0KGJpKS5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gdC5jbGFzc0xpc3QucmVtb3ZlKGUpfSkpOnQuY2xhc3NMaXN0LnJlbW92ZShlKSx0LmNsYXNzTGlzdC5sZW5ndGh8fHQucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIik7ZWxzZXtmb3IodmFyIG49XCIgXCIuY29uY2F0KHQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIil8fFwiXCIsXCIgXCIpLHI9XCIgXCIrZStcIiBcIjtuLmluZGV4T2Yocik+PTA7KW49bi5yZXBsYWNlKHIsXCIgXCIpOyhuPW4udHJpbSgpKT90LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsbik6dC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKX19ZnVuY3Rpb24geGkodCl7aWYodCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIHQpe3ZhciBlPXt9O3JldHVybiExIT09dC5jc3MmJlQoZSxDaSh0Lm5hbWV8fFwidlwiKSksVChlLHQpLGV9cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQ/Q2kodCk6dm9pZCAwfX12YXIgQ2k9YigoZnVuY3Rpb24odCl7cmV0dXJue2VudGVyQ2xhc3M6XCJcIi5jb25jYXQodCxcIi1lbnRlclwiKSxlbnRlclRvQ2xhc3M6XCJcIi5jb25jYXQodCxcIi1lbnRlci10b1wiKSxlbnRlckFjdGl2ZUNsYXNzOlwiXCIuY29uY2F0KHQsXCItZW50ZXItYWN0aXZlXCIpLGxlYXZlQ2xhc3M6XCJcIi5jb25jYXQodCxcIi1sZWF2ZVwiKSxsZWF2ZVRvQ2xhc3M6XCJcIi5jb25jYXQodCxcIi1sZWF2ZS10b1wiKSxsZWF2ZUFjdGl2ZUNsYXNzOlwiXCIuY29uY2F0KHQsXCItbGVhdmUtYWN0aXZlXCIpfX0pKSxraT1KJiYhWixTaT1cInRyYW5zaXRpb25cIixPaT1cImFuaW1hdGlvblwiLFRpPVwidHJhbnNpdGlvblwiLEFpPVwidHJhbnNpdGlvbmVuZFwiLGppPVwiYW5pbWF0aW9uXCIsRWk9XCJhbmltYXRpb25lbmRcIjtraSYmKHZvaWQgMD09PXdpbmRvdy5vbnRyYW5zaXRpb25lbmQmJnZvaWQgMCE9PXdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQmJihUaT1cIldlYmtpdFRyYW5zaXRpb25cIixBaT1cIndlYmtpdFRyYW5zaXRpb25FbmRcIiksdm9pZCAwPT09d2luZG93Lm9uYW5pbWF0aW9uZW5kJiZ2b2lkIDAhPT13aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQmJihqaT1cIldlYmtpdEFuaW1hdGlvblwiLEVpPVwid2Via2l0QW5pbWF0aW9uRW5kXCIpKTt2YXIgTmk9Sj93aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lP3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpOnNldFRpbWVvdXQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQoKX07ZnVuY3Rpb24gUGkodCl7TmkoKGZ1bmN0aW9uKCl7TmkodCl9KSl9ZnVuY3Rpb24gRGkodCxlKXt2YXIgbj10Ll90cmFuc2l0aW9uQ2xhc3Nlc3x8KHQuX3RyYW5zaXRpb25DbGFzc2VzPVtdKTtuLmluZGV4T2YoZSk8MCYmKG4ucHVzaChlKSwkaSh0LGUpKX1mdW5jdGlvbiBNaSh0LGUpe3QuX3RyYW5zaXRpb25DbGFzc2VzJiZnKHQuX3RyYW5zaXRpb25DbGFzc2VzLGUpLHdpKHQsZSl9ZnVuY3Rpb24gSWkodCxlLG4pe3ZhciByPVJpKHQsZSksbz1yLnR5cGUsaT1yLnRpbWVvdXQsYT1yLnByb3BDb3VudDtpZighbylyZXR1cm4gbigpO3ZhciBzPW89PT1TaT9BaTpFaSxjPTAsdT1mdW5jdGlvbigpe3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihzLGwpLG4oKX0sbD1mdW5jdGlvbihlKXtlLnRhcmdldD09PXQmJisrYz49YSYmdSgpfTtzZXRUaW1lb3V0KChmdW5jdGlvbigpe2M8YSYmdSgpfSksaSsxKSx0LmFkZEV2ZW50TGlzdGVuZXIocyxsKX12YXIgTGk9L1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztmdW5jdGlvbiBSaSh0LGUpe3ZhciBuLHI9d2luZG93LmdldENvbXB1dGVkU3R5bGUodCksbz0ocltUaStcIkRlbGF5XCJdfHxcIlwiKS5zcGxpdChcIiwgXCIpLGk9KHJbVGkrXCJEdXJhdGlvblwiXXx8XCJcIikuc3BsaXQoXCIsIFwiKSxhPUZpKG8saSkscz0ocltqaStcIkRlbGF5XCJdfHxcIlwiKS5zcGxpdChcIiwgXCIpLGM9KHJbamkrXCJEdXJhdGlvblwiXXx8XCJcIikuc3BsaXQoXCIsIFwiKSx1PUZpKHMsYyksbD0wLGY9MDtyZXR1cm4gZT09PVNpP2E+MCYmKG49U2ksbD1hLGY9aS5sZW5ndGgpOmU9PT1PaT91PjAmJihuPU9pLGw9dSxmPWMubGVuZ3RoKTpmPShuPShsPU1hdGgubWF4KGEsdSkpPjA/YT51P1NpOk9pOm51bGwpP249PT1TaT9pLmxlbmd0aDpjLmxlbmd0aDowLHt0eXBlOm4sdGltZW91dDpsLHByb3BDb3VudDpmLGhhc1RyYW5zZm9ybTpuPT09U2kmJkxpLnRlc3QocltUaStcIlByb3BlcnR5XCJdKX19ZnVuY3Rpb24gRmkodCxlKXtmb3IoO3QubGVuZ3RoPGUubGVuZ3RoOyl0PXQuY29uY2F0KHQpO3JldHVybiBNYXRoLm1heC5hcHBseShudWxsLGUubWFwKChmdW5jdGlvbihlLG4pe3JldHVybiBIaShlKStIaSh0W25dKX0pKSl9ZnVuY3Rpb24gSGkodCl7cmV0dXJuIDFlMypOdW1iZXIodC5zbGljZSgwLC0xKS5yZXBsYWNlKFwiLFwiLFwiLlwiKSl9ZnVuY3Rpb24gQmkodCxlKXt2YXIgbz10LmVsbTtyKG8uX2xlYXZlQ2IpJiYoby5fbGVhdmVDYi5jYW5jZWxsZWQ9ITAsby5fbGVhdmVDYigpKTt2YXIgaT14aSh0LmRhdGEudHJhbnNpdGlvbik7aWYoIW4oaSkmJiFyKG8uX2VudGVyQ2IpJiYxPT09by5ub2RlVHlwZSl7Zm9yKHZhciBjPWkuY3NzLHU9aS50eXBlLGw9aS5lbnRlckNsYXNzLGY9aS5lbnRlclRvQ2xhc3MsZD1pLmVudGVyQWN0aXZlQ2xhc3Msdj1pLmFwcGVhckNsYXNzLGg9aS5hcHBlYXJUb0NsYXNzLG09aS5hcHBlYXJBY3RpdmVDbGFzcyxnPWkuYmVmb3JlRW50ZXIseT1pLmVudGVyLF89aS5hZnRlckVudGVyLGI9aS5lbnRlckNhbmNlbGxlZCwkPWkuYmVmb3JlQXBwZWFyLHc9aS5hcHBlYXIseD1pLmFmdGVyQXBwZWFyLEM9aS5hcHBlYXJDYW5jZWxsZWQsaz1pLmR1cmF0aW9uLFM9SWUsTz1JZS4kdm5vZGU7TyYmTy5wYXJlbnQ7KVM9Ty5jb250ZXh0LE89Ty5wYXJlbnQ7dmFyIFQ9IVMuX2lzTW91bnRlZHx8IXQuaXNSb290SW5zZXJ0O2lmKCFUfHx3fHxcIlwiPT09dyl7dmFyIEE9VCYmdj92Omwsaj1UJiZtP206ZCxFPVQmJmg/aDpmLE49VCYmJHx8ZyxQPVQmJmEodyk/dzp5LEQ9VCYmeHx8XyxJPVQmJkN8fGIsTD1wKHMoayk/ay5lbnRlcjprKSxSPSExIT09YyYmIVosRj1WaShQKSxIPW8uX2VudGVyQ2I9TSgoZnVuY3Rpb24oKXtSJiYoTWkobyxFKSxNaShvLGopKSxILmNhbmNlbGxlZD8oUiYmTWkobyxBKSxJJiZJKG8pKTpEJiZEKG8pLG8uX2VudGVyQ2I9bnVsbH0pKTt0LmRhdGEuc2hvd3x8WnQodCxcImluc2VydFwiLChmdW5jdGlvbigpe3ZhciBlPW8ucGFyZW50Tm9kZSxuPWUmJmUuX3BlbmRpbmcmJmUuX3BlbmRpbmdbdC5rZXldO24mJm4udGFnPT09dC50YWcmJm4uZWxtLl9sZWF2ZUNiJiZuLmVsbS5fbGVhdmVDYigpLFAmJlAobyxIKX0pKSxOJiZOKG8pLFImJihEaShvLEEpLERpKG8saiksUGkoKGZ1bmN0aW9uKCl7TWkobyxBKSxILmNhbmNlbGxlZHx8KERpKG8sRSksRnx8KHppKEwpP3NldFRpbWVvdXQoSCxMKTpJaShvLHUsSCkpKX0pKSksdC5kYXRhLnNob3cmJihlJiZlKCksUCYmUChvLEgpKSxSfHxGfHxIKCl9fX1mdW5jdGlvbiBVaSh0LGUpe3ZhciBvPXQuZWxtO3Ioby5fZW50ZXJDYikmJihvLl9lbnRlckNiLmNhbmNlbGxlZD0hMCxvLl9lbnRlckNiKCkpO3ZhciBpPXhpKHQuZGF0YS50cmFuc2l0aW9uKTtpZihuKGkpfHwxIT09by5ub2RlVHlwZSlyZXR1cm4gZSgpO2lmKCFyKG8uX2xlYXZlQ2IpKXt2YXIgYT1pLmNzcyxjPWkudHlwZSx1PWkubGVhdmVDbGFzcyxsPWkubGVhdmVUb0NsYXNzLGY9aS5sZWF2ZUFjdGl2ZUNsYXNzLGQ9aS5iZWZvcmVMZWF2ZSx2PWkubGVhdmUsaD1pLmFmdGVyTGVhdmUsbT1pLmxlYXZlQ2FuY2VsbGVkLGc9aS5kZWxheUxlYXZlLHk9aS5kdXJhdGlvbixfPSExIT09YSYmIVosYj1WaSh2KSwkPXAocyh5KT95LmxlYXZlOnkpLHc9by5fbGVhdmVDYj1NKChmdW5jdGlvbigpe28ucGFyZW50Tm9kZSYmby5wYXJlbnROb2RlLl9wZW5kaW5nJiYoby5wYXJlbnROb2RlLl9wZW5kaW5nW3Qua2V5XT1udWxsKSxfJiYoTWkobyxsKSxNaShvLGYpKSx3LmNhbmNlbGxlZD8oXyYmTWkobyx1KSxtJiZtKG8pKTooZSgpLGgmJmgobykpLG8uX2xlYXZlQ2I9bnVsbH0pKTtnP2coeCk6eCgpfWZ1bmN0aW9uIHgoKXt3LmNhbmNlbGxlZHx8KCF0LmRhdGEuc2hvdyYmby5wYXJlbnROb2RlJiYoKG8ucGFyZW50Tm9kZS5fcGVuZGluZ3x8KG8ucGFyZW50Tm9kZS5fcGVuZGluZz17fSkpW3Qua2V5XT10KSxkJiZkKG8pLF8mJihEaShvLHUpLERpKG8sZiksUGkoKGZ1bmN0aW9uKCl7TWkobyx1KSx3LmNhbmNlbGxlZHx8KERpKG8sbCksYnx8KHppKCQpP3NldFRpbWVvdXQodywkKTpJaShvLGMsdykpKX0pKSksdiYmdihvLHcpLF98fGJ8fHcoKSl9fWZ1bmN0aW9uIHppKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0JiYhaXNOYU4odCl9ZnVuY3Rpb24gVmkodCl7aWYobih0KSlyZXR1cm4hMTt2YXIgZT10LmZucztyZXR1cm4gcihlKT9WaShBcnJheS5pc0FycmF5KGUpP2VbMF06ZSk6KHQuX2xlbmd0aHx8dC5sZW5ndGgpPjF9ZnVuY3Rpb24gS2kodCxlKXshMCE9PWUuZGF0YS5zaG93JiZCaShlKX12YXIgSmk9ZnVuY3Rpb24odCl7dmFyIGEscyxjPXt9LHU9dC5tb2R1bGVzLGw9dC5ub2RlT3BzO2ZvcihhPTA7YTxhby5sZW5ndGg7KythKWZvcihjW2FvW2FdXT1bXSxzPTA7czx1Lmxlbmd0aDsrK3Mpcih1W3NdW2FvW2FdXSkmJmNbYW9bYV1dLnB1c2godVtzXVthb1thXV0pO2Z1bmN0aW9uIGYodCl7dmFyIGU9bC5wYXJlbnROb2RlKHQpO3IoZSkmJmwucmVtb3ZlQ2hpbGQoZSx0KX1mdW5jdGlvbiBkKHQsZSxuLGksYSxzLHUpe2lmKHIodC5lbG0pJiZyKHMpJiYodD1zW3VdPXB0KHQpKSx0LmlzUm9vdEluc2VydD0hYSwhZnVuY3Rpb24odCxlLG4saSl7dmFyIGE9dC5kYXRhO2lmKHIoYSkpe3ZhciBzPXIodC5jb21wb25lbnRJbnN0YW5jZSkmJmEua2VlcEFsaXZlO2lmKHIoYT1hLmhvb2spJiZyKGE9YS5pbml0KSYmYSh0LCExKSxyKHQuY29tcG9uZW50SW5zdGFuY2UpKXJldHVybiBwKHQsZSksaChuLHQuZWxtLGkpLG8ocykmJmZ1bmN0aW9uKHQsZSxuLG8pe3ZhciBpLGE9dDtmb3IoO2EuY29tcG9uZW50SW5zdGFuY2U7KWlmKHIoaT0oYT1hLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSkuZGF0YSkmJnIoaT1pLnRyYW5zaXRpb24pKXtmb3IoaT0wO2k8Yy5hY3RpdmF0ZS5sZW5ndGg7KytpKWMuYWN0aXZhdGVbaV0oaW8sYSk7ZS5wdXNoKGEpO2JyZWFrfWgobix0LmVsbSxvKX0odCxlLG4saSksITB9fSh0LGUsbixpKSl7dmFyIGY9dC5kYXRhLGQ9dC5jaGlsZHJlbix2PXQudGFnO3Iodik/KHQuZWxtPXQubnM/bC5jcmVhdGVFbGVtZW50TlModC5ucyx2KTpsLmNyZWF0ZUVsZW1lbnQodix0KSxfKHQpLG0odCxkLGUpLHIoZikmJnkodCxlKSxoKG4sdC5lbG0saSkpOm8odC5pc0NvbW1lbnQpPyh0LmVsbT1sLmNyZWF0ZUNvbW1lbnQodC50ZXh0KSxoKG4sdC5lbG0saSkpOih0LmVsbT1sLmNyZWF0ZVRleHROb2RlKHQudGV4dCksaChuLHQuZWxtLGkpKX19ZnVuY3Rpb24gcCh0LGUpe3IodC5kYXRhLnBlbmRpbmdJbnNlcnQpJiYoZS5wdXNoLmFwcGx5KGUsdC5kYXRhLnBlbmRpbmdJbnNlcnQpLHQuZGF0YS5wZW5kaW5nSW5zZXJ0PW51bGwpLHQuZWxtPXQuY29tcG9uZW50SW5zdGFuY2UuJGVsLGcodCk/KHkodCxlKSxfKHQpKToocm8odCksZS5wdXNoKHQpKX1mdW5jdGlvbiBoKHQsZSxuKXtyKHQpJiYocihuKT9sLnBhcmVudE5vZGUobik9PT10JiZsLmluc2VydEJlZm9yZSh0LGUsbik6bC5hcHBlbmRDaGlsZCh0LGUpKX1mdW5jdGlvbiBtKHQsbixyKXtpZihlKG4pKWZvcih2YXIgbz0wO288bi5sZW5ndGg7KytvKWQobltvXSxyLHQuZWxtLG51bGwsITAsbixvKTtlbHNlIGkodC50ZXh0KSYmbC5hcHBlbmRDaGlsZCh0LmVsbSxsLmNyZWF0ZVRleHROb2RlKFN0cmluZyh0LnRleHQpKSl9ZnVuY3Rpb24gZyh0KXtmb3IoO3QuY29tcG9uZW50SW5zdGFuY2U7KXQ9dC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7cmV0dXJuIHIodC50YWcpfWZ1bmN0aW9uIHkodCxlKXtmb3IodmFyIG49MDtuPGMuY3JlYXRlLmxlbmd0aDsrK24pYy5jcmVhdGVbbl0oaW8sdCk7cihhPXQuZGF0YS5ob29rKSYmKHIoYS5jcmVhdGUpJiZhLmNyZWF0ZShpbyx0KSxyKGEuaW5zZXJ0KSYmZS5wdXNoKHQpKX1mdW5jdGlvbiBfKHQpe3ZhciBlO2lmKHIoZT10LmZuU2NvcGVJZCkpbC5zZXRTdHlsZVNjb3BlKHQuZWxtLGUpO2Vsc2UgZm9yKHZhciBuPXQ7bjspcihlPW4uY29udGV4dCkmJnIoZT1lLiRvcHRpb25zLl9zY29wZUlkKSYmbC5zZXRTdHlsZVNjb3BlKHQuZWxtLGUpLG49bi5wYXJlbnQ7cihlPUllKSYmZSE9PXQuY29udGV4dCYmZSE9PXQuZm5Db250ZXh0JiZyKGU9ZS4kb3B0aW9ucy5fc2NvcGVJZCkmJmwuc2V0U3R5bGVTY29wZSh0LmVsbSxlKX1mdW5jdGlvbiBiKHQsZSxuLHIsbyxpKXtmb3IoO3I8PW87KytyKWQobltyXSxpLHQsZSwhMSxuLHIpfWZ1bmN0aW9uICQodCl7dmFyIGUsbixvPXQuZGF0YTtpZihyKG8pKWZvcihyKGU9by5ob29rKSYmcihlPWUuZGVzdHJveSkmJmUodCksZT0wO2U8Yy5kZXN0cm95Lmxlbmd0aDsrK2UpYy5kZXN0cm95W2VdKHQpO2lmKHIoZT10LmNoaWxkcmVuKSlmb3Iobj0wO248dC5jaGlsZHJlbi5sZW5ndGg7KytuKSQodC5jaGlsZHJlbltuXSl9ZnVuY3Rpb24gdyh0LGUsbil7Zm9yKDtlPD1uOysrZSl7dmFyIG89dFtlXTtyKG8pJiYocihvLnRhZyk/KHgobyksJChvKSk6ZihvLmVsbSkpfX1mdW5jdGlvbiB4KHQsZSl7aWYocihlKXx8cih0LmRhdGEpKXt2YXIgbixvPWMucmVtb3ZlLmxlbmd0aCsxO2ZvcihyKGUpP2UubGlzdGVuZXJzKz1vOmU9ZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7MD09LS1uLmxpc3RlbmVycyYmZih0KX1yZXR1cm4gbi5saXN0ZW5lcnM9ZSxufSh0LmVsbSxvKSxyKG49dC5jb21wb25lbnRJbnN0YW5jZSkmJnIobj1uLl92bm9kZSkmJnIobi5kYXRhKSYmeChuLGUpLG49MDtuPGMucmVtb3ZlLmxlbmd0aDsrK24pYy5yZW1vdmVbbl0odCxlKTtyKG49dC5kYXRhLmhvb2spJiZyKG49bi5yZW1vdmUpP24odCxlKTplKCl9ZWxzZSBmKHQuZWxtKX1mdW5jdGlvbiBDKHQsZSxuLG8pe2Zvcih2YXIgaT1uO2k8bztpKyspe3ZhciBhPWVbaV07aWYocihhKSYmc28odCxhKSlyZXR1cm4gaX19ZnVuY3Rpb24gayh0LGUsaSxhLHMsdSl7aWYodCE9PWUpe3IoZS5lbG0pJiZyKGEpJiYoZT1hW3NdPXB0KGUpKTt2YXIgZj1lLmVsbT10LmVsbTtpZihvKHQuaXNBc3luY1BsYWNlaG9sZGVyKSlyKGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKT9UKHQuZWxtLGUsaSk6ZS5pc0FzeW5jUGxhY2Vob2xkZXI9ITA7ZWxzZSBpZihvKGUuaXNTdGF0aWMpJiZvKHQuaXNTdGF0aWMpJiZlLmtleT09PXQua2V5JiYobyhlLmlzQ2xvbmVkKXx8byhlLmlzT25jZSkpKWUuY29tcG9uZW50SW5zdGFuY2U9dC5jb21wb25lbnRJbnN0YW5jZTtlbHNle3ZhciBwLHY9ZS5kYXRhO3IodikmJnIocD12Lmhvb2spJiZyKHA9cC5wcmVwYXRjaCkmJnAodCxlKTt2YXIgaD10LmNoaWxkcmVuLG09ZS5jaGlsZHJlbjtpZihyKHYpJiZnKGUpKXtmb3IocD0wO3A8Yy51cGRhdGUubGVuZ3RoOysrcCljLnVwZGF0ZVtwXSh0LGUpO3IocD12Lmhvb2spJiZyKHA9cC51cGRhdGUpJiZwKHQsZSl9bihlLnRleHQpP3IoaCkmJnIobSk/aCE9PW0mJmZ1bmN0aW9uKHQsZSxvLGksYSl7Zm9yKHZhciBzLGMsdSxmPTAscD0wLHY9ZS5sZW5ndGgtMSxoPWVbMF0sbT1lW3ZdLGc9by5sZW5ndGgtMSx5PW9bMF0sXz1vW2ddLCQ9IWE7Zjw9diYmcDw9ZzspbihoKT9oPWVbKytmXTpuKG0pP209ZVstLXZdOnNvKGgseSk/KGsoaCx5LGksbyxwKSxoPWVbKytmXSx5PW9bKytwXSk6c28obSxfKT8oayhtLF8saSxvLGcpLG09ZVstLXZdLF89b1stLWddKTpzbyhoLF8pPyhrKGgsXyxpLG8sZyksJCYmbC5pbnNlcnRCZWZvcmUodCxoLmVsbSxsLm5leHRTaWJsaW5nKG0uZWxtKSksaD1lWysrZl0sXz1vWy0tZ10pOnNvKG0seSk/KGsobSx5LGksbyxwKSwkJiZsLmluc2VydEJlZm9yZSh0LG0uZWxtLGguZWxtKSxtPWVbLS12XSx5PW9bKytwXSk6KG4ocykmJihzPWNvKGUsZix2KSksbihjPXIoeS5rZXkpP3NbeS5rZXldOkMoeSxlLGYsdikpP2QoeSxpLHQsaC5lbG0sITEsbyxwKTpzbyh1PWVbY10seSk/KGsodSx5LGksbyxwKSxlW2NdPXZvaWQgMCwkJiZsLmluc2VydEJlZm9yZSh0LHUuZWxtLGguZWxtKSk6ZCh5LGksdCxoLmVsbSwhMSxvLHApLHk9b1srK3BdKTtmPnY/Yih0LG4ob1tnKzFdKT9udWxsOm9bZysxXS5lbG0sbyxwLGcsaSk6cD5nJiZ3KGUsZix2KX0oZixoLG0saSx1KTpyKG0pPyhyKHQudGV4dCkmJmwuc2V0VGV4dENvbnRlbnQoZixcIlwiKSxiKGYsbnVsbCxtLDAsbS5sZW5ndGgtMSxpKSk6cihoKT93KGgsMCxoLmxlbmd0aC0xKTpyKHQudGV4dCkmJmwuc2V0VGV4dENvbnRlbnQoZixcIlwiKTp0LnRleHQhPT1lLnRleHQmJmwuc2V0VGV4dENvbnRlbnQoZixlLnRleHQpLHIodikmJnIocD12Lmhvb2spJiZyKHA9cC5wb3N0cGF0Y2gpJiZwKHQsZSl9fX1mdW5jdGlvbiBTKHQsZSxuKXtpZihvKG4pJiZyKHQucGFyZW50KSl0LnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQ9ZTtlbHNlIGZvcih2YXIgaT0wO2k8ZS5sZW5ndGg7KytpKWVbaV0uZGF0YS5ob29rLmluc2VydChlW2ldKX12YXIgTz12KFwiYXR0cnMsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5XCIpO2Z1bmN0aW9uIFQodCxlLG4saSl7dmFyIGEscz1lLnRhZyxjPWUuZGF0YSx1PWUuY2hpbGRyZW47aWYoaT1pfHxjJiZjLnByZSxlLmVsbT10LG8oZS5pc0NvbW1lbnQpJiZyKGUuYXN5bmNGYWN0b3J5KSlyZXR1cm4gZS5pc0FzeW5jUGxhY2Vob2xkZXI9ITAsITA7aWYocihjKSYmKHIoYT1jLmhvb2spJiZyKGE9YS5pbml0KSYmYShlLCEwKSxyKGE9ZS5jb21wb25lbnRJbnN0YW5jZSkpKXJldHVybiBwKGUsbiksITA7aWYocihzKSl7aWYocih1KSlpZih0Lmhhc0NoaWxkTm9kZXMoKSlpZihyKGE9YykmJnIoYT1hLmRvbVByb3BzKSYmcihhPWEuaW5uZXJIVE1MKSl7aWYoYSE9PXQuaW5uZXJIVE1MKXJldHVybiExfWVsc2V7Zm9yKHZhciBsPSEwLGY9dC5maXJzdENoaWxkLGQ9MDtkPHUubGVuZ3RoO2QrKyl7aWYoIWZ8fCFUKGYsdVtkXSxuLGkpKXtsPSExO2JyZWFrfWY9Zi5uZXh0U2libGluZ31pZighbHx8ZilyZXR1cm4hMX1lbHNlIG0oZSx1LG4pO2lmKHIoYykpe3ZhciB2PSExO2Zvcih2YXIgaCBpbiBjKWlmKCFPKGgpKXt2PSEwLHkoZSxuKTticmVha30hdiYmYy5jbGFzcyYmQm4oYy5jbGFzcyl9fWVsc2UgdC5kYXRhIT09ZS50ZXh0JiYodC5kYXRhPWUudGV4dCk7cmV0dXJuITB9cmV0dXJuIGZ1bmN0aW9uKHQsZSxpLGEpe2lmKCFuKGUpKXt2YXIgcyx1PSExLGY9W107aWYobih0KSl1PSEwLGQoZSxmKTtlbHNle3ZhciBwPXIodC5ub2RlVHlwZSk7aWYoIXAmJnNvKHQsZSkpayh0LGUsZixudWxsLG51bGwsYSk7ZWxzZXtpZihwKXtpZigxPT09dC5ub2RlVHlwZSYmdC5oYXNBdHRyaWJ1dGUoTCkmJih0LnJlbW92ZUF0dHJpYnV0ZShMKSxpPSEwKSxvKGkpJiZUKHQsZSxmKSlyZXR1cm4gUyhlLGYsITApLHQ7cz10LHQ9bmV3IGx0KGwudGFnTmFtZShzKS50b0xvd2VyQ2FzZSgpLHt9LFtdLHZvaWQgMCxzKX12YXIgdj10LmVsbSxoPWwucGFyZW50Tm9kZSh2KTtpZihkKGUsZix2Ll9sZWF2ZUNiP251bGw6aCxsLm5leHRTaWJsaW5nKHYpKSxyKGUucGFyZW50KSlmb3IodmFyIG09ZS5wYXJlbnQseT1nKGUpO207KXtmb3IodmFyIF89MDtfPGMuZGVzdHJveS5sZW5ndGg7KytfKWMuZGVzdHJveVtfXShtKTtpZihtLmVsbT1lLmVsbSx5KXtmb3IodmFyIGI9MDtiPGMuY3JlYXRlLmxlbmd0aDsrK2IpYy5jcmVhdGVbYl0oaW8sbSk7dmFyIHg9bS5kYXRhLmhvb2suaW5zZXJ0O2lmKHgubWVyZ2VkKWZvcih2YXIgQz0xO0M8eC5mbnMubGVuZ3RoO0MrKyl4LmZuc1tDXSgpfWVsc2Ugcm8obSk7bT1tLnBhcmVudH1yKGgpP3coW3RdLDAsMCk6cih0LnRhZykmJiQodCl9fXJldHVybiBTKGUsZix1KSxlLmVsbX1yKHQpJiYkKHQpfX0oe25vZGVPcHM6ZW8sbW9kdWxlczpbYm8sVG8saWksY2ksX2ksSj97Y3JlYXRlOktpLGFjdGl2YXRlOktpLHJlbW92ZTpmdW5jdGlvbih0LGUpeyEwIT09dC5kYXRhLnNob3c/VWkodCxlKTplKCl9fTp7fV0uY29uY2F0KG1vKX0pO1omJmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwoZnVuY3Rpb24oKXt2YXIgdD1kb2N1bWVudC5hY3RpdmVFbGVtZW50O3QmJnQudm1vZGVsJiZ0YSh0LFwiaW5wdXRcIil9KSk7dmFyIHFpPXtpbnNlcnRlZDpmdW5jdGlvbih0LGUsbixyKXtcInNlbGVjdFwiPT09bi50YWc/KHIuZWxtJiYhci5lbG0uX3ZPcHRpb25zP1p0KG4sXCJwb3N0cGF0Y2hcIiwoZnVuY3Rpb24oKXtxaS5jb21wb25lbnRVcGRhdGVkKHQsZSxuKX0pKTpXaSh0LGUsbi5jb250ZXh0KSx0Ll92T3B0aW9ucz1bXS5tYXAuY2FsbCh0Lm9wdGlvbnMsWGkpKTooXCJ0ZXh0YXJlYVwiPT09bi50YWd8fFFyKHQudHlwZSkpJiYodC5fdk1vZGlmaWVycz1lLm1vZGlmaWVycyxlLm1vZGlmaWVycy5sYXp5fHwodC5hZGRFdmVudExpc3RlbmVyKFwiY29tcG9zaXRpb25zdGFydFwiLFlpKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJjb21wb3NpdGlvbmVuZFwiLFFpKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIixRaSksWiYmKHQudm1vZGVsPSEwKSkpfSxjb21wb25lbnRVcGRhdGVkOmZ1bmN0aW9uKHQsZSxuKXtpZihcInNlbGVjdFwiPT09bi50YWcpe1dpKHQsZSxuLmNvbnRleHQpO3ZhciByPXQuX3ZPcHRpb25zLG89dC5fdk9wdGlvbnM9W10ubWFwLmNhbGwodC5vcHRpb25zLFhpKTtpZihvLnNvbWUoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIVAodCxyW2VdKX0pKSkodC5tdWx0aXBsZT9lLnZhbHVlLnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiBHaSh0LG8pfSkpOmUudmFsdWUhPT1lLm9sZFZhbHVlJiZHaShlLnZhbHVlLG8pKSYmdGEodCxcImNoYW5nZVwiKX19fTtmdW5jdGlvbiBXaSh0LGUsbil7WmkodCxlKSwoV3x8RykmJnNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7WmkodCxlKX0pLDApfWZ1bmN0aW9uIFppKHQsZSxuKXt2YXIgcj1lLnZhbHVlLG89dC5tdWx0aXBsZTtpZighb3x8QXJyYXkuaXNBcnJheShyKSl7Zm9yKHZhciBpLGEscz0wLGM9dC5vcHRpb25zLmxlbmd0aDtzPGM7cysrKWlmKGE9dC5vcHRpb25zW3NdLG8paT1EKHIsWGkoYSkpPi0xLGEuc2VsZWN0ZWQhPT1pJiYoYS5zZWxlY3RlZD1pKTtlbHNlIGlmKFAoWGkoYSkscikpcmV0dXJuIHZvaWQodC5zZWxlY3RlZEluZGV4IT09cyYmKHQuc2VsZWN0ZWRJbmRleD1zKSk7b3x8KHQuc2VsZWN0ZWRJbmRleD0tMSl9fWZ1bmN0aW9uIEdpKHQsZSl7cmV0dXJuIGUuZXZlcnkoKGZ1bmN0aW9uKGUpe3JldHVybiFQKGUsdCl9KSl9ZnVuY3Rpb24gWGkodCl7cmV0dXJuXCJfdmFsdWVcImluIHQ/dC5fdmFsdWU6dC52YWx1ZX1mdW5jdGlvbiBZaSh0KXt0LnRhcmdldC5jb21wb3Npbmc9ITB9ZnVuY3Rpb24gUWkodCl7dC50YXJnZXQuY29tcG9zaW5nJiYodC50YXJnZXQuY29tcG9zaW5nPSExLHRhKHQudGFyZ2V0LFwiaW5wdXRcIikpfWZ1bmN0aW9uIHRhKHQsZSl7dmFyIG49ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJIVE1MRXZlbnRzXCIpO24uaW5pdEV2ZW50KGUsITAsITApLHQuZGlzcGF0Y2hFdmVudChuKX1mdW5jdGlvbiBlYSh0KXtyZXR1cm4hdC5jb21wb25lbnRJbnN0YW5jZXx8dC5kYXRhJiZ0LmRhdGEudHJhbnNpdGlvbj90OmVhKHQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKX12YXIgbmE9e2JpbmQ6ZnVuY3Rpb24odCxlLG4pe3ZhciByPWUudmFsdWUsbz0obj1lYShuKSkuZGF0YSYmbi5kYXRhLnRyYW5zaXRpb24saT10Ll9fdk9yaWdpbmFsRGlzcGxheT1cIm5vbmVcIj09PXQuc3R5bGUuZGlzcGxheT9cIlwiOnQuc3R5bGUuZGlzcGxheTtyJiZvPyhuLmRhdGEuc2hvdz0hMCxCaShuLChmdW5jdGlvbigpe3Quc3R5bGUuZGlzcGxheT1pfSkpKTp0LnN0eWxlLmRpc3BsYXk9cj9pOlwibm9uZVwifSx1cGRhdGU6ZnVuY3Rpb24odCxlLG4pe3ZhciByPWUudmFsdWU7IXIhPSFlLm9sZFZhbHVlJiYoKG49ZWEobikpLmRhdGEmJm4uZGF0YS50cmFuc2l0aW9uPyhuLmRhdGEuc2hvdz0hMCxyP0JpKG4sKGZ1bmN0aW9uKCl7dC5zdHlsZS5kaXNwbGF5PXQuX192T3JpZ2luYWxEaXNwbGF5fSkpOlVpKG4sKGZ1bmN0aW9uKCl7dC5zdHlsZS5kaXNwbGF5PVwibm9uZVwifSkpKTp0LnN0eWxlLmRpc3BsYXk9cj90Ll9fdk9yaWdpbmFsRGlzcGxheTpcIm5vbmVcIil9LHVuYmluZDpmdW5jdGlvbih0LGUsbixyLG8pe298fCh0LnN0eWxlLmRpc3BsYXk9dC5fX3ZPcmlnaW5hbERpc3BsYXkpfX0scmE9e21vZGVsOnFpLHNob3c6bmF9LG9hPXtuYW1lOlN0cmluZyxhcHBlYXI6Qm9vbGVhbixjc3M6Qm9vbGVhbixtb2RlOlN0cmluZyx0eXBlOlN0cmluZyxlbnRlckNsYXNzOlN0cmluZyxsZWF2ZUNsYXNzOlN0cmluZyxlbnRlclRvQ2xhc3M6U3RyaW5nLGxlYXZlVG9DbGFzczpTdHJpbmcsZW50ZXJBY3RpdmVDbGFzczpTdHJpbmcsbGVhdmVBY3RpdmVDbGFzczpTdHJpbmcsYXBwZWFyQ2xhc3M6U3RyaW5nLGFwcGVhckFjdGl2ZUNsYXNzOlN0cmluZyxhcHBlYXJUb0NsYXNzOlN0cmluZyxkdXJhdGlvbjpbTnVtYmVyLFN0cmluZyxPYmplY3RdfTtmdW5jdGlvbiBpYSh0KXt2YXIgZT10JiZ0LmNvbXBvbmVudE9wdGlvbnM7cmV0dXJuIGUmJmUuQ3Rvci5vcHRpb25zLmFic3RyYWN0P2lhKEVlKGUuY2hpbGRyZW4pKTp0fWZ1bmN0aW9uIGFhKHQpe3ZhciBlPXt9LG49dC4kb3B0aW9ucztmb3IodmFyIHIgaW4gbi5wcm9wc0RhdGEpZVtyXT10W3JdO3ZhciBvPW4uX3BhcmVudExpc3RlbmVycztmb3IodmFyIHIgaW4gbyllW3cocildPW9bcl07cmV0dXJuIGV9ZnVuY3Rpb24gc2EodCxlKXtpZigvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KGUudGFnKSlyZXR1cm4gdChcImtlZXAtYWxpdmVcIix7cHJvcHM6ZS5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YX0pfXZhciBjYT1mdW5jdGlvbih0KXtyZXR1cm4gdC50YWd8fF9lKHQpfSx1YT1mdW5jdGlvbih0KXtyZXR1cm5cInNob3dcIj09PXQubmFtZX0sbGE9e25hbWU6XCJ0cmFuc2l0aW9uXCIscHJvcHM6b2EsYWJzdHJhY3Q6ITAscmVuZGVyOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj10aGlzLiRzbG90cy5kZWZhdWx0O2lmKG4mJihuPW4uZmlsdGVyKGNhKSkubGVuZ3RoKXt2YXIgcj10aGlzLm1vZGUsbz1uWzBdO2lmKGZ1bmN0aW9uKHQpe2Zvcig7dD10LnBhcmVudDspaWYodC5kYXRhLnRyYW5zaXRpb24pcmV0dXJuITB9KHRoaXMuJHZub2RlKSlyZXR1cm4gbzt2YXIgYT1pYShvKTtpZighYSlyZXR1cm4gbztpZih0aGlzLl9sZWF2aW5nKXJldHVybiBzYSh0LG8pO3ZhciBzPVwiX190cmFuc2l0aW9uLVwiLmNvbmNhdCh0aGlzLl91aWQsXCItXCIpO2Eua2V5PW51bGw9PWEua2V5P2EuaXNDb21tZW50P3MrXCJjb21tZW50XCI6cythLnRhZzppKGEua2V5KT8wPT09U3RyaW5nKGEua2V5KS5pbmRleE9mKHMpP2Eua2V5OnMrYS5rZXk6YS5rZXk7dmFyIGM9KGEuZGF0YXx8KGEuZGF0YT17fSkpLnRyYW5zaXRpb249YWEodGhpcyksdT10aGlzLl92bm9kZSxsPWlhKHUpO2lmKGEuZGF0YS5kaXJlY3RpdmVzJiZhLmRhdGEuZGlyZWN0aXZlcy5zb21lKHVhKSYmKGEuZGF0YS5zaG93PSEwKSxsJiZsLmRhdGEmJiFmdW5jdGlvbih0LGUpe3JldHVybiBlLmtleT09PXQua2V5JiZlLnRhZz09PXQudGFnfShhLGwpJiYhX2UobCkmJighbC5jb21wb25lbnRJbnN0YW5jZXx8IWwuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudCkpe3ZhciBmPWwuZGF0YS50cmFuc2l0aW9uPVQoe30sYyk7aWYoXCJvdXQtaW5cIj09PXIpcmV0dXJuIHRoaXMuX2xlYXZpbmc9ITAsWnQoZixcImFmdGVyTGVhdmVcIiwoZnVuY3Rpb24oKXtlLl9sZWF2aW5nPSExLGUuJGZvcmNlVXBkYXRlKCl9KSksc2EodCxvKTtpZihcImluLW91dFwiPT09cil7aWYoX2UoYSkpcmV0dXJuIHU7dmFyIGQscD1mdW5jdGlvbigpe2QoKX07WnQoYyxcImFmdGVyRW50ZXJcIixwKSxadChjLFwiZW50ZXJDYW5jZWxsZWRcIixwKSxadChmLFwiZGVsYXlMZWF2ZVwiLChmdW5jdGlvbih0KXtkPXR9KSl9fXJldHVybiBvfX19LGZhPVQoe3RhZzpTdHJpbmcsbW92ZUNsYXNzOlN0cmluZ30sb2EpO2RlbGV0ZSBmYS5tb2RlO3ZhciBkYT17cHJvcHM6ZmEsYmVmb3JlTW91bnQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy5fdXBkYXRlO3RoaXMuX3VwZGF0ZT1mdW5jdGlvbihuLHIpe3ZhciBvPUxlKHQpO3QuX19wYXRjaF9fKHQuX3Zub2RlLHQua2VwdCwhMSwhMCksdC5fdm5vZGU9dC5rZXB0LG8oKSxlLmNhbGwodCxuLHIpfX0scmVuZGVyOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLnRhZ3x8dGhpcy4kdm5vZGUuZGF0YS50YWd8fFwic3BhblwiLG49T2JqZWN0LmNyZWF0ZShudWxsKSxyPXRoaXMucHJldkNoaWxkcmVuPXRoaXMuY2hpbGRyZW4sbz10aGlzLiRzbG90cy5kZWZhdWx0fHxbXSxpPXRoaXMuY2hpbGRyZW49W10sYT1hYSh0aGlzKSxzPTA7czxvLmxlbmd0aDtzKyspeyhsPW9bc10pLnRhZyYmbnVsbCE9bC5rZXkmJjAhPT1TdHJpbmcobC5rZXkpLmluZGV4T2YoXCJfX3ZsaXN0XCIpJiYoaS5wdXNoKGwpLG5bbC5rZXldPWwsKGwuZGF0YXx8KGwuZGF0YT17fSkpLnRyYW5zaXRpb249YSl9aWYocil7dmFyIGM9W10sdT1bXTtmb3Iocz0wO3M8ci5sZW5ndGg7cysrKXt2YXIgbDsobD1yW3NdKS5kYXRhLnRyYW5zaXRpb249YSxsLmRhdGEucG9zPWwuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG5bbC5rZXldP2MucHVzaChsKTp1LnB1c2gobCl9dGhpcy5rZXB0PXQoZSxudWxsLGMpLHRoaXMucmVtb3ZlZD11fXJldHVybiB0KGUsbnVsbCxpKX0sdXBkYXRlZDpmdW5jdGlvbigpe3ZhciB0PXRoaXMucHJldkNoaWxkcmVuLGU9dGhpcy5tb3ZlQ2xhc3N8fCh0aGlzLm5hbWV8fFwidlwiKStcIi1tb3ZlXCI7dC5sZW5ndGgmJnRoaXMuaGFzTW92ZSh0WzBdLmVsbSxlKSYmKHQuZm9yRWFjaChwYSksdC5mb3JFYWNoKHZhKSx0LmZvckVhY2goaGEpLHRoaXMuX3JlZmxvdz1kb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodCx0LmZvckVhY2goKGZ1bmN0aW9uKHQpe2lmKHQuZGF0YS5tb3ZlZCl7dmFyIG49dC5lbG0scj1uLnN0eWxlO0RpKG4sZSksci50cmFuc2Zvcm09ci5XZWJraXRUcmFuc2Zvcm09ci50cmFuc2l0aW9uRHVyYXRpb249XCJcIixuLmFkZEV2ZW50TGlzdGVuZXIoQWksbi5fbW92ZUNiPWZ1bmN0aW9uIHQocil7ciYmci50YXJnZXQhPT1ufHxyJiYhL3RyYW5zZm9ybSQvLnRlc3Qoci5wcm9wZXJ0eU5hbWUpfHwobi5yZW1vdmVFdmVudExpc3RlbmVyKEFpLHQpLG4uX21vdmVDYj1udWxsLE1pKG4sZSkpfSl9fSkpKX0sbWV0aG9kczp7aGFzTW92ZTpmdW5jdGlvbih0LGUpe2lmKCFraSlyZXR1cm4hMTtpZih0aGlzLl9oYXNNb3ZlKXJldHVybiB0aGlzLl9oYXNNb3ZlO3ZhciBuPXQuY2xvbmVOb2RlKCk7dC5fdHJhbnNpdGlvbkNsYXNzZXMmJnQuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goKGZ1bmN0aW9uKHQpe3dpKG4sdCl9KSksJGkobixlKSxuLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy4kZWwuYXBwZW5kQ2hpbGQobik7dmFyIHI9Umkobik7cmV0dXJuIHRoaXMuJGVsLnJlbW92ZUNoaWxkKG4pLHRoaXMuX2hhc01vdmU9ci5oYXNUcmFuc2Zvcm19fX07ZnVuY3Rpb24gcGEodCl7dC5lbG0uX21vdmVDYiYmdC5lbG0uX21vdmVDYigpLHQuZWxtLl9lbnRlckNiJiZ0LmVsbS5fZW50ZXJDYigpfWZ1bmN0aW9uIHZhKHQpe3QuZGF0YS5uZXdQb3M9dC5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCl9ZnVuY3Rpb24gaGEodCl7dmFyIGU9dC5kYXRhLnBvcyxuPXQuZGF0YS5uZXdQb3Mscj1lLmxlZnQtbi5sZWZ0LG89ZS50b3Atbi50b3A7aWYocnx8byl7dC5kYXRhLm1vdmVkPSEwO3ZhciBpPXQuZWxtLnN0eWxlO2kudHJhbnNmb3JtPWkuV2Via2l0VHJhbnNmb3JtPVwidHJhbnNsYXRlKFwiLmNvbmNhdChyLFwicHgsXCIpLmNvbmNhdChvLFwicHgpXCIpLGkudHJhbnNpdGlvbkR1cmF0aW9uPVwiMHNcIn19dmFyIG1hPXtUcmFuc2l0aW9uOmxhLFRyYW5zaXRpb25Hcm91cDpkYX07Q3IuY29uZmlnLm11c3RVc2VQcm9wPU1yLENyLmNvbmZpZy5pc1Jlc2VydmVkVGFnPUdyLENyLmNvbmZpZy5pc1Jlc2VydmVkQXR0cj1QcixDci5jb25maWcuZ2V0VGFnTmFtZXNwYWNlPVhyLENyLmNvbmZpZy5pc1Vua25vd25FbGVtZW50PWZ1bmN0aW9uKHQpe2lmKCFKKXJldHVybiEwO2lmKEdyKHQpKXJldHVybiExO2lmKHQ9dC50b0xvd2VyQ2FzZSgpLG51bGwhPVlyW3RdKXJldHVybiBZclt0XTt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KHQpO3JldHVybiB0LmluZGV4T2YoXCItXCIpPi0xP1lyW3RdPWUuY29uc3RydWN0b3I9PT13aW5kb3cuSFRNTFVua25vd25FbGVtZW50fHxlLmNvbnN0cnVjdG9yPT09d2luZG93LkhUTUxFbGVtZW50OllyW3RdPS9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZS50b1N0cmluZygpKX0sVChDci5vcHRpb25zLmRpcmVjdGl2ZXMscmEpLFQoQ3Iub3B0aW9ucy5jb21wb25lbnRzLG1hKSxDci5wcm90b3R5cGUuX19wYXRjaF9fPUo/Smk6aixDci5wcm90b3R5cGUuJG1vdW50PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt2YXIgcjt0LiRlbD1lLHQuJG9wdGlvbnMucmVuZGVyfHwodC4kb3B0aW9ucy5yZW5kZXI9ZnQpLEJlKHQsXCJiZWZvcmVNb3VudFwiKSxyPWZ1bmN0aW9uKCl7dC5fdXBkYXRlKHQuX3JlbmRlcigpLG4pfSxuZXcgVm4odCxyLGose2JlZm9yZTpmdW5jdGlvbigpe3QuX2lzTW91bnRlZCYmIXQuX2lzRGVzdHJveWVkJiZCZSh0LFwiYmVmb3JlVXBkYXRlXCIpfX0sITApLG49ITE7dmFyIG89dC5fcHJlV2F0Y2hlcnM7aWYobylmb3IodmFyIGk9MDtpPG8ubGVuZ3RoO2krKylvW2ldLnJ1bigpO3JldHVybiBudWxsPT10LiR2bm9kZSYmKHQuX2lzTW91bnRlZD0hMCxCZSh0LFwibW91bnRlZFwiKSksdH0odGhpcyx0PXQmJko/dG8odCk6dm9pZCAwLGUpfSxKJiZzZXRUaW1lb3V0KChmdW5jdGlvbigpe0guZGV2dG9vbHMmJm90JiZvdC5lbWl0KFwiaW5pdFwiLENyKX0pLDApO3ZhciBnYT0vXFx7XFx7KCg/Oi58XFxyP1xcbikrPylcXH1cXH0vZyx5YT0vWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nLF9hPWIoKGZ1bmN0aW9uKHQpe3ZhciBlPXRbMF0ucmVwbGFjZSh5YSxcIlxcXFwkJlwiKSxuPXRbMV0ucmVwbGFjZSh5YSxcIlxcXFwkJlwiKTtyZXR1cm4gbmV3IFJlZ0V4cChlK1wiKCg/Oi58XFxcXG4pKz8pXCIrbixcImdcIil9KSk7dmFyIGJhPXtzdGF0aWNLZXlzOltcInN0YXRpY0NsYXNzXCJdLHRyYW5zZm9ybU5vZGU6ZnVuY3Rpb24odCxlKXtlLndhcm47dmFyIG49Qm8odCxcImNsYXNzXCIpO24mJih0LnN0YXRpY0NsYXNzPUpTT04uc3RyaW5naWZ5KG4ucmVwbGFjZSgvXFxzKy9nLFwiIFwiKS50cmltKCkpKTt2YXIgcj1Ibyh0LFwiY2xhc3NcIiwhMSk7ciYmKHQuY2xhc3NCaW5kaW5nPXIpfSxnZW5EYXRhOmZ1bmN0aW9uKHQpe3ZhciBlPVwiXCI7cmV0dXJuIHQuc3RhdGljQ2xhc3MmJihlKz1cInN0YXRpY0NsYXNzOlwiLmNvbmNhdCh0LnN0YXRpY0NsYXNzLFwiLFwiKSksdC5jbGFzc0JpbmRpbmcmJihlKz1cImNsYXNzOlwiLmNvbmNhdCh0LmNsYXNzQmluZGluZyxcIixcIikpLGV9fTt2YXIgJGEsd2E9e3N0YXRpY0tleXM6W1wic3RhdGljU3R5bGVcIl0sdHJhbnNmb3JtTm9kZTpmdW5jdGlvbih0LGUpe2Uud2Fybjt2YXIgbj1Cbyh0LFwic3R5bGVcIik7biYmKHQuc3RhdGljU3R5bGU9SlNPTi5zdHJpbmdpZnkodWkobikpKTt2YXIgcj1Ibyh0LFwic3R5bGVcIiwhMSk7ciYmKHQuc3R5bGVCaW5kaW5nPXIpfSxnZW5EYXRhOmZ1bmN0aW9uKHQpe3ZhciBlPVwiXCI7cmV0dXJuIHQuc3RhdGljU3R5bGUmJihlKz1cInN0YXRpY1N0eWxlOlwiLmNvbmNhdCh0LnN0YXRpY1N0eWxlLFwiLFwiKSksdC5zdHlsZUJpbmRpbmcmJihlKz1cInN0eWxlOihcIi5jb25jYXQodC5zdHlsZUJpbmRpbmcsXCIpLFwiKSksZX19LHhhPWZ1bmN0aW9uKHQpe3JldHVybigkYT0kYXx8ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkuaW5uZXJIVE1MPXQsJGEudGV4dENvbnRlbnR9LENhPXYoXCJhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbixsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdiclwiKSxrYT12KFwiY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZVwiKSxTYT12KFwiYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLGRldGFpbHMsZGlhbG9nLGRpdixkbCxkdCxmaWVsZHNldCxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsZm9ybSxoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSxvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsdGl0bGUsdHIsdHJhY2tcIiksT2E9L15cXHMqKFteXFxzXCInPD5cXC89XSspKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy8sVGE9L15cXHMqKCg/OnYtW1xcdy1dKzp8QHw6fCMpXFxbW149XSs/XFxdW15cXHNcIic8PlxcLz1dKikoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LyxBYT1cIlthLXpBLVpfXVtcXFxcLVxcXFwuMC05X2EtekEtWlwiLmNvbmNhdChCLnNvdXJjZSxcIl0qXCIpLGphPVwiKCg/OlwiLmNvbmNhdChBYSxcIlxcXFw6KT9cIikuY29uY2F0KEFhLFwiKVwiKSxFYT1uZXcgUmVnRXhwKFwiXjxcIi5jb25jYXQoamEpKSxOYT0vXlxccyooXFwvPyk+LyxQYT1uZXcgUmVnRXhwKFwiXjxcXFxcL1wiLmNvbmNhdChqYSxcIltePl0qPlwiKSksRGE9L148IURPQ1RZUEUgW14+XSs+L2ksTWE9L148IVxcLS0vLElhPS9ePCFcXFsvLExhPXYoXCJzY3JpcHQsc3R5bGUsdGV4dGFyZWFcIiwhMCksUmE9e30sRmE9e1wiJmx0O1wiOlwiPFwiLFwiJmd0O1wiOlwiPlwiLFwiJnF1b3Q7XCI6J1wiJyxcIiZhbXA7XCI6XCImXCIsXCImIzEwO1wiOlwiXFxuXCIsXCImIzk7XCI6XCJcXHRcIixcIiYjMzk7XCI6XCInXCJ9LEhhPS8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5KTsvZyxCYT0vJig/Omx0fGd0fHF1b3R8YW1wfCMzOXwjMTB8IzkpOy9nLFVhPXYoXCJwcmUsdGV4dGFyZWFcIiwhMCksemE9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCYmVWEodCkmJlwiXFxuXCI9PT1lWzBdfTtmdW5jdGlvbiBWYSh0LGUpe3ZhciBuPWU/QmE6SGE7cmV0dXJuIHQucmVwbGFjZShuLChmdW5jdGlvbih0KXtyZXR1cm4gRmFbdF19KSl9ZnVuY3Rpb24gS2EodCxlKXtmb3IodmFyIG4scixvPVtdLGk9ZS5leHBlY3RIVE1MLGE9ZS5pc1VuYXJ5VGFnfHxFLHM9ZS5jYW5CZUxlZnRPcGVuVGFnfHxFLGM9MCx1PWZ1bmN0aW9uKCl7aWYobj10LHImJkxhKHIpKXt2YXIgdT0wLGQ9ci50b0xvd2VyQ2FzZSgpLHA9UmFbZF18fChSYVtkXT1uZXcgUmVnRXhwKFwiKFtcXFxcc1xcXFxTXSo/KSg8L1wiK2QrXCJbXj5dKj4pXCIsXCJpXCIpKTt3PXQucmVwbGFjZShwLChmdW5jdGlvbih0LG4scil7cmV0dXJuIHU9ci5sZW5ndGgsTGEoZCl8fFwibm9zY3JpcHRcIj09PWR8fChuPW4ucmVwbGFjZSgvPCFcXC0tKFtcXHNcXFNdKj8pLS0+L2csXCIkMVwiKS5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csXCIkMVwiKSksemEoZCxuKSYmKG49bi5zbGljZSgxKSksZS5jaGFycyYmZS5jaGFycyhuKSxcIlwifSkpO2MrPXQubGVuZ3RoLXcubGVuZ3RoLHQ9dyxmKGQsYy11LGMpfWVsc2V7dmFyIHY9dC5pbmRleE9mKFwiPFwiKTtpZigwPT09dil7aWYoTWEudGVzdCh0KSl7dmFyIGg9dC5pbmRleE9mKFwiLS1cXHgzZVwiKTtpZihoPj0wKXJldHVybiBlLnNob3VsZEtlZXBDb21tZW50JiZlLmNvbW1lbnQmJmUuY29tbWVudCh0LnN1YnN0cmluZyg0LGgpLGMsYytoKzMpLGwoaCszKSxcImNvbnRpbnVlXCJ9aWYoSWEudGVzdCh0KSl7dmFyIG09dC5pbmRleE9mKFwiXT5cIik7aWYobT49MClyZXR1cm4gbChtKzIpLFwiY29udGludWVcIn12YXIgZz10Lm1hdGNoKERhKTtpZihnKXJldHVybiBsKGdbMF0ubGVuZ3RoKSxcImNvbnRpbnVlXCI7dmFyIHk9dC5tYXRjaChQYSk7aWYoeSl7dmFyIF89YztyZXR1cm4gbCh5WzBdLmxlbmd0aCksZih5WzFdLF8sYyksXCJjb250aW51ZVwifXZhciBiPWZ1bmN0aW9uKCl7dmFyIGU9dC5tYXRjaChFYSk7aWYoZSl7dmFyIG49e3RhZ05hbWU6ZVsxXSxhdHRyczpbXSxzdGFydDpjfTtsKGVbMF0ubGVuZ3RoKTtmb3IodmFyIHI9dm9pZCAwLG89dm9pZCAwOyEocj10Lm1hdGNoKE5hKSkmJihvPXQubWF0Y2goVGEpfHx0Lm1hdGNoKE9hKSk7KW8uc3RhcnQ9YyxsKG9bMF0ubGVuZ3RoKSxvLmVuZD1jLG4uYXR0cnMucHVzaChvKTtpZihyKXJldHVybiBuLnVuYXJ5U2xhc2g9clsxXSxsKHJbMF0ubGVuZ3RoKSxuLmVuZD1jLG59fSgpO2lmKGIpcmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBuPXQudGFnTmFtZSxjPXQudW5hcnlTbGFzaDtpJiYoXCJwXCI9PT1yJiZTYShuKSYmZihyKSxzKG4pJiZyPT09biYmZihuKSk7Zm9yKHZhciB1PWEobil8fCEhYyxsPXQuYXR0cnMubGVuZ3RoLGQ9bmV3IEFycmF5KGwpLHA9MDtwPGw7cCsrKXt2YXIgdj10LmF0dHJzW3BdLGg9dlszXXx8dls0XXx8dls1XXx8XCJcIixtPVwiYVwiPT09biYmXCJocmVmXCI9PT12WzFdP2Uuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOmUuc2hvdWxkRGVjb2RlTmV3bGluZXM7ZFtwXT17bmFtZTp2WzFdLHZhbHVlOlZhKGgsbSl9fXV8fChvLnB1c2goe3RhZzpuLGxvd2VyQ2FzZWRUYWc6bi50b0xvd2VyQ2FzZSgpLGF0dHJzOmQsc3RhcnQ6dC5zdGFydCxlbmQ6dC5lbmR9KSxyPW4pO2Uuc3RhcnQmJmUuc3RhcnQobixkLHUsdC5zdGFydCx0LmVuZCl9KGIpLHphKGIudGFnTmFtZSx0KSYmbCgxKSxcImNvbnRpbnVlXCJ9dmFyICQ9dm9pZCAwLHc9dm9pZCAwLHg9dm9pZCAwO2lmKHY+PTApe2Zvcih3PXQuc2xpY2Uodik7IShQYS50ZXN0KHcpfHxFYS50ZXN0KHcpfHxNYS50ZXN0KHcpfHxJYS50ZXN0KHcpfHwoeD13LmluZGV4T2YoXCI8XCIsMSkpPDApOyl2Kz14LHc9dC5zbGljZSh2KTskPXQuc3Vic3RyaW5nKDAsdil9djwwJiYoJD10KSwkJiZsKCQubGVuZ3RoKSxlLmNoYXJzJiYkJiZlLmNoYXJzKCQsYy0kLmxlbmd0aCxjKX1pZih0PT09bilyZXR1cm4gZS5jaGFycyYmZS5jaGFycyh0KSxcImJyZWFrXCJ9O3Q7KXtpZihcImJyZWFrXCI9PT11KCkpYnJlYWt9ZnVuY3Rpb24gbChlKXtjKz1lLHQ9dC5zdWJzdHJpbmcoZSl9ZnVuY3Rpb24gZih0LG4saSl7dmFyIGEscztpZihudWxsPT1uJiYobj1jKSxudWxsPT1pJiYoaT1jKSx0KWZvcihzPXQudG9Mb3dlckNhc2UoKSxhPW8ubGVuZ3RoLTE7YT49MCYmb1thXS5sb3dlckNhc2VkVGFnIT09czthLS0pO2Vsc2UgYT0wO2lmKGE+PTApe2Zvcih2YXIgdT1vLmxlbmd0aC0xO3U+PWE7dS0tKWUuZW5kJiZlLmVuZChvW3VdLnRhZyxuLGkpO28ubGVuZ3RoPWEscj1hJiZvW2EtMV0udGFnfWVsc2VcImJyXCI9PT1zP2Uuc3RhcnQmJmUuc3RhcnQodCxbXSwhMCxuLGkpOlwicFwiPT09cyYmKGUuc3RhcnQmJmUuc3RhcnQodCxbXSwhMSxuLGkpLGUuZW5kJiZlLmVuZCh0LG4saSkpfWYoKX12YXIgSmEscWEsV2EsWmEsR2EsWGEsWWEsUWEsdHM9L15AfF52LW9uOi8sZXM9L152LXxeQHxeOnxeIy8sbnM9LyhbXFxzXFxTXSo/KVxccysoPzppbnxvZilcXHMrKFtcXHNcXFNdKikvLHJzPS8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLyxvcz0vXlxcKHxcXCkkL2csaXM9L15cXFsuKlxcXSQvLGFzPS86KC4qKSQvLHNzPS9eOnxeXFwufF52LWJpbmQ6Lyxjcz0vXFwuW14uXFxdXSsoPz1bXlxcXV0qJCkvZyx1cz0vXnYtc2xvdCg6fCQpfF4jLyxscz0vW1xcclxcbl0vLGZzPS9bIFxcZlxcdFxcclxcbl0rL2csZHM9Yih4YSkscHM9XCJfZW1wdHlfXCI7ZnVuY3Rpb24gdnModCxlLG4pe3JldHVybnt0eXBlOjEsdGFnOnQsYXR0cnNMaXN0OmUsYXR0cnNNYXA6JHMoZSkscmF3QXR0cnNNYXA6e30scGFyZW50Om4sY2hpbGRyZW46W119fWZ1bmN0aW9uIGhzKHQsZSl7SmE9ZS53YXJufHxObyxYYT1lLmlzUHJlVGFnfHxFLFlhPWUubXVzdFVzZVByb3B8fEUsUWE9ZS5nZXRUYWdOYW1lc3BhY2V8fEUsZS5pc1Jlc2VydmVkVGFnLFdhPVBvKGUubW9kdWxlcyxcInRyYW5zZm9ybU5vZGVcIiksWmE9UG8oZS5tb2R1bGVzLFwicHJlVHJhbnNmb3JtTm9kZVwiKSxHYT1QbyhlLm1vZHVsZXMsXCJwb3N0VHJhbnNmb3JtTm9kZVwiKSxxYT1lLmRlbGltaXRlcnM7dmFyIG4scixvPVtdLGk9ITEhPT1lLnByZXNlcnZlV2hpdGVzcGFjZSxhPWUud2hpdGVzcGFjZSxzPSExLGM9ITE7ZnVuY3Rpb24gdSh0KXtpZihsKHQpLHN8fHQucHJvY2Vzc2VkfHwodD1tcyh0LGUpKSxvLmxlbmd0aHx8dD09PW58fG4uaWYmJih0LmVsc2VpZnx8dC5lbHNlKSYmeXMobix7ZXhwOnQuZWxzZWlmLGJsb2NrOnR9KSxyJiYhdC5mb3JiaWRkZW4paWYodC5lbHNlaWZ8fHQuZWxzZSlhPXQsdT1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5sZW5ndGg7ZS0tOyl7aWYoMT09PXRbZV0udHlwZSlyZXR1cm4gdFtlXTt0LnBvcCgpfX0oci5jaGlsZHJlbiksdSYmdS5pZiYmeXModSx7ZXhwOmEuZWxzZWlmLGJsb2NrOmF9KTtlbHNle2lmKHQuc2xvdFNjb3BlKXt2YXIgaT10LnNsb3RUYXJnZXR8fCdcImRlZmF1bHRcIic7KHIuc2NvcGVkU2xvdHN8fChyLnNjb3BlZFNsb3RzPXt9KSlbaV09dH1yLmNoaWxkcmVuLnB1c2godCksdC5wYXJlbnQ9cn12YXIgYSx1O3QuY2hpbGRyZW49dC5jaGlsZHJlbi5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiF0LnNsb3RTY29wZX0pKSxsKHQpLHQucHJlJiYocz0hMSksWGEodC50YWcpJiYoYz0hMSk7Zm9yKHZhciBmPTA7ZjxHYS5sZW5ndGg7ZisrKUdhW2ZdKHQsZSl9ZnVuY3Rpb24gbCh0KXtpZighYylmb3IodmFyIGU9dm9pZCAwOyhlPXQuY2hpbGRyZW5bdC5jaGlsZHJlbi5sZW5ndGgtMV0pJiYzPT09ZS50eXBlJiZcIiBcIj09PWUudGV4dDspdC5jaGlsZHJlbi5wb3AoKX1yZXR1cm4gS2EodCx7d2FybjpKYSxleHBlY3RIVE1MOmUuZXhwZWN0SFRNTCxpc1VuYXJ5VGFnOmUuaXNVbmFyeVRhZyxjYW5CZUxlZnRPcGVuVGFnOmUuY2FuQmVMZWZ0T3BlblRhZyxzaG91bGREZWNvZGVOZXdsaW5lczplLnNob3VsZERlY29kZU5ld2xpbmVzLHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjplLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixzaG91bGRLZWVwQ29tbWVudDplLmNvbW1lbnRzLG91dHB1dFNvdXJjZVJhbmdlOmUub3V0cHV0U291cmNlUmFuZ2Usc3RhcnQ6ZnVuY3Rpb24odCxpLGEsbCxmKXt2YXIgZD1yJiZyLm5zfHxRYSh0KTtXJiZcInN2Z1wiPT09ZCYmKGk9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTt3cy50ZXN0KHIubmFtZSl8fChyLm5hbWU9ci5uYW1lLnJlcGxhY2UoeHMsXCJcIiksZS5wdXNoKHIpKX1yZXR1cm4gZX0oaSkpO3ZhciBwLHY9dnModCxpLHIpO2QmJih2Lm5zPWQpLFwic3R5bGVcIiE9PShwPXYpLnRhZyYmKFwic2NyaXB0XCIhPT1wLnRhZ3x8cC5hdHRyc01hcC50eXBlJiZcInRleHQvamF2YXNjcmlwdFwiIT09cC5hdHRyc01hcC50eXBlKXx8cnQoKXx8KHYuZm9yYmlkZGVuPSEwKTtmb3IodmFyIGg9MDtoPFphLmxlbmd0aDtoKyspdj1aYVtoXSh2LGUpfHx2O3N8fCghZnVuY3Rpb24odCl7bnVsbCE9Qm8odCxcInYtcHJlXCIpJiYodC5wcmU9ITApfSh2KSx2LnByZSYmKHM9ITApKSxYYSh2LnRhZykmJihjPSEwKSxzP2Z1bmN0aW9uKHQpe3ZhciBlPXQuYXR0cnNMaXN0LG49ZS5sZW5ndGg7aWYobilmb3IodmFyIHI9dC5hdHRycz1uZXcgQXJyYXkobiksbz0wO288bjtvKyspcltvXT17bmFtZTplW29dLm5hbWUsdmFsdWU6SlNPTi5zdHJpbmdpZnkoZVtvXS52YWx1ZSl9LG51bGwhPWVbb10uc3RhcnQmJihyW29dLnN0YXJ0PWVbb10uc3RhcnQscltvXS5lbmQ9ZVtvXS5lbmQpO2Vsc2UgdC5wcmV8fCh0LnBsYWluPSEwKX0odik6di5wcm9jZXNzZWR8fChncyh2KSxmdW5jdGlvbih0KXt2YXIgZT1Cbyh0LFwidi1pZlwiKTtpZihlKXQuaWY9ZSx5cyh0LHtleHA6ZSxibG9jazp0fSk7ZWxzZXtudWxsIT1Cbyh0LFwidi1lbHNlXCIpJiYodC5lbHNlPSEwKTt2YXIgbj1Cbyh0LFwidi1lbHNlLWlmXCIpO24mJih0LmVsc2VpZj1uKX19KHYpLGZ1bmN0aW9uKHQpe251bGwhPUJvKHQsXCJ2LW9uY2VcIikmJih0Lm9uY2U9ITApfSh2KSksbnx8KG49diksYT91KHYpOihyPXYsby5wdXNoKHYpKX0sZW5kOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1vW28ubGVuZ3RoLTFdO28ubGVuZ3RoLT0xLHI9b1tvLmxlbmd0aC0xXSx1KGkpfSxjaGFyczpmdW5jdGlvbih0LGUsbil7aWYociYmKCFXfHxcInRleHRhcmVhXCIhPT1yLnRhZ3x8ci5hdHRyc01hcC5wbGFjZWhvbGRlciE9PXQpKXt2YXIgbyx1PXIuY2hpbGRyZW47aWYodD1jfHx0LnRyaW0oKT9cInNjcmlwdFwiPT09KG89cikudGFnfHxcInN0eWxlXCI9PT1vLnRhZz90OmRzKHQpOnUubGVuZ3RoP2E/XCJjb25kZW5zZVwiPT09YSYmbHMudGVzdCh0KT9cIlwiOlwiIFwiOmk/XCIgXCI6XCJcIjpcIlwiKXtjfHxcImNvbmRlbnNlXCIhPT1hfHwodD10LnJlcGxhY2UoZnMsXCIgXCIpKTt2YXIgbD12b2lkIDAsZj12b2lkIDA7IXMmJlwiIFwiIT09dCYmKGw9ZnVuY3Rpb24odCxlKXt2YXIgbj1lP19hKGUpOmdhO2lmKG4udGVzdCh0KSl7Zm9yKHZhciByLG8saSxhPVtdLHM9W10sYz1uLmxhc3RJbmRleD0wO3I9bi5leGVjKHQpOyl7KG89ci5pbmRleCk+YyYmKHMucHVzaChpPXQuc2xpY2UoYyxvKSksYS5wdXNoKEpTT04uc3RyaW5naWZ5KGkpKSk7dmFyIHU9am8oclsxXS50cmltKCkpO2EucHVzaChcIl9zKFwiLmNvbmNhdCh1LFwiKVwiKSkscy5wdXNoKHtcIkBiaW5kaW5nXCI6dX0pLGM9bytyWzBdLmxlbmd0aH1yZXR1cm4gYzx0Lmxlbmd0aCYmKHMucHVzaChpPXQuc2xpY2UoYykpLGEucHVzaChKU09OLnN0cmluZ2lmeShpKSkpLHtleHByZXNzaW9uOmEuam9pbihcIitcIiksdG9rZW5zOnN9fX0odCxxYSkpP2Y9e3R5cGU6MixleHByZXNzaW9uOmwuZXhwcmVzc2lvbix0b2tlbnM6bC50b2tlbnMsdGV4dDp0fTpcIiBcIj09PXQmJnUubGVuZ3RoJiZcIiBcIj09PXVbdS5sZW5ndGgtMV0udGV4dHx8KGY9e3R5cGU6Myx0ZXh0OnR9KSxmJiZ1LnB1c2goZil9fX0sY29tbWVudDpmdW5jdGlvbih0LGUsbil7aWYocil7dmFyIG89e3R5cGU6Myx0ZXh0OnQsaXNDb21tZW50OiEwfTtyLmNoaWxkcmVuLnB1c2gobyl9fX0pLG59ZnVuY3Rpb24gbXModCxlKXt2YXIgbixyOyhyPUhvKG49dCxcImtleVwiKSkmJihuLmtleT1yKSx0LnBsYWluPSF0LmtleSYmIXQuc2NvcGVkU2xvdHMmJiF0LmF0dHJzTGlzdC5sZW5ndGgsZnVuY3Rpb24odCl7dmFyIGU9SG8odCxcInJlZlwiKTtlJiYodC5yZWY9ZSx0LnJlZkluRm9yPWZ1bmN0aW9uKHQpe3ZhciBlPXQ7Zm9yKDtlOyl7aWYodm9pZCAwIT09ZS5mb3IpcmV0dXJuITA7ZT1lLnBhcmVudH1yZXR1cm4hMX0odCkpfSh0KSxmdW5jdGlvbih0KXt2YXIgZTtcInRlbXBsYXRlXCI9PT10LnRhZz8oZT1Cbyh0LFwic2NvcGVcIiksdC5zbG90U2NvcGU9ZXx8Qm8odCxcInNsb3Qtc2NvcGVcIikpOihlPUJvKHQsXCJzbG90LXNjb3BlXCIpKSYmKHQuc2xvdFNjb3BlPWUpO3ZhciBuPUhvKHQsXCJzbG90XCIpO24mJih0LnNsb3RUYXJnZXQ9J1wiXCInPT09bj8nXCJkZWZhdWx0XCInOm4sdC5zbG90VGFyZ2V0RHluYW1pYz0hKCF0LmF0dHJzTWFwW1wiOnNsb3RcIl0mJiF0LmF0dHJzTWFwW1widi1iaW5kOnNsb3RcIl0pLFwidGVtcGxhdGVcIj09PXQudGFnfHx0LnNsb3RTY29wZXx8TW8odCxcInNsb3RcIixuLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQucmF3QXR0cnNNYXBbXCI6XCIrZV18fHQucmF3QXR0cnNNYXBbXCJ2LWJpbmQ6XCIrZV18fHQucmF3QXR0cnNNYXBbZV19KHQsXCJzbG90XCIpKSk7aWYoXCJ0ZW1wbGF0ZVwiPT09dC50YWcpe2lmKGE9VW8odCx1cykpe3ZhciByPV9zKGEpLG89ci5uYW1lLGk9ci5keW5hbWljO3Quc2xvdFRhcmdldD1vLHQuc2xvdFRhcmdldER5bmFtaWM9aSx0LnNsb3RTY29wZT1hLnZhbHVlfHxwc319ZWxzZXt2YXIgYTtpZihhPVVvKHQsdXMpKXt2YXIgcz10LnNjb3BlZFNsb3RzfHwodC5zY29wZWRTbG90cz17fSksYz1fcyhhKSx1PWMubmFtZSxsPShpPWMuZHluYW1pYyxzW3VdPXZzKFwidGVtcGxhdGVcIixbXSx0KSk7bC5zbG90VGFyZ2V0PXUsbC5zbG90VGFyZ2V0RHluYW1pYz1pLGwuY2hpbGRyZW49dC5jaGlsZHJlbi5maWx0ZXIoKGZ1bmN0aW9uKHQpe2lmKCF0LnNsb3RTY29wZSlyZXR1cm4gdC5wYXJlbnQ9bCwhMH0pKSxsLnNsb3RTY29wZT1hLnZhbHVlfHxwcyx0LmNoaWxkcmVuPVtdLHQucGxhaW49ITF9fX0odCksZnVuY3Rpb24odCl7XCJzbG90XCI9PT10LnRhZyYmKHQuc2xvdE5hbWU9SG8odCxcIm5hbWVcIikpfSh0KSxmdW5jdGlvbih0KXt2YXIgZTsoZT1Ibyh0LFwiaXNcIikpJiYodC5jb21wb25lbnQ9ZSk7bnVsbCE9Qm8odCxcImlubGluZS10ZW1wbGF0ZVwiKSYmKHQuaW5saW5lVGVtcGxhdGU9ITApfSh0KTtmb3IodmFyIG89MDtvPFdhLmxlbmd0aDtvKyspdD1XYVtvXSh0LGUpfHx0O3JldHVybiBmdW5jdGlvbih0KXt2YXIgZSxuLHIsbyxpLGEscyxjLHU9dC5hdHRyc0xpc3Q7Zm9yKGU9MCxuPXUubGVuZ3RoO2U8bjtlKyspaWYocj1vPXVbZV0ubmFtZSxpPXVbZV0udmFsdWUsZXMudGVzdChyKSlpZih0Lmhhc0JpbmRpbmdzPSEwLChhPWJzKHIucmVwbGFjZShlcyxcIlwiKSkpJiYocj1yLnJlcGxhY2UoY3MsXCJcIikpLHNzLnRlc3Qocikpcj1yLnJlcGxhY2Uoc3MsXCJcIiksaT1qbyhpKSwoYz1pcy50ZXN0KHIpKSYmKHI9ci5zbGljZSgxLC0xKSksYSYmKGEucHJvcCYmIWMmJlwiaW5uZXJIdG1sXCI9PT0ocj13KHIpKSYmKHI9XCJpbm5lckhUTUxcIiksYS5jYW1lbCYmIWMmJihyPXcocikpLGEuc3luYyYmKHM9S28oaSxcIiRldmVudFwiKSxjP0ZvKHQsJ1widXBkYXRlOlwiKygnLmNvbmNhdChyLFwiKVwiKSxzLG51bGwsITEsMCx1W2VdLCEwKTooRm8odCxcInVwZGF0ZTpcIi5jb25jYXQodyhyKSkscyxudWxsLCExLDAsdVtlXSksayhyKSE9PXcocikmJkZvKHQsXCJ1cGRhdGU6XCIuY29uY2F0KGsocikpLHMsbnVsbCwhMSwwLHVbZV0pKSkpLGEmJmEucHJvcHx8IXQuY29tcG9uZW50JiZZYSh0LnRhZyx0LmF0dHJzTWFwLnR5cGUscik/RG8odCxyLGksdVtlXSxjKTpNbyh0LHIsaSx1W2VdLGMpO2Vsc2UgaWYodHMudGVzdChyKSlyPXIucmVwbGFjZSh0cyxcIlwiKSwoYz1pcy50ZXN0KHIpKSYmKHI9ci5zbGljZSgxLC0xKSksRm8odCxyLGksYSwhMSwwLHVbZV0sYyk7ZWxzZXt2YXIgbD0ocj1yLnJlcGxhY2UoZXMsXCJcIikpLm1hdGNoKGFzKSxmPWwmJmxbMV07Yz0hMSxmJiYocj1yLnNsaWNlKDAsLShmLmxlbmd0aCsxKSksaXMudGVzdChmKSYmKGY9Zi5zbGljZSgxLC0xKSxjPSEwKSksTG8odCxyLG8saSxmLGMsYSx1W2VdKX1lbHNlIE1vKHQscixKU09OLnN0cmluZ2lmeShpKSx1W2VdKSwhdC5jb21wb25lbnQmJlwibXV0ZWRcIj09PXImJllhKHQudGFnLHQuYXR0cnNNYXAudHlwZSxyKSYmRG8odCxyLFwidHJ1ZVwiLHVbZV0pfSh0KSx0fWZ1bmN0aW9uIGdzKHQpe3ZhciBlO2lmKGU9Qm8odCxcInYtZm9yXCIpKXt2YXIgbj1mdW5jdGlvbih0KXt2YXIgZT10Lm1hdGNoKG5zKTtpZighZSlyZXR1cm47dmFyIG49e307bi5mb3I9ZVsyXS50cmltKCk7dmFyIHI9ZVsxXS50cmltKCkucmVwbGFjZShvcyxcIlwiKSxvPXIubWF0Y2gocnMpO28/KG4uYWxpYXM9ci5yZXBsYWNlKHJzLFwiXCIpLnRyaW0oKSxuLml0ZXJhdG9yMT1vWzFdLnRyaW0oKSxvWzJdJiYobi5pdGVyYXRvcjI9b1syXS50cmltKCkpKTpuLmFsaWFzPXI7cmV0dXJuIG59KGUpO24mJlQodCxuKX19ZnVuY3Rpb24geXModCxlKXt0LmlmQ29uZGl0aW9uc3x8KHQuaWZDb25kaXRpb25zPVtdKSx0LmlmQ29uZGl0aW9ucy5wdXNoKGUpfWZ1bmN0aW9uIF9zKHQpe3ZhciBlPXQubmFtZS5yZXBsYWNlKHVzLFwiXCIpO3JldHVybiBlfHxcIiNcIiE9PXQubmFtZVswXSYmKGU9XCJkZWZhdWx0XCIpLGlzLnRlc3QoZSk/e25hbWU6ZS5zbGljZSgxLC0xKSxkeW5hbWljOiEwfTp7bmFtZTonXCInLmNvbmNhdChlLCdcIicpLGR5bmFtaWM6ITF9fWZ1bmN0aW9uIGJzKHQpe3ZhciBlPXQubWF0Y2goY3MpO2lmKGUpe3ZhciBuPXt9O3JldHVybiBlLmZvckVhY2goKGZ1bmN0aW9uKHQpe25bdC5zbGljZSgxKV09ITB9KSksbn19ZnVuY3Rpb24gJHModCl7Zm9yKHZhciBlPXt9LG49MCxyPXQubGVuZ3RoO248cjtuKyspZVt0W25dLm5hbWVdPXRbbl0udmFsdWU7cmV0dXJuIGV9dmFyIHdzPS9eeG1sbnM6TlNcXGQrLyx4cz0vXk5TXFxkKzovO2Z1bmN0aW9uIENzKHQpe3JldHVybiB2cyh0LnRhZyx0LmF0dHJzTGlzdC5zbGljZSgpLHQucGFyZW50KX12YXIga3M9W2JhLHdhLHtwcmVUcmFuc2Zvcm1Ob2RlOmZ1bmN0aW9uKHQsZSl7aWYoXCJpbnB1dFwiPT09dC50YWcpe3ZhciBuPXQuYXR0cnNNYXA7aWYoIW5bXCJ2LW1vZGVsXCJdKXJldHVybjt2YXIgcj12b2lkIDA7aWYoKG5bXCI6dHlwZVwiXXx8bltcInYtYmluZDp0eXBlXCJdKSYmKHI9SG8odCxcInR5cGVcIikpLG4udHlwZXx8cnx8IW5bXCJ2LWJpbmRcIl18fChyPVwiKFwiLmNvbmNhdChuW1widi1iaW5kXCJdLFwiKS50eXBlXCIpKSxyKXt2YXIgbz1Cbyh0LFwidi1pZlwiLCEwKSxpPW8/XCImJihcIi5jb25jYXQobyxcIilcIik6XCJcIixhPW51bGwhPUJvKHQsXCJ2LWVsc2VcIiwhMCkscz1Cbyh0LFwidi1lbHNlLWlmXCIsITApLGM9Q3ModCk7Z3MoYyksSW8oYyxcInR5cGVcIixcImNoZWNrYm94XCIpLG1zKGMsZSksYy5wcm9jZXNzZWQ9ITAsYy5pZj1cIihcIi5jb25jYXQocixcIik9PT0nY2hlY2tib3gnXCIpK2kseXMoYyx7ZXhwOmMuaWYsYmxvY2s6Y30pO3ZhciB1PUNzKHQpO0JvKHUsXCJ2LWZvclwiLCEwKSxJbyh1LFwidHlwZVwiLFwicmFkaW9cIiksbXModSxlKSx5cyhjLHtleHA6XCIoXCIuY29uY2F0KHIsXCIpPT09J3JhZGlvJ1wiKStpLGJsb2NrOnV9KTt2YXIgbD1Dcyh0KTtyZXR1cm4gQm8obCxcInYtZm9yXCIsITApLElvKGwsXCI6dHlwZVwiLHIpLG1zKGwsZSkseXMoYyx7ZXhwOm8sYmxvY2s6bH0pLGE/Yy5lbHNlPSEwOnMmJihjLmVsc2VpZj1zKSxjfX19fV07dmFyIFNzLE9zLFRzPXttb2RlbDpmdW5jdGlvbih0LGUsbil7dmFyIHI9ZS52YWx1ZSxvPWUubW9kaWZpZXJzLGk9dC50YWcsYT10LmF0dHJzTWFwLnR5cGU7aWYodC5jb21wb25lbnQpcmV0dXJuIFZvKHQscixvKSwhMTtpZihcInNlbGVjdFwiPT09aSkhZnVuY3Rpb24odCxlLG4pe3ZhciByPW4mJm4ubnVtYmVyLG89J0FycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KS5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFwiX3ZhbHVlXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTsnK1wicmV0dXJuIFwiLmNvbmNhdChyP1wiX24odmFsKVwiOlwidmFsXCIsXCJ9KVwiKSxpPVwiJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdXCIsYT1cInZhciAkJHNlbGVjdGVkVmFsID0gXCIuY29uY2F0KG8sXCI7XCIpO2E9XCJcIi5jb25jYXQoYSxcIiBcIikuY29uY2F0KEtvKGUsaSkpLEZvKHQsXCJjaGFuZ2VcIixhLG51bGwsITApfSh0LHIsbyk7ZWxzZSBpZihcImlucHV0XCI9PT1pJiZcImNoZWNrYm94XCI9PT1hKSFmdW5jdGlvbih0LGUsbil7dmFyIHI9biYmbi5udW1iZXIsbz1Ibyh0LFwidmFsdWVcIil8fFwibnVsbFwiLGk9SG8odCxcInRydWUtdmFsdWVcIil8fFwidHJ1ZVwiLGE9SG8odCxcImZhbHNlLXZhbHVlXCIpfHxcImZhbHNlXCI7RG8odCxcImNoZWNrZWRcIixcIkFycmF5LmlzQXJyYXkoXCIuY29uY2F0KGUsXCIpXCIpK1wiP19pKFwiLmNvbmNhdChlLFwiLFwiKS5jb25jYXQobyxcIik+LTFcIikrKFwidHJ1ZVwiPT09aT9cIjooXCIuY29uY2F0KGUsXCIpXCIpOlwiOl9xKFwiLmNvbmNhdChlLFwiLFwiKS5jb25jYXQoaSxcIilcIikpKSxGbyh0LFwiY2hhbmdlXCIsXCJ2YXIgJCRhPVwiLmNvbmNhdChlLFwiLFwiKStcIiQkZWw9JGV2ZW50LnRhcmdldCxcIitcIiQkYz0kJGVsLmNoZWNrZWQ/KFwiLmNvbmNhdChpLFwiKTooXCIpLmNvbmNhdChhLFwiKTtcIikrXCJpZihBcnJheS5pc0FycmF5KCQkYSkpe1wiK1widmFyICQkdj1cIi5jb25jYXQocj9cIl9uKFwiK28rXCIpXCI6byxcIixcIikrXCIkJGk9X2koJCRhLCQkdik7XCIrXCJpZigkJGVsLmNoZWNrZWQpeyQkaTwwJiYoXCIuY29uY2F0KEtvKGUsXCIkJGEuY29uY2F0KFskJHZdKVwiKSxcIil9XCIpK1wiZWxzZXskJGk+LTEmJihcIi5jb25jYXQoS28oZSxcIiQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpXCIpLFwiKX1cIikrXCJ9ZWxzZXtcIi5jb25jYXQoS28oZSxcIiQkY1wiKSxcIn1cIiksbnVsbCwhMCl9KHQscixvKTtlbHNlIGlmKFwiaW5wdXRcIj09PWkmJlwicmFkaW9cIj09PWEpIWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uJiZuLm51bWJlcixvPUhvKHQsXCJ2YWx1ZVwiKXx8XCJudWxsXCI7bz1yP1wiX24oXCIuY29uY2F0KG8sXCIpXCIpOm8sRG8odCxcImNoZWNrZWRcIixcIl9xKFwiLmNvbmNhdChlLFwiLFwiKS5jb25jYXQobyxcIilcIikpLEZvKHQsXCJjaGFuZ2VcIixLbyhlLG8pLG51bGwsITApfSh0LHIsbyk7ZWxzZSBpZihcImlucHV0XCI9PT1pfHxcInRleHRhcmVhXCI9PT1pKSFmdW5jdGlvbih0LGUsbil7dmFyIHI9dC5hdHRyc01hcC50eXBlLG89bnx8e30saT1vLmxhenksYT1vLm51bWJlcixzPW8udHJpbSxjPSFpJiZcInJhbmdlXCIhPT1yLHU9aT9cImNoYW5nZVwiOlwicmFuZ2VcIj09PXI/WW86XCJpbnB1dFwiLGw9XCIkZXZlbnQudGFyZ2V0LnZhbHVlXCI7cyYmKGw9XCIkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKVwiKTthJiYobD1cIl9uKFwiLmNvbmNhdChsLFwiKVwiKSk7dmFyIGY9S28oZSxsKTtjJiYoZj1cImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIi5jb25jYXQoZikpO0RvKHQsXCJ2YWx1ZVwiLFwiKFwiLmNvbmNhdChlLFwiKVwiKSksRm8odCx1LGYsbnVsbCwhMCksKHN8fGEpJiZGbyh0LFwiYmx1clwiLFwiJGZvcmNlVXBkYXRlKClcIil9KHQscixvKTtlbHNlIGlmKCFILmlzUmVzZXJ2ZWRUYWcoaSkpcmV0dXJuIFZvKHQscixvKSwhMTtyZXR1cm4hMH0sdGV4dDpmdW5jdGlvbih0LGUpe2UudmFsdWUmJkRvKHQsXCJ0ZXh0Q29udGVudFwiLFwiX3MoXCIuY29uY2F0KGUudmFsdWUsXCIpXCIpLGUpfSxodG1sOmZ1bmN0aW9uKHQsZSl7ZS52YWx1ZSYmRG8odCxcImlubmVySFRNTFwiLFwiX3MoXCIuY29uY2F0KGUudmFsdWUsXCIpXCIpLGUpfX0sQXM9e2V4cGVjdEhUTUw6ITAsbW9kdWxlczprcyxkaXJlY3RpdmVzOlRzLGlzUHJlVGFnOmZ1bmN0aW9uKHQpe3JldHVyblwicHJlXCI9PT10fSxpc1VuYXJ5VGFnOkNhLG11c3RVc2VQcm9wOk1yLGNhbkJlTGVmdE9wZW5UYWc6a2EsaXNSZXNlcnZlZFRhZzpHcixnZXRUYWdOYW1lc3BhY2U6WHIsc3RhdGljS2V5czpmdW5jdGlvbih0KXtyZXR1cm4gdC5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuY29uY2F0KGUuc3RhdGljS2V5c3x8W10pfSksW10pLmpvaW4oXCIsXCIpfShrcyl9LGpzPWIoKGZ1bmN0aW9uKHQpe3JldHVybiB2KFwidHlwZSx0YWcsYXR0cnNMaXN0LGF0dHJzTWFwLHBsYWluLHBhcmVudCxjaGlsZHJlbixhdHRycyxzdGFydCxlbmQscmF3QXR0cnNNYXBcIisodD9cIixcIit0OlwiXCIpKX0pKTtmdW5jdGlvbiBFcyh0LGUpe3QmJihTcz1qcyhlLnN0YXRpY0tleXN8fFwiXCIpLE9zPWUuaXNSZXNlcnZlZFRhZ3x8RSxOcyh0KSxQcyh0LCExKSl9ZnVuY3Rpb24gTnModCl7aWYodC5zdGF0aWM9ZnVuY3Rpb24odCl7aWYoMj09PXQudHlwZSlyZXR1cm4hMTtpZigzPT09dC50eXBlKXJldHVybiEwO3JldHVybiEoIXQucHJlJiYodC5oYXNCaW5kaW5nc3x8dC5pZnx8dC5mb3J8fGgodC50YWcpfHwhT3ModC50YWcpfHxmdW5jdGlvbih0KXtmb3IoO3QucGFyZW50Oyl7aWYoXCJ0ZW1wbGF0ZVwiIT09KHQ9dC5wYXJlbnQpLnRhZylyZXR1cm4hMTtpZih0LmZvcilyZXR1cm4hMH1yZXR1cm4hMX0odCl8fCFPYmplY3Qua2V5cyh0KS5ldmVyeShTcykpKX0odCksMT09PXQudHlwZSl7aWYoIU9zKHQudGFnKSYmXCJzbG90XCIhPT10LnRhZyYmbnVsbD09dC5hdHRyc01hcFtcImlubGluZS10ZW1wbGF0ZVwiXSlyZXR1cm47Zm9yKHZhciBlPTAsbj10LmNoaWxkcmVuLmxlbmd0aDtlPG47ZSsrKXt2YXIgcj10LmNoaWxkcmVuW2VdO05zKHIpLHIuc3RhdGljfHwodC5zdGF0aWM9ITEpfWlmKHQuaWZDb25kaXRpb25zKWZvcihlPTEsbj10LmlmQ29uZGl0aW9ucy5sZW5ndGg7ZTxuO2UrKyl7dmFyIG89dC5pZkNvbmRpdGlvbnNbZV0uYmxvY2s7TnMobyksby5zdGF0aWN8fCh0LnN0YXRpYz0hMSl9fX1mdW5jdGlvbiBQcyh0LGUpe2lmKDE9PT10LnR5cGUpe2lmKCh0LnN0YXRpY3x8dC5vbmNlKSYmKHQuc3RhdGljSW5Gb3I9ZSksdC5zdGF0aWMmJnQuY2hpbGRyZW4ubGVuZ3RoJiYoMSE9PXQuY2hpbGRyZW4ubGVuZ3RofHwzIT09dC5jaGlsZHJlblswXS50eXBlKSlyZXR1cm4gdm9pZCh0LnN0YXRpY1Jvb3Q9ITApO2lmKHQuc3RhdGljUm9vdD0hMSx0LmNoaWxkcmVuKWZvcih2YXIgbj0wLHI9dC5jaGlsZHJlbi5sZW5ndGg7bjxyO24rKylQcyh0LmNoaWxkcmVuW25dLGV8fCEhdC5mb3IpO2lmKHQuaWZDb25kaXRpb25zKWZvcihuPTEscj10LmlmQ29uZGl0aW9ucy5sZW5ndGg7bjxyO24rKylQcyh0LmlmQ29uZGl0aW9uc1tuXS5ibG9jayxlKX19dmFyIERzPS9eKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uKD86XFxzK1tcXHckXSspP1xccypcXCgvLE1zPS9cXChbXildKj9cXCk7KiQvLElzPS9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC8sTHM9e2VzYzoyNyx0YWI6OSxlbnRlcjoxMyxzcGFjZTozMix1cDozOCxsZWZ0OjM3LHJpZ2h0OjM5LGRvd246NDAsZGVsZXRlOls4LDQ2XX0sUnM9e2VzYzpbXCJFc2NcIixcIkVzY2FwZVwiXSx0YWI6XCJUYWJcIixlbnRlcjpcIkVudGVyXCIsc3BhY2U6W1wiIFwiLFwiU3BhY2ViYXJcIl0sdXA6W1wiVXBcIixcIkFycm93VXBcIl0sbGVmdDpbXCJMZWZ0XCIsXCJBcnJvd0xlZnRcIl0scmlnaHQ6W1wiUmlnaHRcIixcIkFycm93UmlnaHRcIl0sZG93bjpbXCJEb3duXCIsXCJBcnJvd0Rvd25cIl0sZGVsZXRlOltcIkJhY2tzcGFjZVwiLFwiRGVsZXRlXCIsXCJEZWxcIl19LEZzPWZ1bmN0aW9uKHQpe3JldHVyblwiaWYoXCIuY29uY2F0KHQsXCIpcmV0dXJuIG51bGw7XCIpfSxIcz17c3RvcDpcIiRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcIixwcmV2ZW50OlwiJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XCIsc2VsZjpGcyhcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLGN0cmw6RnMoXCIhJGV2ZW50LmN0cmxLZXlcIiksc2hpZnQ6RnMoXCIhJGV2ZW50LnNoaWZ0S2V5XCIpLGFsdDpGcyhcIiEkZXZlbnQuYWx0S2V5XCIpLG1ldGE6RnMoXCIhJGV2ZW50Lm1ldGFLZXlcIiksbGVmdDpGcyhcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwXCIpLG1pZGRsZTpGcyhcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLHJpZ2h0OkZzKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIil9O2Z1bmN0aW9uIEJzKHQsZSl7dmFyIG49ZT9cIm5hdGl2ZU9uOlwiOlwib246XCIscj1cIlwiLG89XCJcIjtmb3IodmFyIGkgaW4gdCl7dmFyIGE9VXModFtpXSk7dFtpXSYmdFtpXS5keW5hbWljP28rPVwiXCIuY29uY2F0KGksXCIsXCIpLmNvbmNhdChhLFwiLFwiKTpyKz0nXCInLmNvbmNhdChpLCdcIjonKS5jb25jYXQoYSxcIixcIil9cmV0dXJuIHI9XCJ7XCIuY29uY2F0KHIuc2xpY2UoMCwtMSksXCJ9XCIpLG8/bitcIl9kKFwiLmNvbmNhdChyLFwiLFtcIikuY29uY2F0KG8uc2xpY2UoMCwtMSksXCJdKVwiKTpuK3J9ZnVuY3Rpb24gVXModCl7aWYoIXQpcmV0dXJuXCJmdW5jdGlvbigpe31cIjtpZihBcnJheS5pc0FycmF5KHQpKXJldHVyblwiW1wiLmNvbmNhdCh0Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIFVzKHQpfSkpLmpvaW4oXCIsXCIpLFwiXVwiKTt2YXIgZT1Jcy50ZXN0KHQudmFsdWUpLG49RHMudGVzdCh0LnZhbHVlKSxyPUlzLnRlc3QodC52YWx1ZS5yZXBsYWNlKE1zLFwiXCIpKTtpZih0Lm1vZGlmaWVycyl7dmFyIG89XCJcIixpPVwiXCIsYT1bXSxzPWZ1bmN0aW9uKGUpe2lmKEhzW2VdKWkrPUhzW2VdLExzW2VdJiZhLnB1c2goZSk7ZWxzZSBpZihcImV4YWN0XCI9PT1lKXt2YXIgbj10Lm1vZGlmaWVycztpKz1GcyhbXCJjdHJsXCIsXCJzaGlmdFwiLFwiYWx0XCIsXCJtZXRhXCJdLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIW5bdF19KSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm5cIiRldmVudC5cIi5jb25jYXQodCxcIktleVwiKX0pKS5qb2luKFwifHxcIikpfWVsc2UgYS5wdXNoKGUpfTtmb3IodmFyIGMgaW4gdC5tb2RpZmllcnMpcyhjKTthLmxlbmd0aCYmKG8rPWZ1bmN0aW9uKHQpe3JldHVyblwiaWYoISRldmVudC50eXBlLmluZGV4T2YoJ2tleScpJiZcIitcIlwiLmNvbmNhdCh0Lm1hcCh6cykuam9pbihcIiYmXCIpLFwiKXJldHVybiBudWxsO1wiKX0oYSkpLGkmJihvKz1pKTt2YXIgdT1lP1wicmV0dXJuIFwiLmNvbmNhdCh0LnZhbHVlLFwiLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcIik6bj9cInJldHVybiAoXCIuY29uY2F0KHQudmFsdWUsXCIpLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcIik6cj9cInJldHVybiBcIi5jb25jYXQodC52YWx1ZSk6dC52YWx1ZTtyZXR1cm5cImZ1bmN0aW9uKCRldmVudCl7XCIuY29uY2F0KG8pLmNvbmNhdCh1LFwifVwiKX1yZXR1cm4gZXx8bj90LnZhbHVlOlwiZnVuY3Rpb24oJGV2ZW50KXtcIi5jb25jYXQocj9cInJldHVybiBcIi5jb25jYXQodC52YWx1ZSk6dC52YWx1ZSxcIn1cIil9ZnVuY3Rpb24genModCl7dmFyIGU9cGFyc2VJbnQodCwxMCk7aWYoZSlyZXR1cm5cIiRldmVudC5rZXlDb2RlIT09XCIuY29uY2F0KGUpO3ZhciBuPUxzW3RdLHI9UnNbdF07cmV0dXJuXCJfaygkZXZlbnQua2V5Q29kZSxcIitcIlwiLmNvbmNhdChKU09OLnN0cmluZ2lmeSh0KSxcIixcIikrXCJcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkobiksXCIsXCIpK1wiJGV2ZW50LmtleSxcIitcIlwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShyKSkrXCIpXCJ9dmFyIFZzPXtvbjpmdW5jdGlvbih0LGUpe3Qud3JhcExpc3RlbmVycz1mdW5jdGlvbih0KXtyZXR1cm5cIl9nKFwiLmNvbmNhdCh0LFwiLFwiKS5jb25jYXQoZS52YWx1ZSxcIilcIil9fSxiaW5kOmZ1bmN0aW9uKHQsZSl7dC53cmFwRGF0YT1mdW5jdGlvbihuKXtyZXR1cm5cIl9iKFwiLmNvbmNhdChuLFwiLCdcIikuY29uY2F0KHQudGFnLFwiJyxcIikuY29uY2F0KGUudmFsdWUsXCIsXCIpLmNvbmNhdChlLm1vZGlmaWVycyYmZS5tb2RpZmllcnMucHJvcD9cInRydWVcIjpcImZhbHNlXCIpLmNvbmNhdChlLm1vZGlmaWVycyYmZS5tb2RpZmllcnMuc3luYz9cIix0cnVlXCI6XCJcIixcIilcIil9fSxjbG9hazpqfSxLcz1mdW5jdGlvbih0KXt0aGlzLm9wdGlvbnM9dCx0aGlzLndhcm49dC53YXJufHxObyx0aGlzLnRyYW5zZm9ybXM9UG8odC5tb2R1bGVzLFwidHJhbnNmb3JtQ29kZVwiKSx0aGlzLmRhdGFHZW5GbnM9UG8odC5tb2R1bGVzLFwiZ2VuRGF0YVwiKSx0aGlzLmRpcmVjdGl2ZXM9VChUKHt9LFZzKSx0LmRpcmVjdGl2ZXMpO3ZhciBlPXQuaXNSZXNlcnZlZFRhZ3x8RTt0aGlzLm1heWJlQ29tcG9uZW50PWZ1bmN0aW9uKHQpe3JldHVybiEhdC5jb21wb25lbnR8fCFlKHQudGFnKX0sdGhpcy5vbmNlSWQ9MCx0aGlzLnN0YXRpY1JlbmRlckZucz1bXSx0aGlzLnByZT0hMX07ZnVuY3Rpb24gSnModCxlKXt2YXIgbj1uZXcgS3MoZSkscj10P1wic2NyaXB0XCI9PT10LnRhZz9cIm51bGxcIjpxcyh0LG4pOidfYyhcImRpdlwiKSc7cmV0dXJue3JlbmRlcjpcIndpdGgodGhpcyl7cmV0dXJuIFwiLmNvbmNhdChyLFwifVwiKSxzdGF0aWNSZW5kZXJGbnM6bi5zdGF0aWNSZW5kZXJGbnN9fWZ1bmN0aW9uIHFzKHQsZSl7aWYodC5wYXJlbnQmJih0LnByZT10LnByZXx8dC5wYXJlbnQucHJlKSx0LnN0YXRpY1Jvb3QmJiF0LnN0YXRpY1Byb2Nlc3NlZClyZXR1cm4gV3ModCxlKTtpZih0Lm9uY2UmJiF0Lm9uY2VQcm9jZXNzZWQpcmV0dXJuIFpzKHQsZSk7aWYodC5mb3ImJiF0LmZvclByb2Nlc3NlZClyZXR1cm4gWXModCxlKTtpZih0LmlmJiYhdC5pZlByb2Nlc3NlZClyZXR1cm4gR3ModCxlKTtpZihcInRlbXBsYXRlXCIhPT10LnRhZ3x8dC5zbG90VGFyZ2V0fHxlLnByZSl7aWYoXCJzbG90XCI9PT10LnRhZylyZXR1cm4gZnVuY3Rpb24odCxlKXt2YXIgbj10LnNsb3ROYW1lfHwnXCJkZWZhdWx0XCInLHI9bmModCxlKSxvPVwiX3QoXCIuY29uY2F0KG4pLmNvbmNhdChyP1wiLGZ1bmN0aW9uKCl7cmV0dXJuIFwiLmNvbmNhdChyLFwifVwiKTpcIlwiKSxpPXQuYXR0cnN8fHQuZHluYW1pY0F0dHJzP2ljKCh0LmF0dHJzfHxbXSkuY29uY2F0KHQuZHluYW1pY0F0dHJzfHxbXSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm57bmFtZTp3KHQubmFtZSksdmFsdWU6dC52YWx1ZSxkeW5hbWljOnQuZHluYW1pY319KSkpOm51bGwsYT10LmF0dHJzTWFwW1widi1iaW5kXCJdOyFpJiYhYXx8cnx8KG8rPVwiLG51bGxcIik7aSYmKG8rPVwiLFwiLmNvbmNhdChpKSk7YSYmKG8rPVwiXCIuY29uY2F0KGk/XCJcIjpcIixudWxsXCIsXCIsXCIpLmNvbmNhdChhKSk7cmV0dXJuIG8rXCIpXCJ9KHQsZSk7dmFyIG49dm9pZCAwO2lmKHQuY29tcG9uZW50KW49ZnVuY3Rpb24odCxlLG4pe3ZhciByPWUuaW5saW5lVGVtcGxhdGU/bnVsbDpuYyhlLG4sITApO3JldHVyblwiX2MoXCIuY29uY2F0KHQsXCIsXCIpLmNvbmNhdChRcyhlLG4pKS5jb25jYXQocj9cIixcIi5jb25jYXQocik6XCJcIixcIilcIil9KHQuY29tcG9uZW50LHQsZSk7ZWxzZXt2YXIgcj12b2lkIDAsbz1lLm1heWJlQ29tcG9uZW50KHQpOyghdC5wbGFpbnx8dC5wcmUmJm8pJiYocj1Rcyh0LGUpKTt2YXIgaT12b2lkIDAsYT1lLm9wdGlvbnMuYmluZGluZ3M7byYmYSYmITEhPT1hLl9faXNTY3JpcHRTZXR1cCYmKGk9ZnVuY3Rpb24odCxlKXt2YXIgbj13KGUpLHI9eChuKSxvPWZ1bmN0aW9uKG8pe3JldHVybiB0W2VdPT09bz9lOnRbbl09PT1vP246dFtyXT09PW8/cjp2b2lkIDB9LGk9byhcInNldHVwLWNvbnN0XCIpfHxvKFwic2V0dXAtcmVhY3RpdmUtY29uc3RcIik7aWYoaSlyZXR1cm4gaTt2YXIgYT1vKFwic2V0dXAtbGV0XCIpfHxvKFwic2V0dXAtcmVmXCIpfHxvKFwic2V0dXAtbWF5YmUtcmVmXCIpO2lmKGEpcmV0dXJuIGF9KGEsdC50YWcpKSxpfHwoaT1cIidcIi5jb25jYXQodC50YWcsXCInXCIpKTt2YXIgcz10LmlubGluZVRlbXBsYXRlP251bGw6bmModCxlLCEwKTtuPVwiX2MoXCIuY29uY2F0KGkpLmNvbmNhdChyP1wiLFwiLmNvbmNhdChyKTpcIlwiKS5jb25jYXQocz9cIixcIi5jb25jYXQocyk6XCJcIixcIilcIil9Zm9yKHZhciBjPTA7YzxlLnRyYW5zZm9ybXMubGVuZ3RoO2MrKyluPWUudHJhbnNmb3Jtc1tjXSh0LG4pO3JldHVybiBufXJldHVybiBuYyh0LGUpfHxcInZvaWQgMFwifWZ1bmN0aW9uIFdzKHQsZSl7dC5zdGF0aWNQcm9jZXNzZWQ9ITA7dmFyIG49ZS5wcmU7cmV0dXJuIHQucHJlJiYoZS5wcmU9dC5wcmUpLGUuc3RhdGljUmVuZGVyRm5zLnB1c2goXCJ3aXRoKHRoaXMpe3JldHVybiBcIi5jb25jYXQocXModCxlKSxcIn1cIikpLGUucHJlPW4sXCJfbShcIi5jb25jYXQoZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoLTEpLmNvbmNhdCh0LnN0YXRpY0luRm9yP1wiLHRydWVcIjpcIlwiLFwiKVwiKX1mdW5jdGlvbiBacyh0LGUpe2lmKHQub25jZVByb2Nlc3NlZD0hMCx0LmlmJiYhdC5pZlByb2Nlc3NlZClyZXR1cm4gR3ModCxlKTtpZih0LnN0YXRpY0luRm9yKXtmb3IodmFyIG49XCJcIixyPXQucGFyZW50O3I7KXtpZihyLmZvcil7bj1yLmtleTticmVha31yPXIucGFyZW50fXJldHVybiBuP1wiX28oXCIuY29uY2F0KHFzKHQsZSksXCIsXCIpLmNvbmNhdChlLm9uY2VJZCsrLFwiLFwiKS5jb25jYXQobixcIilcIik6cXModCxlKX1yZXR1cm4gV3ModCxlKX1mdW5jdGlvbiBHcyh0LGUsbixyKXtyZXR1cm4gdC5pZlByb2Nlc3NlZD0hMCxYcyh0LmlmQ29uZGl0aW9ucy5zbGljZSgpLGUsbixyKX1mdW5jdGlvbiBYcyh0LGUsbixyKXtpZighdC5sZW5ndGgpcmV0dXJuIHJ8fFwiX2UoKVwiO3ZhciBvPXQuc2hpZnQoKTtyZXR1cm4gby5leHA/XCIoXCIuY29uY2F0KG8uZXhwLFwiKT9cIikuY29uY2F0KGkoby5ibG9jayksXCI6XCIpLmNvbmNhdChYcyh0LGUsbixyKSk6XCJcIi5jb25jYXQoaShvLmJsb2NrKSk7ZnVuY3Rpb24gaSh0KXtyZXR1cm4gbj9uKHQsZSk6dC5vbmNlP1pzKHQsZSk6cXModCxlKX19ZnVuY3Rpb24gWXModCxlLG4scil7dmFyIG89dC5mb3IsaT10LmFsaWFzLGE9dC5pdGVyYXRvcjE/XCIsXCIuY29uY2F0KHQuaXRlcmF0b3IxKTpcIlwiLHM9dC5pdGVyYXRvcjI/XCIsXCIuY29uY2F0KHQuaXRlcmF0b3IyKTpcIlwiO3JldHVybiB0LmZvclByb2Nlc3NlZD0hMCxcIlwiLmNvbmNhdChyfHxcIl9sXCIsXCIoKFwiKS5jb25jYXQobyxcIiksXCIpK1wiZnVuY3Rpb24oXCIuY29uY2F0KGkpLmNvbmNhdChhKS5jb25jYXQocyxcIil7XCIpK1wicmV0dXJuIFwiLmNvbmNhdCgobnx8cXMpKHQsZSkpK1wifSlcIn1mdW5jdGlvbiBRcyh0LGUpe3ZhciBuPVwie1wiLHI9ZnVuY3Rpb24odCxlKXt2YXIgbj10LmRpcmVjdGl2ZXM7aWYoIW4pcmV0dXJuO3ZhciByLG8saSxhLHM9XCJkaXJlY3RpdmVzOltcIixjPSExO2ZvcihyPTAsbz1uLmxlbmd0aDtyPG87cisrKXtpPW5bcl0sYT0hMDt2YXIgdT1lLmRpcmVjdGl2ZXNbaS5uYW1lXTt1JiYoYT0hIXUodCxpLGUud2FybikpLGEmJihjPSEwLHMrPSd7bmFtZTpcIicuY29uY2F0KGkubmFtZSwnXCIscmF3TmFtZTpcIicpLmNvbmNhdChpLnJhd05hbWUsJ1wiJykuY29uY2F0KGkudmFsdWU/XCIsdmFsdWU6KFwiLmNvbmNhdChpLnZhbHVlLFwiKSxleHByZXNzaW9uOlwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkoaS52YWx1ZSkpOlwiXCIpLmNvbmNhdChpLmFyZz9cIixhcmc6XCIuY29uY2F0KGkuaXNEeW5hbWljQXJnP2kuYXJnOidcIicuY29uY2F0KGkuYXJnLCdcIicpKTpcIlwiKS5jb25jYXQoaS5tb2RpZmllcnM/XCIsbW9kaWZpZXJzOlwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShpLm1vZGlmaWVycykpOlwiXCIsXCJ9LFwiKSl9aWYoYylyZXR1cm4gcy5zbGljZSgwLC0xKStcIl1cIn0odCxlKTtyJiYobis9citcIixcIiksdC5rZXkmJihuKz1cImtleTpcIi5jb25jYXQodC5rZXksXCIsXCIpKSx0LnJlZiYmKG4rPVwicmVmOlwiLmNvbmNhdCh0LnJlZixcIixcIikpLHQucmVmSW5Gb3ImJihuKz1cInJlZkluRm9yOnRydWUsXCIpLHQucHJlJiYobis9XCJwcmU6dHJ1ZSxcIiksdC5jb21wb25lbnQmJihuKz0ndGFnOlwiJy5jb25jYXQodC50YWcsJ1wiLCcpKTtmb3IodmFyIG89MDtvPGUuZGF0YUdlbkZucy5sZW5ndGg7bysrKW4rPWUuZGF0YUdlbkZuc1tvXSh0KTtpZih0LmF0dHJzJiYobis9XCJhdHRyczpcIi5jb25jYXQoaWModC5hdHRycyksXCIsXCIpKSx0LnByb3BzJiYobis9XCJkb21Qcm9wczpcIi5jb25jYXQoaWModC5wcm9wcyksXCIsXCIpKSx0LmV2ZW50cyYmKG4rPVwiXCIuY29uY2F0KEJzKHQuZXZlbnRzLCExKSxcIixcIikpLHQubmF0aXZlRXZlbnRzJiYobis9XCJcIi5jb25jYXQoQnModC5uYXRpdmVFdmVudHMsITApLFwiLFwiKSksdC5zbG90VGFyZ2V0JiYhdC5zbG90U2NvcGUmJihuKz1cInNsb3Q6XCIuY29uY2F0KHQuc2xvdFRhcmdldCxcIixcIikpLHQuc2NvcGVkU2xvdHMmJihuKz1cIlwiLmNvbmNhdChmdW5jdGlvbih0LGUsbil7dmFyIHI9dC5mb3J8fE9iamVjdC5rZXlzKGUpLnNvbWUoKGZ1bmN0aW9uKHQpe3ZhciBuPWVbdF07cmV0dXJuIG4uc2xvdFRhcmdldER5bmFtaWN8fG4uaWZ8fG4uZm9yfHx0YyhuKX0pKSxvPSEhdC5pZjtpZighcilmb3IodmFyIGk9dC5wYXJlbnQ7aTspe2lmKGkuc2xvdFNjb3BlJiZpLnNsb3RTY29wZSE9PXBzfHxpLmZvcil7cj0hMDticmVha31pLmlmJiYobz0hMCksaT1pLnBhcmVudH12YXIgYT1PYmplY3Qua2V5cyhlKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBlYyhlW3RdLG4pfSkpLmpvaW4oXCIsXCIpO3JldHVyblwic2NvcGVkU2xvdHM6X3UoW1wiLmNvbmNhdChhLFwiXVwiKS5jb25jYXQocj9cIixudWxsLHRydWVcIjpcIlwiKS5jb25jYXQoIXImJm8/XCIsbnVsbCxmYWxzZSxcIi5jb25jYXQoZnVuY3Rpb24odCl7dmFyIGU9NTM4MSxuPXQubGVuZ3RoO2Zvcig7bjspZT0zMyplXnQuY2hhckNvZGVBdCgtLW4pO3JldHVybiBlPj4+MH0oYSkpOlwiXCIsXCIpXCIpfSh0LHQuc2NvcGVkU2xvdHMsZSksXCIsXCIpKSx0Lm1vZGVsJiYobis9XCJtb2RlbDp7dmFsdWU6XCIuY29uY2F0KHQubW9kZWwudmFsdWUsXCIsY2FsbGJhY2s6XCIpLmNvbmNhdCh0Lm1vZGVsLmNhbGxiYWNrLFwiLGV4cHJlc3Npb246XCIpLmNvbmNhdCh0Lm1vZGVsLmV4cHJlc3Npb24sXCJ9LFwiKSksdC5pbmxpbmVUZW1wbGF0ZSl7dmFyIGk9ZnVuY3Rpb24odCxlKXt2YXIgbj10LmNoaWxkcmVuWzBdO2lmKG4mJjE9PT1uLnR5cGUpe3ZhciByPUpzKG4sZS5vcHRpb25zKTtyZXR1cm5cImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIi5jb25jYXQoci5yZW5kZXIsXCJ9LHN0YXRpY1JlbmRlckZuczpbXCIpLmNvbmNhdChyLnN0YXRpY1JlbmRlckZucy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVyblwiZnVuY3Rpb24oKXtcIi5jb25jYXQodCxcIn1cIil9KSkuam9pbihcIixcIiksXCJdfVwiKX19KHQsZSk7aSYmKG4rPVwiXCIuY29uY2F0KGksXCIsXCIpKX1yZXR1cm4gbj1uLnJlcGxhY2UoLywkLyxcIlwiKStcIn1cIix0LmR5bmFtaWNBdHRycyYmKG49XCJfYihcIi5jb25jYXQobiwnLFwiJykuY29uY2F0KHQudGFnLCdcIiwnKS5jb25jYXQoaWModC5keW5hbWljQXR0cnMpLFwiKVwiKSksdC53cmFwRGF0YSYmKG49dC53cmFwRGF0YShuKSksdC53cmFwTGlzdGVuZXJzJiYobj10LndyYXBMaXN0ZW5lcnMobikpLG59ZnVuY3Rpb24gdGModCl7cmV0dXJuIDE9PT10LnR5cGUmJihcInNsb3RcIj09PXQudGFnfHx0LmNoaWxkcmVuLnNvbWUodGMpKX1mdW5jdGlvbiBlYyh0LGUpe3ZhciBuPXQuYXR0cnNNYXBbXCJzbG90LXNjb3BlXCJdO2lmKHQuaWYmJiF0LmlmUHJvY2Vzc2VkJiYhbilyZXR1cm4gR3ModCxlLGVjLFwibnVsbFwiKTtpZih0LmZvciYmIXQuZm9yUHJvY2Vzc2VkKXJldHVybiBZcyh0LGUsZWMpO3ZhciByPXQuc2xvdFNjb3BlPT09cHM/XCJcIjpTdHJpbmcodC5zbG90U2NvcGUpLG89XCJmdW5jdGlvbihcIi5jb25jYXQocixcIil7XCIpK1wicmV0dXJuIFwiLmNvbmNhdChcInRlbXBsYXRlXCI9PT10LnRhZz90LmlmJiZuP1wiKFwiLmNvbmNhdCh0LmlmLFwiKT9cIikuY29uY2F0KG5jKHQsZSl8fFwidW5kZWZpbmVkXCIsXCI6dW5kZWZpbmVkXCIpOm5jKHQsZSl8fFwidW5kZWZpbmVkXCI6cXModCxlKSxcIn1cIiksaT1yP1wiXCI6XCIscHJveHk6dHJ1ZVwiO3JldHVyblwie2tleTpcIi5jb25jYXQodC5zbG90VGFyZ2V0fHwnXCJkZWZhdWx0XCInLFwiLGZuOlwiKS5jb25jYXQobykuY29uY2F0KGksXCJ9XCIpfWZ1bmN0aW9uIG5jKHQsZSxuLHIsbyl7dmFyIGk9dC5jaGlsZHJlbjtpZihpLmxlbmd0aCl7dmFyIGE9aVswXTtpZigxPT09aS5sZW5ndGgmJmEuZm9yJiZcInRlbXBsYXRlXCIhPT1hLnRhZyYmXCJzbG90XCIhPT1hLnRhZyl7dmFyIHM9bj9lLm1heWJlQ29tcG9uZW50KGEpP1wiLDFcIjpcIiwwXCI6XCJcIjtyZXR1cm5cIlwiLmNvbmNhdCgocnx8cXMpKGEsZSkpLmNvbmNhdChzKX12YXIgYz1uP2Z1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTAscj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbz10W3JdO2lmKDE9PT1vLnR5cGUpe2lmKHJjKG8pfHxvLmlmQ29uZGl0aW9ucyYmby5pZkNvbmRpdGlvbnMuc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIHJjKHQuYmxvY2spfSkpKXtuPTI7YnJlYWt9KGUobyl8fG8uaWZDb25kaXRpb25zJiZvLmlmQ29uZGl0aW9ucy5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gZSh0LmJsb2NrKX0pKSkmJihuPTEpfX1yZXR1cm4gbn0oaSxlLm1heWJlQ29tcG9uZW50KTowLHU9b3x8b2M7cmV0dXJuXCJbXCIuY29uY2F0KGkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdSh0LGUpfSkpLmpvaW4oXCIsXCIpLFwiXVwiKS5jb25jYXQoYz9cIixcIi5jb25jYXQoYyk6XCJcIil9fWZ1bmN0aW9uIHJjKHQpe3JldHVybiB2b2lkIDAhPT10LmZvcnx8XCJ0ZW1wbGF0ZVwiPT09dC50YWd8fFwic2xvdFwiPT09dC50YWd9ZnVuY3Rpb24gb2ModCxlKXtyZXR1cm4gMT09PXQudHlwZT9xcyh0LGUpOjM9PT10LnR5cGUmJnQuaXNDb21tZW50P2Z1bmN0aW9uKHQpe3JldHVyblwiX2UoXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHQudGV4dCksXCIpXCIpfSh0KTpmdW5jdGlvbih0KXtyZXR1cm5cIl92KFwiLmNvbmNhdCgyPT09dC50eXBlP3QuZXhwcmVzc2lvbjphYyhKU09OLnN0cmluZ2lmeSh0LnRleHQpKSxcIilcIil9KHQpfWZ1bmN0aW9uIGljKHQpe2Zvcih2YXIgZT1cIlwiLG49XCJcIixyPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBvPXRbcl0saT1hYyhvLnZhbHVlKTtvLmR5bmFtaWM/bis9XCJcIi5jb25jYXQoby5uYW1lLFwiLFwiKS5jb25jYXQoaSxcIixcIik6ZSs9J1wiJy5jb25jYXQoby5uYW1lLCdcIjonKS5jb25jYXQoaSxcIixcIil9cmV0dXJuIGU9XCJ7XCIuY29uY2F0KGUuc2xpY2UoMCwtMSksXCJ9XCIpLG4/XCJfZChcIi5jb25jYXQoZSxcIixbXCIpLmNvbmNhdChuLnNsaWNlKDAsLTEpLFwiXSlcIik6ZX1mdW5jdGlvbiBhYyh0KXtyZXR1cm4gdC5yZXBsYWNlKC9cXHUyMDI4L2csXCJcXFxcdTIwMjhcIikucmVwbGFjZSgvXFx1MjAyOS9nLFwiXFxcXHUyMDI5XCIpfWZ1bmN0aW9uIHNjKHQsZSl7dHJ5e3JldHVybiBuZXcgRnVuY3Rpb24odCl9Y2F0Y2gobil7cmV0dXJuIGUucHVzaCh7ZXJyOm4sY29kZTp0fSksan19ZnVuY3Rpb24gY2ModCl7dmFyIGU9T2JqZWN0LmNyZWF0ZShudWxsKTtyZXR1cm4gZnVuY3Rpb24obixyLG8peyhyPVQoe30scikpLndhcm4sZGVsZXRlIHIud2Fybjt2YXIgaT1yLmRlbGltaXRlcnM/U3RyaW5nKHIuZGVsaW1pdGVycykrbjpuO2lmKGVbaV0pcmV0dXJuIGVbaV07dmFyIGE9dChuLHIpLHM9e30sYz1bXTtyZXR1cm4gcy5yZW5kZXI9c2MoYS5yZW5kZXIsYykscy5zdGF0aWNSZW5kZXJGbnM9YS5zdGF0aWNSZW5kZXJGbnMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gc2ModCxjKX0pKSxlW2ldPXN9fW5ldyBSZWdFeHAoXCJcXFxcYlwiK1wiZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCxzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50c1wiLnNwbGl0KFwiLFwiKS5qb2luKFwiXFxcXGJ8XFxcXGJcIikrXCJcXFxcYlwiKSxuZXcgUmVnRXhwKFwiXFxcXGJcIitcImRlbGV0ZSx0eXBlb2Ysdm9pZFwiLnNwbGl0KFwiLFwiKS5qb2luKFwiXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYlwiKStcIlxcXFxzKlxcXFwoW15cXFxcKV0qXFxcXClcIik7dmFyIHVjLGxjLGZjPSh1Yz1mdW5jdGlvbih0LGUpe3ZhciBuPWhzKHQudHJpbSgpLGUpOyExIT09ZS5vcHRpbWl6ZSYmRXMobixlKTt2YXIgcj1KcyhuLGUpO3JldHVybnthc3Q6bixyZW5kZXI6ci5yZW5kZXIsc3RhdGljUmVuZGVyRm5zOnIuc3RhdGljUmVuZGVyRm5zfX0sZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLG4pe3ZhciByPU9iamVjdC5jcmVhdGUodCksbz1bXSxpPVtdO2lmKG4pZm9yKHZhciBhIGluIG4ubW9kdWxlcyYmKHIubW9kdWxlcz0odC5tb2R1bGVzfHxbXSkuY29uY2F0KG4ubW9kdWxlcykpLG4uZGlyZWN0aXZlcyYmKHIuZGlyZWN0aXZlcz1UKE9iamVjdC5jcmVhdGUodC5kaXJlY3RpdmVzfHxudWxsKSxuLmRpcmVjdGl2ZXMpKSxuKVwibW9kdWxlc1wiIT09YSYmXCJkaXJlY3RpdmVzXCIhPT1hJiYoclthXT1uW2FdKTtyLndhcm49ZnVuY3Rpb24odCxlLG4peyhuP2k6bykucHVzaCh0KX07dmFyIHM9dWMoZS50cmltKCkscik7cmV0dXJuIHMuZXJyb3JzPW8scy50aXBzPWksc31yZXR1cm57Y29tcGlsZTplLGNvbXBpbGVUb0Z1bmN0aW9uczpjYyhlKX19KSxkYz1mYyhBcykuY29tcGlsZVRvRnVuY3Rpb25zO2Z1bmN0aW9uIHBjKHQpe3JldHVybihsYz1sY3x8ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkuaW5uZXJIVE1MPXQ/JzxhIGhyZWY9XCJcXG5cIi8+JzonPGRpdiBhPVwiXFxuXCIvPicsbGMuaW5uZXJIVE1MLmluZGV4T2YoXCImIzEwO1wiKT4wfXZhciB2Yz0hIUomJnBjKCExKSxoYz0hIUomJnBjKCEwKSxtYz1iKChmdW5jdGlvbih0KXt2YXIgZT10byh0KTtyZXR1cm4gZSYmZS5pbm5lckhUTUx9KSksZ2M9Q3IucHJvdG90eXBlLiRtb3VudDtyZXR1cm4gQ3IucHJvdG90eXBlLiRtb3VudD1mdW5jdGlvbih0LGUpe2lmKCh0PXQmJnRvKHQpKT09PWRvY3VtZW50LmJvZHl8fHQ9PT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpcmV0dXJuIHRoaXM7dmFyIG49dGhpcy4kb3B0aW9ucztpZighbi5yZW5kZXIpe3ZhciByPW4udGVtcGxhdGU7aWYocilpZihcInN0cmluZ1wiPT10eXBlb2YgcilcIiNcIj09PXIuY2hhckF0KDApJiYocj1tYyhyKSk7ZWxzZXtpZighci5ub2RlVHlwZSlyZXR1cm4gdGhpcztyPXIuaW5uZXJIVE1MfWVsc2UgdCYmKHI9ZnVuY3Rpb24odCl7aWYodC5vdXRlckhUTUwpcmV0dXJuIHQub3V0ZXJIVE1MO3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7cmV0dXJuIGUuYXBwZW5kQ2hpbGQodC5jbG9uZU5vZGUoITApKSxlLmlubmVySFRNTH0odCkpO2lmKHIpe3ZhciBvPWRjKHIse291dHB1dFNvdXJjZVJhbmdlOiExLHNob3VsZERlY29kZU5ld2xpbmVzOnZjLHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjpoYyxkZWxpbWl0ZXJzOm4uZGVsaW1pdGVycyxjb21tZW50czpuLmNvbW1lbnRzfSx0aGlzKSxpPW8ucmVuZGVyLGE9by5zdGF0aWNSZW5kZXJGbnM7bi5yZW5kZXI9aSxuLnN0YXRpY1JlbmRlckZucz1hfX1yZXR1cm4gZ2MuY2FsbCh0aGlzLHQsZSl9LENyLmNvbXBpbGU9ZGMsVChDcixGbiksQ3IuZWZmZWN0PWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IFZuKGN0LHQsaix7c3luYzohMH0pO2UmJihuLnVwZGF0ZT1mdW5jdGlvbigpe2UoKGZ1bmN0aW9uKCl7cmV0dXJuIG4ucnVuKCl9KSl9KX0sQ3J9KSk7IiwiLyohXG4gKiBWdWUuanMgdjIuNy4xNFxuICogKGMpIDIwMTQtMjAyMiBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbi8vIFRoZXNlIGhlbHBlcnMgcHJvZHVjZSBiZXR0ZXIgVk0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZy5cbmZ1bmN0aW9uIGlzVW5kZWYodikge1xuICAgIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzRGVmKHYpIHtcbiAgICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGw7XG59XG5mdW5jdGlvbiBpc1RydWUodikge1xuICAgIHJldHVybiB2ID09PSB0cnVlO1xufVxuZnVuY3Rpb24gaXNGYWxzZSh2KSB7XG4gICAgcmV0dXJuIHYgPT09IGZhbHNlO1xufVxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmUuXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHxcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogb2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xufVxuLyoqXG4gKiBHZXQgdGhlIHJhdyB0eXBlIHN0cmluZyBvZiBhIHZhbHVlLCBlLmcuLCBbb2JqZWN0IE9iamVjdF0uXG4gKi9cbmNvbnN0IF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5mdW5jdGlvbiB0b1Jhd1R5cGUodmFsdWUpIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKTtcbn1cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5mdW5jdGlvbiBpc1JlZ0V4cCh2KSB7XG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4KHZhbCkge1xuICAgIGNvbnN0IG4gPSBwYXJzZUZsb2F0KFN0cmluZyh2YWwpKTtcbiAgICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKTtcbn1cbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWwpIHtcbiAgICByZXR1cm4gKGlzRGVmKHZhbCkgJiZcbiAgICAgICAgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiB2YWwuY2F0Y2ggPT09ICdmdW5jdGlvbicpO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgICAgID8gJydcbiAgICAgICAgOiBBcnJheS5pc0FycmF5KHZhbCkgfHwgKGlzUGxhaW5PYmplY3QodmFsKSAmJiB2YWwudG9TdHJpbmcgPT09IF90b1N0cmluZylcbiAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgICAgICAgOiBTdHJpbmcodmFsKTtcbn1cbi8qKlxuICogQ29udmVydCBhbiBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsKSB7XG4gICAgY29uc3QgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xufVxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwKHN0ciwgZXhwZWN0c0xvd2VyQ2FzZSkge1xuICAgIGNvbnN0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3QgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZSA/IHZhbCA9PiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldIDogdmFsID0+IG1hcFt2YWxdO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xuY29uc3QgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcbi8qKlxuICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuICovXG5jb25zdCBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXMnKTtcbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlJDIoYXJyLCBpdGVtKSB7XG4gICAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBpZiAobGVuKSB7XG4gICAgICAgIC8vIGZhc3QgcGF0aCBmb3IgdGhlIG9ubHkgLyBsYXN0IGl0ZW1cbiAgICAgICAgaWYgKGl0ZW0gPT09IGFycltsZW4gLSAxXSkge1xuICAgICAgICAgICAgYXJyLmxlbmd0aCA9IGxlbiAtIDE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbiBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZChmbikge1xuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2FjaGVkRm4oc3RyKSB7XG4gICAgICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XG4gICAgICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcbiAgICB9O1xufVxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuY29uc3QgY2FtZWxpemUgPSBjYWNoZWQoKHN0cikgPT4ge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoXywgYykgPT4gKGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJykpO1xufSk7XG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZWQoKHN0cikgPT4ge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59KTtcbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xuY29uc3QgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVkKChzdHIpID0+IHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpO1xufSk7XG4vKipcbiAqIFNpbXBsZSBiaW5kIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCxcbiAqIGUuZy4sIFBoYW50b21KUyAxLnguIFRlY2huaWNhbGx5LCB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZVxuICogc2luY2UgbmF0aXZlIGJpbmQgaXMgbm93IHBlcmZvcm1hbnQgZW5vdWdoIGluIG1vc3QgYnJvd3NlcnMuXG4gKiBCdXQgcmVtb3ZpbmcgaXQgd291bGQgbWVhbiBicmVha2luZyBjb2RlIHRoYXQgd2FzIGFibGUgdG8gcnVuIGluXG4gKiBQaGFudG9tSlMgMS54LCBzbyB0aGlzIG11c3QgYmUga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIHBvbHlmaWxsQmluZChmbiwgY3R4KSB7XG4gICAgZnVuY3Rpb24gYm91bmRGbihhKSB7XG4gICAgICAgIGNvbnN0IGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbFxuICAgICAgICAgICAgPyBsID4gMVxuICAgICAgICAgICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgICAgICAgIDogZm4uY2FsbChjdHgpO1xuICAgIH1cbiAgICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gICAgcmV0dXJuIGJvdW5kRm47XG59XG5mdW5jdGlvbiBuYXRpdmVCaW5kKGZuLCBjdHgpIHtcbiAgICByZXR1cm4gZm4uYmluZChjdHgpO1xufVxuLy8gQHRzLWV4cGVjdC1lcnJvciBiaW5kIGNhbm5vdCBiZSBgdW5kZWZpbmVkYFxuY29uc3QgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID8gbmF0aXZlQmluZCA6IHBvbHlmaWxsQmluZDtcbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkobGlzdCwgc3RhcnQpIHtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgbGV0IGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICAgIGNvbnN0IHJldCA9IG5ldyBBcnJheShpKTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQodG8sIF9mcm9tKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gX2Zyb20pIHtcbiAgICAgICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0bztcbn1cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QoYXJyKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycltpXSkge1xuICAgICAgICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKS5cbiAqL1xuZnVuY3Rpb24gbm9vcChhLCBiLCBjKSB7IH1cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xuY29uc3Qgbm8gPSAoYSwgYiwgYykgPT4gZmFsc2U7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG4vKipcbiAqIFJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAqL1xuY29uc3QgaWRlbnRpdHkgPSAoXykgPT4gXztcbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgICBjb25zdCBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgICAgICAgY29uc3QgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgYS5ldmVyeSgoZSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBrZXlzQS5ldmVyeShrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJuIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGxvb3NlbHkgZXF1YWwgdmFsdWUgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgYXJyYXkgKGlmIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGUgYXJyYXkgbXVzdFxuICogY29udGFpbiBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc2hhcGUpLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAqL1xuZnVuY3Rpb24gbG9vc2VJbmRleE9mKGFyciwgdmFsKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZShmbikge1xuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzI3BvbHlmaWxsXG5mdW5jdGlvbiBoYXNDaGFuZ2VkKHgsIHkpIHtcbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICByZXR1cm4geCA9PT0gMCAmJiAxIC8geCAhPT0gMSAvIHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geCA9PT0geCB8fCB5ID09PSB5O1xuICAgIH1cbn1cblxuY29uc3QgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuY29uc3QgQVNTRVRfVFlQRVMgPSBbJ2NvbXBvbmVudCcsICdkaXJlY3RpdmUnLCAnZmlsdGVyJ107XG5jb25zdCBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICAgJ2JlZm9yZUNyZWF0ZScsXG4gICAgJ2NyZWF0ZWQnLFxuICAgICdiZWZvcmVNb3VudCcsXG4gICAgJ21vdW50ZWQnLFxuICAgICdiZWZvcmVVcGRhdGUnLFxuICAgICd1cGRhdGVkJyxcbiAgICAnYmVmb3JlRGVzdHJveScsXG4gICAgJ2Rlc3Ryb3llZCcsXG4gICAgJ2FjdGl2YXRlZCcsXG4gICAgJ2RlYWN0aXZhdGVkJyxcbiAgICAnZXJyb3JDYXB0dXJlZCcsXG4gICAgJ3NlcnZlclByZWZldGNoJyxcbiAgICAncmVuZGVyVHJhY2tlZCcsXG4gICAgJ3JlbmRlclRyaWdnZXJlZCdcbl07XG5cbnZhciBjb25maWcgPSB7XG4gICAgLyoqXG4gICAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAgICovXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAgICovXG4gICAgc2lsZW50OiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgICAqL1xuICAgIHByb2R1Y3Rpb25UaXA6IHRydWUsXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICAgKi9cbiAgICBkZXZ0b29sczogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAgICovXG4gICAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAgICovXG4gICAgZXJyb3JIYW5kbGVyOiBudWxsLFxuICAgIC8qKlxuICAgICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgICAqL1xuICAgIHdhcm5IYW5kbGVyOiBudWxsLFxuICAgIC8qKlxuICAgICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgICAqL1xuICAgIGlnbm9yZWRFbGVtZW50czogW10sXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICAgKi9cbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAgICovXG4gICAgaXNSZXNlcnZlZFRhZzogbm8sXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgICAqL1xuICAgIGlzUmVzZXJ2ZWRBdHRyOiBubyxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgICAqL1xuICAgIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICAgKi9cbiAgICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAgICovXG4gICAgbXVzdFVzZVByb3A6IG5vLFxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gdXBkYXRlcyBhc3luY2hyb25vdXNseS4gSW50ZW5kZWQgdG8gYmUgdXNlZCBieSBWdWUgVGVzdCBVdGlsc1xuICAgICAqIFRoaXMgd2lsbCBzaWduaWZpY2FudGx5IHJlZHVjZSBwZXJmb3JtYW5jZSBpZiBzZXQgdG8gZmFsc2UuXG4gICAgICovXG4gICAgYXN5bmM6IHRydWUsXG4gICAgLyoqXG4gICAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICAgKi9cbiAgICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufTtcblxuLyoqXG4gKiB1bmljb2RlIGxldHRlcnMgdXNlZCBmb3IgcGFyc2luZyBodG1sIHRhZ3MsIGNvbXBvbmVudCBuYW1lcyBhbmQgcHJvcGVydHkgcGF0aHMuXG4gKiB1c2luZyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUzL3NlbWFudGljcy1zY3JpcHRpbmcuaHRtbCNwb3RlbnRpYWxjdXN0b21lbGVtZW50bmFtZVxuICogc2tpcHBpbmcgXFx1MTAwMDAtXFx1RUZGRkYgZHVlIHRvIGl0IGZyZWV6aW5nIHVwIFBoYW50b21KU1xuICovXG5jb25zdCB1bmljb2RlUmVnRXhwID0gL2EtekEtWlxcdTAwQjdcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDNGLVxcdTIwNDBcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkQvO1xuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZChzdHIpIHtcbiAgICBjb25zdCBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICAgIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NWY7XG59XG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbn1cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbmNvbnN0IGJhaWxSRSA9IG5ldyBSZWdFeHAoYFteJHt1bmljb2RlUmVnRXhwLnNvdXJjZX0uJF9cXFxcZF1gKTtcbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gICAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFvYmopXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG59XG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xuY29uc3QgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbmNvbnN0IGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuY29uc3QgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbmNvbnN0IGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbmNvbnN0IGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG5jb25zdCBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcblVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDA7XG5jb25zdCBpc0lPUyA9IFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSk7XG5VQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcblVBICYmIC9waGFudG9tanMvLnRlc3QoVUEpO1xuY29uc3QgaXNGRiA9IFVBICYmIFVBLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLyk7XG4vLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG4vLyBAdHMtZXhwZWN0LWVycm9yIGZpcmVib3ggc3VwcG9ydFxuY29uc3QgbmF0aXZlV2F0Y2ggPSB7fS53YXRjaDtcbmxldCBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBvcHRzID0ge307XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxufVxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxubGV0IF9pc1NlcnZlcjtcbmNvbnN0IGlzU2VydmVyUmVuZGVyaW5nID0gKCkgPT4ge1xuICAgIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgICAgICAgX2lzU2VydmVyID1cbiAgICAgICAgICAgICAgICBnbG9iYWxbJ3Byb2Nlc3MnXSAmJiBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2lzU2VydmVyO1xufTtcbi8vIGRldGVjdCBkZXZ0b29sc1xuY29uc3QgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUoQ3Rvcikge1xuICAgIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKTtcbn1cbmNvbnN0IGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmXG4gICAgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICAgIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5sZXQgX1NldDsgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgICBfU2V0ID0gU2V0O1xufVxuZWxzZSB7XG4gICAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICAgIF9TZXQgPSBjbGFzcyBTZXQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBoYXMoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBhZGQoa2V5KSB7XG4gICAgICAgICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhcigpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmxldCBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xuLyoqXG4gKiBUaGlzIGlzIGV4cG9zZWQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB2MyAoZS5nLiBzb21lIGZ1bmN0aW9ucyBpbiBWdWVVc2VcbiAqIHJlbGllcyBvbiBpdCkuIERvIG5vdCB1c2UgdGhpcyBpbnRlcm5hbGx5LCBqdXN0IHVzZSBgY3VycmVudEluc3RhbmNlYC5cbiAqXG4gKiBAaW50ZXJuYWwgdGhpcyBmdW5jdGlvbiBuZWVkcyBtYW51YWwgdHlwZSBkZWNsYXJhdGlvbiBiZWNhdXNlIGl0IHJlbGllc1xuICogb24gcHJldmlvdXNseSBtYW51YWxseSBhdXRob3JlZCB0eXBlcyBmcm9tIFZ1ZSAyXG4gKi9cbmZ1bmN0aW9uIGdldEN1cnJlbnRJbnN0YW5jZSgpIHtcbiAgICByZXR1cm4gY3VycmVudEluc3RhbmNlICYmIHsgcHJveHk6IGN1cnJlbnRJbnN0YW5jZSB9O1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gc2V0Q3VycmVudEluc3RhbmNlKHZtID0gbnVsbCkge1xuICAgIGlmICghdm0pXG4gICAgICAgIGN1cnJlbnRJbnN0YW5jZSAmJiBjdXJyZW50SW5zdGFuY2UuX3Njb3BlLm9mZigpO1xuICAgIGN1cnJlbnRJbnN0YW5jZSA9IHZtO1xuICAgIHZtICYmIHZtLl9zY29wZS5vbigpO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBWTm9kZSB7XG4gICAgY29uc3RydWN0b3IodGFnLCBkYXRhLCBjaGlsZHJlbiwgdGV4dCwgZWxtLCBjb250ZXh0LCBjb21wb25lbnRPcHRpb25zLCBhc3luY0ZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5lbG0gPSBlbG07XG4gICAgICAgIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmF3ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICAgICAgICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZ2V0IGNoaWxkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB9XG59XG5jb25zdCBjcmVhdGVFbXB0eVZOb2RlID0gKHRleHQgPSAnJykgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgICBub2RlLnRleHQgPSB0ZXh0O1xuICAgIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gbm9kZTtcbn07XG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUodmFsKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSk7XG59XG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSh2bm9kZSkge1xuICAgIGNvbnN0IGNsb25lZCA9IG5ldyBWTm9kZSh2bm9kZS50YWcsIHZub2RlLmRhdGEsIFxuICAgIC8vICM3OTc1XG4gICAgLy8gY2xvbmUgY2hpbGRyZW4gYXJyYXkgdG8gYXZvaWQgbXV0YXRpbmcgb3JpZ2luYWwgaW4gY2FzZSBvZiBjbG9uaW5nXG4gICAgLy8gYSBjaGlsZC5cbiAgICB2bm9kZS5jaGlsZHJlbiAmJiB2bm9kZS5jaGlsZHJlbi5zbGljZSgpLCB2bm9kZS50ZXh0LCB2bm9kZS5lbG0sIHZub2RlLmNvbnRleHQsIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsIHZub2RlLmFzeW5jRmFjdG9yeSk7XG4gICAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gICAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gICAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICAgIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gICAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgICBjbG9uZWQuZm5TY29wZUlkID0gdm5vZGUuZm5TY29wZUlkO1xuICAgIGNsb25lZC5hc3luY01ldGEgPSB2bm9kZS5hc3luY01ldGE7XG4gICAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gY2xvbmVkO1xufVxuXG5sZXQgdWlkJDIgPSAwO1xuY29uc3QgcGVuZGluZ0NsZWFudXBEZXBzID0gW107XG5jb25zdCBjbGVhbnVwRGVwcyA9ICgpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlbmRpbmdDbGVhbnVwRGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkZXAgPSBwZW5kaW5nQ2xlYW51cERlcHNbaV07XG4gICAgICAgIGRlcC5zdWJzID0gZGVwLnN1YnMuZmlsdGVyKHMgPT4gcyk7XG4gICAgICAgIGRlcC5fcGVuZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBwZW5kaW5nQ2xlYW51cERlcHMubGVuZ3RoID0gMDtcbn07XG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBEZXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBwZW5kaW5nIHN1YnMgY2xlYW51cFxuICAgICAgICB0aGlzLl9wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaWQgPSB1aWQkMisrO1xuICAgICAgICB0aGlzLnN1YnMgPSBbXTtcbiAgICB9XG4gICAgYWRkU3ViKHN1Yikge1xuICAgICAgICB0aGlzLnN1YnMucHVzaChzdWIpO1xuICAgIH1cbiAgICByZW1vdmVTdWIoc3ViKSB7XG4gICAgICAgIC8vICMxMjY5NiBkZXBzIHdpdGggbWFzc2l2ZSBhbW91bnQgb2Ygc3Vic2NyaWJlcnMgYXJlIGV4dHJlbWVseSBzbG93IHRvXG4gICAgICAgIC8vIGNsZWFuIHVwIGluIENocm9taXVtXG4gICAgICAgIC8vIHRvIHdvcmthcm91bmQgdGhpcywgd2UgdW5zZXQgdGhlIHN1YiBmb3Igbm93LCBhbmQgY2xlYXIgdGhlbSBvblxuICAgICAgICAvLyBuZXh0IHNjaGVkdWxlciBmbHVzaC5cbiAgICAgICAgdGhpcy5zdWJzW3RoaXMuc3Vicy5pbmRleE9mKHN1YildID0gbnVsbDtcbiAgICAgICAgaWYgKCF0aGlzLl9wZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHBlbmRpbmdDbGVhbnVwRGVwcy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlcGVuZChpbmZvKSB7XG4gICAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgICAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgICAgICAgICAgIGlmIChpbmZvICYmIERlcC50YXJnZXQub25UcmFjaykge1xuICAgICAgICAgICAgICAgIERlcC50YXJnZXQub25UcmFjayhPYmplY3QuYXNzaWduKHsgZWZmZWN0OiBEZXAudGFyZ2V0IH0sIGluZm8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBub3RpZnkoaW5mbykge1xuICAgICAgICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICAgICAgICBjb25zdCBzdWJzID0gdGhpcy5zdWJzLmZpbHRlcihzID0+IHMpO1xuICAgICAgICBpZiAoIWNvbmZpZy5hc3luYykge1xuICAgICAgICAgICAgLy8gc3VicyBhcmVuJ3Qgc29ydGVkIGluIHNjaGVkdWxlciBpZiBub3QgcnVubmluZyBhc3luY1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBzb3J0IHRoZW0gbm93IHRvIG1ha2Ugc3VyZSB0aGV5IGZpcmUgaW4gY29ycmVjdFxuICAgICAgICAgICAgLy8gb3JkZXJcbiAgICAgICAgICAgIHN1YnMuc29ydCgoYSwgYikgPT4gYS5pZCAtIGIuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IHN1YnNbaV07XG4gICAgICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgICAgIHN1Yi5vblRyaWdnZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgc3ViLm9uVHJpZ2dlcihPYmplY3QuYXNzaWduKHsgZWZmZWN0OiBzdWJzW2ldIH0sIGluZm8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1Yi51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIFRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2Ugb25seSBvbmUgd2F0Y2hlclxuLy8gY2FuIGJlIGV2YWx1YXRlZCBhdCBhIHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbmNvbnN0IHRhcmdldFN0YWNrID0gW107XG5mdW5jdGlvbiBwdXNoVGFyZ2V0KHRhcmdldCkge1xuICAgIHRhcmdldFN0YWNrLnB1c2godGFyZ2V0KTtcbiAgICBEZXAudGFyZ2V0ID0gdGFyZ2V0O1xufVxuZnVuY3Rpb24gcG9wVGFyZ2V0KCkge1xuICAgIHRhcmdldFN0YWNrLnBvcCgpO1xuICAgIERlcC50YXJnZXQgPSB0YXJnZXRTdGFja1t0YXJnZXRTdGFjay5sZW5ndGggLSAxXTtcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cbmNvbnN0IGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5jb25zdCBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1xuY29uc3QgbWV0aG9kc1RvUGF0Y2ggPSBbXG4gICAgJ3B1c2gnLFxuICAgICdwb3AnLFxuICAgICdzaGlmdCcsXG4gICAgJ3Vuc2hpZnQnLFxuICAgICdzcGxpY2UnLFxuICAgICdzb3J0JyxcbiAgICAncmV2ZXJzZSdcbl07XG4vKipcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICovXG5tZXRob2RzVG9QYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgICBjb25zdCBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IoLi4uYXJncykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgY29uc3Qgb2IgPSB0aGlzLl9fb2JfXztcbiAgICAgICAgbGV0IGluc2VydGVkO1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSAncHVzaCc6XG4gICAgICAgICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICAgICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zZXJ0ZWQpXG4gICAgICAgICAgICBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpO1xuICAgICAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgICAgIHtcbiAgICAgICAgICAgIG9iLmRlcC5ub3RpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXkgbXV0YXRpb25cIiAvKiBUcmlnZ2VyT3BUeXBlcy5BUlJBWV9NVVRBVElPTiAqLyxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICAgICAga2V5OiBtZXRob2RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG59KTtcblxuY29uc3QgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcbmNvbnN0IE5PX0lOSUlUSUFMX1ZBTFVFID0ge307XG4vKipcbiAqIEluIHNvbWUgY2FzZXMgd2UgbWF5IHdhbnQgdG8gZGlzYWJsZSBvYnNlcnZhdGlvbiBpbnNpZGUgYSBjb21wb25lbnQnc1xuICogdXBkYXRlIGNvbXB1dGF0aW9uLlxuICovXG5sZXQgc2hvdWxkT2JzZXJ2ZSA9IHRydWU7XG5mdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcodmFsdWUpIHtcbiAgICBzaG91bGRPYnNlcnZlID0gdmFsdWU7XG59XG4vLyBzc3IgbW9jayBkZXBcbmNvbnN0IG1vY2tEZXAgPSB7XG4gICAgbm90aWZ5OiBub29wLFxuICAgIGRlcGVuZDogbm9vcCxcbiAgICBhZGRTdWI6IG5vb3AsXG4gICAgcmVtb3ZlU3ViOiBub29wXG59O1xuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGlzIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2ggdXBkYXRlcy5cbiAqL1xuY2xhc3MgT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBzaGFsbG93ID0gZmFsc2UsIG1vY2sgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc2hhbGxvdyA9IHNoYWxsb3c7XG4gICAgICAgIHRoaXMubW9jayA9IG1vY2s7XG4gICAgICAgIC8vIHRoaXMudmFsdWUgPSB2YWx1ZVxuICAgICAgICB0aGlzLmRlcCA9IG1vY2sgPyBtb2NrRGVwIDogbmV3IERlcCgpO1xuICAgICAgICB0aGlzLnZtQ291bnQgPSAwO1xuICAgICAgICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoIW1vY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUHJvdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuX19wcm90b19fID0gYXJyYXlNZXRob2RzO1xuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFycmF5S2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGFycmF5S2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZih2YWx1ZSwga2V5LCBhcnJheU1ldGhvZHNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNoYWxsb3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdhbGsgdGhyb3VnaCBhbGwgcHJvcGVydGllcyBhbmQgY29udmVydCB0aGVtIGludG9cbiAgICAgICAgICAgICAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICAgICAgICAgICAgICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlKHZhbHVlLCBrZXksIE5PX0lOSUlUSUFMX1ZBTFVFLCB1bmRlZmluZWQsIHNoYWxsb3csIG1vY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICAgICAqL1xuICAgIG9ic2VydmVBcnJheSh2YWx1ZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgb2JzZXJ2ZSh2YWx1ZVtpXSwgZmFsc2UsIHRoaXMubW9jayk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBoZWxwZXJzXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlKHZhbHVlLCBzaGFsbG93LCBzc3JNb2NrUmVhY3Rpdml0eSkge1xuICAgIGlmICh2YWx1ZSAmJiBoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgICAgICByZXR1cm4gdmFsdWUuX19vYl9fO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkT2JzZXJ2ZSAmJlxuICAgICAgICAoc3NyTW9ja1JlYWN0aXZpdHkgfHwgIWlzU2VydmVyUmVuZGVyaW5nKCkpICYmXG4gICAgICAgIChpc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICAgICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAgICAgIXZhbHVlLl9fdl9za2lwIC8qIFJlYWN0aXZlRmxhZ3MuU0tJUCAqLyAmJlxuICAgICAgICAhaXNSZWYodmFsdWUpICYmXG4gICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZlcih2YWx1ZSwgc2hhbGxvdywgc3NyTW9ja1JlYWN0aXZpdHkpO1xuICAgIH1cbn1cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZShvYmosIGtleSwgdmFsLCBjdXN0b21TZXR0ZXIsIHNoYWxsb3csIG1vY2spIHtcbiAgICBjb25zdCBkZXAgPSBuZXcgRGVwKCk7XG4gICAgY29uc3QgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICAgIGNvbnN0IGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgICBjb25zdCBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG4gICAgaWYgKCghZ2V0dGVyIHx8IHNldHRlcikgJiZcbiAgICAgICAgKHZhbCA9PT0gTk9fSU5JSVRJQUxfVkFMVUUgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikpIHtcbiAgICAgICAgdmFsID0gb2JqW2tleV07XG4gICAgfVxuICAgIGxldCBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZSh2YWwsIGZhbHNlLCBtb2NrKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyKCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGRlcC5kZXBlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBvYmosXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImdldFwiIC8qIFRyYWNrT3BUeXBlcy5HRVQgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1JlZih2YWx1ZSkgJiYgIXNoYWxsb3cgPyB2YWx1ZS52YWx1ZSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyKG5ld1ZhbCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgICAgICAgaWYgKCFoYXNDaGFuZ2VkKHZhbHVlLCBuZXdWYWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1c3RvbVNldHRlcikge1xuICAgICAgICAgICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICAgICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGdldHRlcikge1xuICAgICAgICAgICAgICAgIC8vICM3OTgxOiBmb3IgYWNjZXNzb3IgcHJvcGVydGllcyB3aXRob3V0IHNldHRlclxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFzaGFsbG93ICYmIGlzUmVmKHZhbHVlKSAmJiAhaXNSZWYobmV3VmFsKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLnZhbHVlID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCwgZmFsc2UsIG1vY2spO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRlcC5ub3RpZnkoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiIC8qIFRyaWdnZXJPcFR5cGVzLlNFVCAqLyxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBvYmosXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbCxcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGVwO1xufVxuZnVuY3Rpb24gc2V0KHRhcmdldCwga2V5LCB2YWwpIHtcbiAgICBpZiAoKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKSkge1xuICAgICAgICB3YXJuKGBDYW5ub3Qgc2V0IHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiAke3RhcmdldH1gKTtcbiAgICB9XG4gICAgaWYgKGlzUmVhZG9ubHkodGFyZ2V0KSkge1xuICAgICAgICB3YXJuKGBTZXQgb3BlcmF0aW9uIG9uIGtleSBcIiR7a2V5fVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9iID0gdGFyZ2V0Ll9fb2JfXztcbiAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICAgICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgICAgICAvLyB3aGVuIG1vY2tpbmcgZm9yIFNTUiwgYXJyYXkgbWV0aG9kcyBhcmUgbm90IGhpamFja2VkXG4gICAgICAgIGlmIChvYiAmJiAhb2Iuc2hhbGxvdyAmJiBvYi5tb2NrKSB7XG4gICAgICAgICAgICBvYnNlcnZlKHZhbCwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICAgICAgd2FybignQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAgICAgICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLicpO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBpZiAoIW9iKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBkZWZpbmVSZWFjdGl2ZShvYi52YWx1ZSwga2V5LCB2YWwsIHVuZGVmaW5lZCwgb2Iuc2hhbGxvdywgb2IubW9jayk7XG4gICAge1xuICAgICAgICBvYi5kZXAubm90aWZ5KHtcbiAgICAgICAgICAgIHR5cGU6IFwiYWRkXCIgLyogVHJpZ2dlck9wVHlwZXMuQUREICovLFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBuZXdWYWx1ZTogdmFsLFxuICAgICAgICAgICAgb2xkVmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIGRlbCh0YXJnZXQsIGtleSkge1xuICAgIGlmICgoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpKSB7XG4gICAgICAgIHdhcm4oYENhbm5vdCBkZWxldGUgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6ICR7dGFyZ2V0fWApO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICAgICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9iID0gdGFyZ2V0Ll9fb2JfXztcbiAgICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICAgICAgd2FybignQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICAgICAgICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1JlYWRvbmx5KHRhcmdldCkpIHtcbiAgICAgICAgd2FybihgRGVsZXRlIG9wZXJhdGlvbiBvbiBrZXkgXCIke2tleX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgdGFyZ2V0W2tleV07XG4gICAgaWYgKCFvYikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHtcbiAgICAgICAgb2IuZGVwLm5vdGlmeSh7XG4gICAgICAgICAgICB0eXBlOiBcImRlbGV0ZVwiIC8qIFRyaWdnZXJPcFR5cGVzLkRFTEVURSAqLyxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAga2V5XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSh2YWx1ZSkge1xuICAgIGZvciAobGV0IGUsIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGUgPSB2YWx1ZVtpXTtcbiAgICAgICAgaWYgKGUgJiYgZS5fX29iX18pIHtcbiAgICAgICAgICAgIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheShlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlYWN0aXZlKHRhcmdldCkge1xuICAgIG1ha2VSZWFjdGl2ZSh0YXJnZXQsIGZhbHNlKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuLyoqXG4gKiBSZXR1cm4gYSBzaGFsbG93bHktcmVhY3RpdmUgY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LCB3aGVyZSBvbmx5IHRoZSByb290XG4gKiBsZXZlbCBwcm9wZXJ0aWVzIGFyZSByZWFjdGl2ZS4gSXQgYWxzbyBkb2VzIG5vdCBhdXRvLXVud3JhcCByZWZzIChldmVuIGF0IHRoZVxuICogcm9vdCBsZXZlbCkuXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dSZWFjdGl2ZSh0YXJnZXQpIHtcbiAgICBtYWtlUmVhY3RpdmUodGFyZ2V0LCB0cnVlKTtcbiAgICBkZWYodGFyZ2V0LCBcIl9fdl9pc1NoYWxsb3dcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1NIQUxMT1cgKi8sIHRydWUpO1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBtYWtlUmVhY3RpdmUodGFyZ2V0LCBzaGFsbG93KSB7XG4gICAgLy8gaWYgdHJ5aW5nIHRvIG9ic2VydmUgYSByZWFkb25seSBwcm94eSwgcmV0dXJuIHRoZSByZWFkb25seSB2ZXJzaW9uLlxuICAgIGlmICghaXNSZWFkb25seSh0YXJnZXQpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBBdm9pZCB1c2luZyBBcnJheSBhcyByb290IHZhbHVlIGZvciAke3NoYWxsb3cgPyBgc2hhbGxvd1JlYWN0aXZlKClgIDogYHJlYWN0aXZlKClgfSBhcyBpdCBjYW5ub3QgYmUgdHJhY2tlZCBpbiB3YXRjaCgpIG9yIHdhdGNoRWZmZWN0KCkuIFVzZSAke3NoYWxsb3cgPyBgc2hhbGxvd1JlZigpYCA6IGByZWYoKWB9IGluc3RlYWQuIFRoaXMgaXMgYSBWdWUtMi1vbmx5IGxpbWl0YXRpb24uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ09iID0gdGFyZ2V0ICYmIHRhcmdldC5fX29iX187XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdPYiAmJiBleGlzdGluZ09iLnNoYWxsb3cgIT09IHNoYWxsb3cpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBUYXJnZXQgaXMgYWxyZWFkeSBhICR7ZXhpc3RpbmdPYi5zaGFsbG93ID8gYGAgOiBgbm9uLWB9c2hhbGxvdyByZWFjdGl2ZSBvYmplY3QsIGFuZCBjYW5ub3QgYmUgY29udmVydGVkIHRvICR7c2hhbGxvdyA/IGBgIDogYG5vbi1gfXNoYWxsb3cuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2IgPSBvYnNlcnZlKHRhcmdldCwgc2hhbGxvdywgaXNTZXJ2ZXJSZW5kZXJpbmcoKSAvKiBzc3IgbW9jayByZWFjdGl2aXR5ICovKTtcbiAgICAgICAgaWYgKCFvYikge1xuICAgICAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGB2YWx1ZSBjYW5ub3QgYmUgbWFkZSByZWFjdGl2ZTogJHtTdHJpbmcodGFyZ2V0KX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0NvbGxlY3Rpb25UeXBlKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBWdWUgMiBkb2VzIG5vdCBzdXBwb3J0IHJlYWN0aXZlIGNvbGxlY3Rpb24gdHlwZXMgc3VjaCBhcyBNYXAgb3IgU2V0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNSZWFjdGl2ZSh2YWx1ZSkge1xuICAgIGlmIChpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZVtcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqL10pO1xuICAgIH1cbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19vYl9fKTtcbn1cbmZ1bmN0aW9uIGlzU2hhbGxvdyh2YWx1ZSkge1xuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX3ZfaXNTaGFsbG93KTtcbn1cbmZ1bmN0aW9uIGlzUmVhZG9ubHkodmFsdWUpIHtcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX192X2lzUmVhZG9ubHkpO1xufVxuZnVuY3Rpb24gaXNQcm94eSh2YWx1ZSkge1xuICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlKSB8fCBpc1JlYWRvbmx5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHRvUmF3KG9ic2VydmVkKSB7XG4gICAgY29uc3QgcmF3ID0gb2JzZXJ2ZWQgJiYgb2JzZXJ2ZWRbXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi9dO1xuICAgIHJldHVybiByYXcgPyB0b1JhdyhyYXcpIDogb2JzZXJ2ZWQ7XG59XG5mdW5jdGlvbiBtYXJrUmF3KHZhbHVlKSB7XG4gICAgLy8gbm9uLWV4dGVuc2libGUgb2JqZWN0cyB3b24ndCBiZSBvYnNlcnZlZCBhbnl3YXlcbiAgICBpZiAoT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgZGVmKHZhbHVlLCBcIl9fdl9za2lwXCIgLyogUmVhY3RpdmVGbGFncy5TS0lQICovLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNDb2xsZWN0aW9uVHlwZSh2YWx1ZSkge1xuICAgIGNvbnN0IHR5cGUgPSB0b1Jhd1R5cGUodmFsdWUpO1xuICAgIHJldHVybiAodHlwZSA9PT0gJ01hcCcgfHwgdHlwZSA9PT0gJ1dlYWtNYXAnIHx8IHR5cGUgPT09ICdTZXQnIHx8IHR5cGUgPT09ICdXZWFrU2V0Jyk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFJlZkZsYWcgPSBgX192X2lzUmVmYDtcbmZ1bmN0aW9uIGlzUmVmKHIpIHtcbiAgICByZXR1cm4gISEociAmJiByLl9fdl9pc1JlZiA9PT0gdHJ1ZSk7XG59XG5mdW5jdGlvbiByZWYkMSh2YWx1ZSkge1xuICAgIHJldHVybiBjcmVhdGVSZWYodmFsdWUsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dSZWYodmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlZihyYXdWYWx1ZSwgc2hhbGxvdykge1xuICAgIGlmIChpc1JlZihyYXdWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHJhd1ZhbHVlO1xuICAgIH1cbiAgICBjb25zdCByZWYgPSB7fTtcbiAgICBkZWYocmVmLCBSZWZGbGFnLCB0cnVlKTtcbiAgICBkZWYocmVmLCBcIl9fdl9pc1NoYWxsb3dcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1NIQUxMT1cgKi8sIHNoYWxsb3cpO1xuICAgIGRlZihyZWYsICdkZXAnLCBkZWZpbmVSZWFjdGl2ZShyZWYsICd2YWx1ZScsIHJhd1ZhbHVlLCBudWxsLCBzaGFsbG93LCBpc1NlcnZlclJlbmRlcmluZygpKSk7XG4gICAgcmV0dXJuIHJlZjtcbn1cbmZ1bmN0aW9uIHRyaWdnZXJSZWYocmVmKSB7XG4gICAgaWYgKCFyZWYuZGVwKSB7XG4gICAgICAgIHdhcm4oYHJlY2VpdmVkIG9iamVjdCBpcyBub3QgYSB0cmlnZ2VyYWJsZSByZWYuYCk7XG4gICAgfVxuICAgIHtcbiAgICAgICAgcmVmLmRlcCAmJlxuICAgICAgICAgICAgcmVmLmRlcC5ub3RpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIgLyogVHJpZ2dlck9wVHlwZXMuU0VUICovLFxuICAgICAgICAgICAgICAgIHRhcmdldDogcmVmLFxuICAgICAgICAgICAgICAgIGtleTogJ3ZhbHVlJ1xuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdW5yZWYocmVmKSB7XG4gICAgcmV0dXJuIGlzUmVmKHJlZikgPyByZWYudmFsdWUgOiByZWY7XG59XG5mdW5jdGlvbiBwcm94eVJlZnMob2JqZWN0V2l0aFJlZnMpIHtcbiAgICBpZiAoaXNSZWFjdGl2ZShvYmplY3RXaXRoUmVmcykpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFdpdGhSZWZzO1xuICAgIH1cbiAgICBjb25zdCBwcm94eSA9IHt9O1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3RXaXRoUmVmcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByb3h5V2l0aFJlZlVud3JhcChwcm94eSwgb2JqZWN0V2l0aFJlZnMsIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJveHk7XG59XG5mdW5jdGlvbiBwcm94eVdpdGhSZWZVbndyYXAodGFyZ2V0LCBzb3VyY2UsIGtleSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gc291cmNlW2tleV07XG4gICAgICAgICAgICBpZiAoaXNSZWYodmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYiA9IHZhbCAmJiB2YWwuX19vYl9fO1xuICAgICAgICAgICAgICAgIGlmIChvYilcbiAgICAgICAgICAgICAgICAgICAgb2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogdmFsdWUgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIGlmIChpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzb3VyY2Vba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjdXN0b21SZWYoZmFjdG9yeSkge1xuICAgIGNvbnN0IGRlcCA9IG5ldyBEZXAoKTtcbiAgICBjb25zdCB7IGdldCwgc2V0IH0gPSBmYWN0b3J5KCgpID0+IHtcbiAgICAgICAge1xuICAgICAgICAgICAgZGVwLmRlcGVuZCh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiByZWYsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLFxuICAgICAgICAgICAgICAgIGtleTogJ3ZhbHVlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCAoKSA9PiB7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlcC5ub3RpZnkoe1xuICAgICAgICAgICAgICAgIHRhcmdldDogcmVmLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIgLyogVHJpZ2dlck9wVHlwZXMuU0VUICovLFxuICAgICAgICAgICAgICAgIGtleTogJ3ZhbHVlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCByZWYgPSB7XG4gICAgICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgICAgICAgICAgc2V0KG5ld1ZhbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRlZihyZWYsIFJlZkZsYWcsIHRydWUpO1xuICAgIHJldHVybiByZWY7XG59XG5mdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XG4gICAgaWYgKCFpc1JlYWN0aXZlKG9iamVjdCkpIHtcbiAgICAgICAgd2FybihgdG9SZWZzKCkgZXhwZWN0cyBhIHJlYWN0aXZlIG9iamVjdCBidXQgcmVjZWl2ZWQgYSBwbGFpbiBvbmUuYCk7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IGlzQXJyYXkob2JqZWN0KSA/IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKSA6IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICByZXRba2V5XSA9IHRvUmVmKG9iamVjdCwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHRvUmVmKG9iamVjdCwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBjb25zdCB2YWwgPSBvYmplY3Rba2V5XTtcbiAgICBpZiAoaXNSZWYodmFsKSkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBjb25zdCByZWYgPSB7XG4gICAgICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogdmFsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IG5ld1ZhbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZGVmKHJlZiwgUmVmRmxhZywgdHJ1ZSk7XG4gICAgcmV0dXJuIHJlZjtcbn1cblxuY29uc3QgcmF3VG9SZWFkb25seUZsYWcgPSBgX192X3Jhd1RvUmVhZG9ubHlgO1xuY29uc3QgcmF3VG9TaGFsbG93UmVhZG9ubHlGbGFnID0gYF9fdl9yYXdUb1NoYWxsb3dSZWFkb25seWA7XG5mdW5jdGlvbiByZWFkb25seSh0YXJnZXQpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVhZG9ubHkodGFyZ2V0LCBmYWxzZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFkb25seSh0YXJnZXQsIHNoYWxsb3cpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodGFyZ2V0KSkge1xuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgd2FybihgVnVlIDIgZG9lcyBub3Qgc3VwcG9ydCByZWFkb25seSBhcnJheXMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0NvbGxlY3Rpb25UeXBlKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBWdWUgMiBkb2VzIG5vdCBzdXBwb3J0IHJlYWRvbmx5IGNvbGxlY3Rpb24gdHlwZXMgc3VjaCBhcyBNYXAgb3IgU2V0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2FybihgdmFsdWUgY2Fubm90IGJlIG1hZGUgcmVhZG9ubHk6ICR7dHlwZW9mIHRhcmdldH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBpZiAoIU9iamVjdC5pc0V4dGVuc2libGUodGFyZ2V0KSkge1xuICAgICAgICB3YXJuKGBWdWUgMiBkb2VzIG5vdCBzdXBwb3J0IGNyZWF0aW5nIHJlYWRvbmx5IHByb3h5IGZvciBub24tZXh0ZW5zaWJsZSBvYmplY3QuYCk7XG4gICAgfVxuICAgIC8vIGFscmVhZHkgYSByZWFkb25seSBvYmplY3RcbiAgICBpZiAoaXNSZWFkb25seSh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIC8vIGFscmVhZHkgaGFzIGEgcmVhZG9ubHkgcHJveHlcbiAgICBjb25zdCBleGlzdGluZ0ZsYWcgPSBzaGFsbG93ID8gcmF3VG9TaGFsbG93UmVhZG9ubHlGbGFnIDogcmF3VG9SZWFkb25seUZsYWc7XG4gICAgY29uc3QgZXhpc3RpbmdQcm94eSA9IHRhcmdldFtleGlzdGluZ0ZsYWddO1xuICAgIGlmIChleGlzdGluZ1Byb3h5KSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xuICAgIH1cbiAgICBjb25zdCBwcm94eSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCkpO1xuICAgIGRlZih0YXJnZXQsIGV4aXN0aW5nRmxhZywgcHJveHkpO1xuICAgIGRlZihwcm94eSwgXCJfX3ZfaXNSZWFkb25seVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBRE9OTFkgKi8sIHRydWUpO1xuICAgIGRlZihwcm94eSwgXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi8sIHRhcmdldCk7XG4gICAgaWYgKGlzUmVmKHRhcmdldCkpIHtcbiAgICAgICAgZGVmKHByb3h5LCBSZWZGbGFnLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHNoYWxsb3cgfHwgaXNTaGFsbG93KHRhcmdldCkpIHtcbiAgICAgICAgZGVmKHByb3h5LCBcIl9fdl9pc1NoYWxsb3dcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1NIQUxMT1cgKi8sIHRydWUpO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGFyZ2V0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVmaW5lUmVhZG9ubHlQcm9wZXJ0eShwcm94eSwgdGFyZ2V0LCBrZXlzW2ldLCBzaGFsbG93KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3h5O1xufVxuZnVuY3Rpb24gZGVmaW5lUmVhZG9ubHlQcm9wZXJ0eShwcm94eSwgdGFyZ2V0LCBrZXksIHNoYWxsb3cpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJveHksIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IHRhcmdldFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3cgfHwgIWlzUGxhaW5PYmplY3QodmFsKSA/IHZhbCA6IHJlYWRvbmx5KHZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCgpIHtcbiAgICAgICAgICAgIHdhcm4oYFNldCBvcGVyYXRpb24gb24ga2V5IFwiJHtrZXl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHJlYWN0aXZlLWNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdCwgd2hlcmUgb25seSB0aGUgcm9vdCBsZXZlbFxuICogcHJvcGVydGllcyBhcmUgcmVhZG9ubHksIGFuZCBkb2VzIE5PVCB1bndyYXAgcmVmcyBub3IgcmVjdXJzaXZlbHkgY29udmVydFxuICogcmV0dXJuZWQgcHJvcGVydGllcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgY3JlYXRpbmcgdGhlIHByb3BzIHByb3h5IG9iamVjdCBmb3Igc3RhdGVmdWwgY29tcG9uZW50cy5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd1JlYWRvbmx5KHRhcmdldCkge1xuICAgIHJldHVybiBjcmVhdGVSZWFkb25seSh0YXJnZXQsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlZChnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucykge1xuICAgIGxldCBnZXR0ZXI7XG4gICAgbGV0IHNldHRlcjtcbiAgICBjb25zdCBvbmx5R2V0dGVyID0gaXNGdW5jdGlvbihnZXR0ZXJPck9wdGlvbnMpO1xuICAgIGlmIChvbmx5R2V0dGVyKSB7XG4gICAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucztcbiAgICAgICAgc2V0dGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHdhcm4oJ1dyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHZhbHVlIGlzIHJlYWRvbmx5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuZ2V0O1xuICAgICAgICBzZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuc2V0O1xuICAgIH1cbiAgICBjb25zdCB3YXRjaGVyID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKVxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBuZXcgV2F0Y2hlcihjdXJyZW50SW5zdGFuY2UsIGdldHRlciwgbm9vcCwgeyBsYXp5OiB0cnVlIH0pO1xuICAgIGlmICh3YXRjaGVyICYmIGRlYnVnT3B0aW9ucykge1xuICAgICAgICB3YXRjaGVyLm9uVHJhY2sgPSBkZWJ1Z09wdGlvbnMub25UcmFjaztcbiAgICAgICAgd2F0Y2hlci5vblRyaWdnZXIgPSBkZWJ1Z09wdGlvbnMub25UcmlnZ2VyO1xuICAgIH1cbiAgICBjb25zdCByZWYgPSB7XG4gICAgICAgIC8vIHNvbWUgbGlicyByZWx5IG9uIHRoZSBwcmVzZW5jZSBlZmZlY3QgZm9yIGNoZWNraW5nIGNvbXB1dGVkIHJlZnNcbiAgICAgICAgLy8gZnJvbSBub3JtYWwgcmVmcywgYnV0IHRoZSBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IG1hdHRlclxuICAgICAgICBlZmZlY3Q6IHdhdGNoZXIsXG4gICAgICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoRGVwLnRhcmdldC5vblRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBEZXAudGFyZ2V0Lm9uVHJhY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdDogRGVwLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImdldFwiIC8qIFRyYWNrT3BUeXBlcy5HRVQgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAndmFsdWUnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXR0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgICAgICAgICAgc2V0dGVyKG5ld1ZhbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRlZihyZWYsIFJlZkZsYWcsIHRydWUpO1xuICAgIGRlZihyZWYsIFwiX192X2lzUmVhZG9ubHlcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1JFQURPTkxZICovLCBvbmx5R2V0dGVyKTtcbiAgICByZXR1cm4gcmVmO1xufVxuXG5jb25zdCBXQVRDSEVSID0gYHdhdGNoZXJgO1xuY29uc3QgV0FUQ0hFUl9DQiA9IGAke1dBVENIRVJ9IGNhbGxiYWNrYDtcbmNvbnN0IFdBVENIRVJfR0VUVEVSID0gYCR7V0FUQ0hFUn0gZ2V0dGVyYDtcbmNvbnN0IFdBVENIRVJfQ0xFQU5VUCA9IGAke1dBVENIRVJ9IGNsZWFudXBgO1xuLy8gU2ltcGxlIGVmZmVjdC5cbmZ1bmN0aW9uIHdhdGNoRWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB3YXRjaFBvc3RFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmbHVzaDogJ3Bvc3QnIH0pICkpO1xufVxuZnVuY3Rpb24gd2F0Y2hTeW5jRWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgZmx1c2g6ICdzeW5jJyB9KSApKTtcbn1cbi8vIGluaXRpYWwgdmFsdWUgZm9yIHdhdGNoZXJzIHRvIHRyaWdnZXIgb24gdW5kZWZpbmVkIGluaXRpYWwgdmFsdWVzXG5jb25zdCBJTklUSUFMX1dBVENIRVJfVkFMVUUgPSB7fTtcbi8vIGltcGxlbWVudGF0aW9uXG5mdW5jdGlvbiB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuKGBcXGB3YXRjaChmbiwgb3B0aW9ucz8pXFxgIHNpZ25hdHVyZSBoYXMgYmVlbiBtb3ZlZCB0byBhIHNlcGFyYXRlIEFQSS4gYCArXG4gICAgICAgICAgICBgVXNlIFxcYHdhdGNoRWZmZWN0KGZuLCBvcHRpb25zPylcXGAgaW5zdGVhZC4gXFxgd2F0Y2hcXGAgbm93IG9ubHkgYCArXG4gICAgICAgICAgICBgc3VwcG9ydHMgXFxgd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucz8pIHNpZ25hdHVyZS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvV2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBkb1dhdGNoKHNvdXJjZSwgY2IsIHsgaW1tZWRpYXRlLCBkZWVwLCBmbHVzaCA9ICdwcmUnLCBvblRyYWNrLCBvblRyaWdnZXIgfSA9IGVtcHR5T2JqZWN0KSB7XG4gICAgaWYgKCFjYikge1xuICAgICAgICBpZiAoaW1tZWRpYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdhcm4oYHdhdGNoKCkgXCJpbW1lZGlhdGVcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgYCArXG4gICAgICAgICAgICAgICAgYHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2Fybihgd2F0Y2goKSBcImRlZXBcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgYCArXG4gICAgICAgICAgICAgICAgYHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgd2FybkludmFsaWRTb3VyY2UgPSAocykgPT4ge1xuICAgICAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIHNvdXJjZTogJHtzfS4gQSB3YXRjaCBzb3VyY2UgY2FuIG9ubHkgYmUgYSBnZXR0ZXIvZWZmZWN0IGAgK1xuICAgICAgICAgICAgYGZ1bmN0aW9uLCBhIHJlZiwgYSByZWFjdGl2ZSBvYmplY3QsIG9yIGFuIGFycmF5IG9mIHRoZXNlIHR5cGVzLmApO1xuICAgIH07XG4gICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgY29uc3QgY2FsbCA9IChmbiwgdHlwZSwgYXJncyA9IG51bGwpID0+IGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGZuLCBudWxsLCBhcmdzLCBpbnN0YW5jZSwgdHlwZSk7XG4gICAgbGV0IGdldHRlcjtcbiAgICBsZXQgZm9yY2VUcmlnZ2VyID0gZmFsc2U7XG4gICAgbGV0IGlzTXVsdGlTb3VyY2UgPSBmYWxzZTtcbiAgICBpZiAoaXNSZWYoc291cmNlKSkge1xuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UudmFsdWU7XG4gICAgICAgIGZvcmNlVHJpZ2dlciA9IGlzU2hhbGxvdyhzb3VyY2UpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1JlYWN0aXZlKHNvdXJjZSkpIHtcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgc291cmNlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9O1xuICAgICAgICBkZWVwID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIGlzTXVsdGlTb3VyY2UgPSB0cnVlO1xuICAgICAgICBmb3JjZVRyaWdnZXIgPSBzb3VyY2Uuc29tZShzID0+IGlzUmVhY3RpdmUocykgfHwgaXNTaGFsbG93KHMpKTtcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLm1hcChzID0+IHtcbiAgICAgICAgICAgIGlmIChpc1JlZihzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWFjdGl2ZShzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzZShzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbChzLCBXQVRDSEVSX0dFVFRFUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3YXJuSW52YWxpZFNvdXJjZShzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIC8vIGdldHRlciB3aXRoIGNiXG4gICAgICAgICAgICBnZXR0ZXIgPSAoKSA9PiBjYWxsKHNvdXJjZSwgV0FUQ0hFUl9HRVRURVIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gY2IgLT4gc2ltcGxlIGVmZmVjdFxuICAgICAgICAgICAgZ2V0dGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2xlYW51cCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsKHNvdXJjZSwgV0FUQ0hFUiwgW29uQ2xlYW51cF0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2V0dGVyID0gbm9vcDtcbiAgICAgICAgd2FybkludmFsaWRTb3VyY2Uoc291cmNlKTtcbiAgICB9XG4gICAgaWYgKGNiICYmIGRlZXApIHtcbiAgICAgICAgY29uc3QgYmFzZUdldHRlciA9IGdldHRlcjtcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gdHJhdmVyc2UoYmFzZUdldHRlcigpKTtcbiAgICB9XG4gICAgbGV0IGNsZWFudXA7XG4gICAgbGV0IG9uQ2xlYW51cCA9IChmbikgPT4ge1xuICAgICAgICBjbGVhbnVwID0gd2F0Y2hlci5vblN0b3AgPSAoKSA9PiB7XG4gICAgICAgICAgICBjYWxsKGZuLCBXQVRDSEVSX0NMRUFOVVApO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLy8gaW4gU1NSIHRoZXJlIGlzIG5vIG5lZWQgdG8gc2V0dXAgYW4gYWN0dWFsIGVmZmVjdCwgYW5kIGl0IHNob3VsZCBiZSBub29wXG4gICAgLy8gdW5sZXNzIGl0J3MgZWFnZXJcbiAgICBpZiAoaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICAvLyB3ZSB3aWxsIGFsc28gbm90IGNhbGwgdGhlIGludmFsaWRhdGUgY2FsbGJhY2sgKCsgcnVubmVyIGlzIG5vdCBzZXQgdXApXG4gICAgICAgIG9uQ2xlYW51cCA9IG5vb3A7XG4gICAgICAgIGlmICghY2IpIHtcbiAgICAgICAgICAgIGdldHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgICAgICAgY2FsbChjYiwgV0FUQ0hFUl9DQiwgW1xuICAgICAgICAgICAgICAgIGdldHRlcigpLFxuICAgICAgICAgICAgICAgIGlzTXVsdGlTb3VyY2UgPyBbXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBvbkNsZWFudXBcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBjb25zdCB3YXRjaGVyID0gbmV3IFdhdGNoZXIoY3VycmVudEluc3RhbmNlLCBnZXR0ZXIsIG5vb3AsIHtcbiAgICAgICAgbGF6eTogdHJ1ZVxuICAgIH0pO1xuICAgIHdhdGNoZXIubm9SZWN1cnNlID0gIWNiO1xuICAgIGxldCBvbGRWYWx1ZSA9IGlzTXVsdGlTb3VyY2UgPyBbXSA6IElOSVRJQUxfV0FUQ0hFUl9WQUxVRTtcbiAgICAvLyBvdmVyd3JpdGUgZGVmYXVsdCBydW5cbiAgICB3YXRjaGVyLnJ1biA9ICgpID0+IHtcbiAgICAgICAgaWYgKCF3YXRjaGVyLmFjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgLy8gd2F0Y2goc291cmNlLCBjYilcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gd2F0Y2hlci5nZXQoKTtcbiAgICAgICAgICAgIGlmIChkZWVwIHx8XG4gICAgICAgICAgICAgICAgZm9yY2VUcmlnZ2VyIHx8XG4gICAgICAgICAgICAgICAgKGlzTXVsdGlTb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgPyBuZXdWYWx1ZS5zb21lKCh2LCBpKSA9PiBoYXNDaGFuZ2VkKHYsIG9sZFZhbHVlW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgOiBoYXNDaGFuZ2VkKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gY2xlYW51cCBiZWZvcmUgcnVubmluZyBjYiBhZ2FpblxuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbChjYiwgV0FUQ0hFUl9DQiwgW1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFzcyB1bmRlZmluZWQgYXMgdGhlIG9sZCB2YWx1ZSB3aGVuIGl0J3MgY2hhbmdlZCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IHVuZGVmaW5lZCA6IG9sZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBvbkNsZWFudXBcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gd2F0Y2hFZmZlY3RcbiAgICAgICAgICAgIHdhdGNoZXIuZ2V0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmIChmbHVzaCA9PT0gJ3N5bmMnKSB7XG4gICAgICAgIHdhdGNoZXIudXBkYXRlID0gd2F0Y2hlci5ydW47XG4gICAgfVxuICAgIGVsc2UgaWYgKGZsdXNoID09PSAncG9zdCcpIHtcbiAgICAgICAgd2F0Y2hlci5wb3N0ID0gdHJ1ZTtcbiAgICAgICAgd2F0Y2hlci51cGRhdGUgPSAoKSA9PiBxdWV1ZVdhdGNoZXIod2F0Y2hlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBwcmVcbiAgICAgICAgd2F0Y2hlci51cGRhdGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UgPT09IGN1cnJlbnRJbnN0YW5jZSAmJiAhaW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgICAgICAgICAgIC8vIHByZS13YXRjaGVyIHRyaWdnZXJlZCBiZWZvcmVcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBpbnN0YW5jZS5fcHJlV2F0Y2hlcnMgfHwgKGluc3RhbmNlLl9wcmVXYXRjaGVycyA9IFtdKTtcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLmluZGV4T2Yod2F0Y2hlcikgPCAwKVxuICAgICAgICAgICAgICAgICAgICBidWZmZXIucHVzaCh3YXRjaGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXVlV2F0Y2hlcih3YXRjaGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAge1xuICAgICAgICB3YXRjaGVyLm9uVHJhY2sgPSBvblRyYWNrO1xuICAgICAgICB3YXRjaGVyLm9uVHJpZ2dlciA9IG9uVHJpZ2dlcjtcbiAgICB9XG4gICAgLy8gaW5pdGlhbCBydW5cbiAgICBpZiAoY2IpIHtcbiAgICAgICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgICAgICAgd2F0Y2hlci5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9sZFZhbHVlID0gd2F0Y2hlci5nZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChmbHVzaCA9PT0gJ3Bvc3QnICYmIGluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlLiRvbmNlKCdob29rOm1vdW50ZWQnLCAoKSA9PiB3YXRjaGVyLmdldCgpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdhdGNoZXIuZ2V0KCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9O1xufVxuXG5sZXQgYWN0aXZlRWZmZWN0U2NvcGU7XG5jbGFzcyBFZmZlY3RTY29wZSB7XG4gICAgY29uc3RydWN0b3IoZGV0YWNoZWQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmRldGFjaGVkID0gZGV0YWNoZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lZmZlY3RzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xlYW51cHMgPSBbXTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBhY3RpdmVFZmZlY3RTY29wZTtcbiAgICAgICAgaWYgKCFkZXRhY2hlZCAmJiBhY3RpdmVFZmZlY3RTY29wZSkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9XG4gICAgICAgICAgICAgICAgKGFjdGl2ZUVmZmVjdFNjb3BlLnNjb3BlcyB8fCAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzID0gW10pKS5wdXNoKHRoaXMpIC0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBydW4oZm4pIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RWZmZWN0U2NvcGUgPSBhY3RpdmVFZmZlY3RTY29wZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSBjdXJyZW50RWZmZWN0U2NvcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3YXJuKGBjYW5ub3QgcnVuIGFuIGluYWN0aXZlIGVmZmVjdCBzY29wZS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgb24oKSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG9mZigpIHtcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzLnBhcmVudDtcbiAgICB9XG4gICAgc3RvcChmcm9tUGFyZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgbGV0IGksIGw7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZWZmZWN0c1tpXS50ZWFyZG93bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2xlYW51cHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwc1tpXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2NvcGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjb3Blc1tpXS5zdG9wKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5lc3RlZCBzY29wZSwgZGVyZWZlcmVuY2UgZnJvbSBwYXJlbnQgdG8gYXZvaWQgbWVtb3J5IGxlYWtzXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGV0YWNoZWQgJiYgdGhpcy5wYXJlbnQgJiYgIWZyb21QYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBvcHRpbWl6ZWQgTygxKSByZW1vdmFsXG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IHRoaXMucGFyZW50LnNjb3Blcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnNjb3Blc1t0aGlzLmluZGV4XSA9IGxhc3Q7XG4gICAgICAgICAgICAgICAgICAgIGxhc3QuaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGVmZmVjdFNjb3BlKGRldGFjaGVkKSB7XG4gICAgcmV0dXJuIG5ldyBFZmZlY3RTY29wZShkZXRhY2hlZCk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiByZWNvcmRFZmZlY3RTY29wZShlZmZlY3QsIHNjb3BlID0gYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgICBpZiAoc2NvcGUgJiYgc2NvcGUuYWN0aXZlKSB7XG4gICAgICAgIHNjb3BlLmVmZmVjdHMucHVzaChlZmZlY3QpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRTY29wZSgpIHtcbiAgICByZXR1cm4gYWN0aXZlRWZmZWN0U2NvcGU7XG59XG5mdW5jdGlvbiBvblNjb3BlRGlzcG9zZShmbikge1xuICAgIGlmIChhY3RpdmVFZmZlY3RTY29wZSkge1xuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZS5jbGVhbnVwcy5wdXNoKGZuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdhcm4oYG9uU2NvcGVEaXNwb3NlKCkgaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGVmZmVjdCBzY29wZWAgK1xuICAgICAgICAgICAgYCB0byBiZSBhc3NvY2lhdGVkIHdpdGguYCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwcm92aWRlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xuICAgICAgICB7XG4gICAgICAgICAgICB3YXJuKGBwcm92aWRlKCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gVFMgZG9lc24ndCBhbGxvdyBzeW1ib2wgYXMgaW5kZXggdHlwZVxuICAgICAgICByZXNvbHZlUHJvdmlkZWQoY3VycmVudEluc3RhbmNlKVtrZXldID0gdmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZVByb3ZpZGVkKHZtKSB7XG4gICAgLy8gYnkgZGVmYXVsdCBhbiBpbnN0YW5jZSBpbmhlcml0cyBpdHMgcGFyZW50J3MgcHJvdmlkZXMgb2JqZWN0XG4gICAgLy8gYnV0IHdoZW4gaXQgbmVlZHMgdG8gcHJvdmlkZSB2YWx1ZXMgb2YgaXRzIG93biwgaXQgY3JlYXRlcyBpdHNcbiAgICAvLyBvd24gcHJvdmlkZXMgb2JqZWN0IHVzaW5nIHBhcmVudCBwcm92aWRlcyBvYmplY3QgYXMgcHJvdG90eXBlLlxuICAgIC8vIHRoaXMgd2F5IGluIGBpbmplY3RgIHdlIGNhbiBzaW1wbHkgbG9vayB1cCBpbmplY3Rpb25zIGZyb20gZGlyZWN0XG4gICAgLy8gcGFyZW50IGFuZCBsZXQgdGhlIHByb3RvdHlwZSBjaGFpbiBkbyB0aGUgd29yay5cbiAgICBjb25zdCBleGlzdGluZyA9IHZtLl9wcm92aWRlZDtcbiAgICBjb25zdCBwYXJlbnRQcm92aWRlcyA9IHZtLiRwYXJlbnQgJiYgdm0uJHBhcmVudC5fcHJvdmlkZWQ7XG4gICAgaWYgKHBhcmVudFByb3ZpZGVzID09PSBleGlzdGluZykge1xuICAgICAgICByZXR1cm4gKHZtLl9wcm92aWRlZCA9IE9iamVjdC5jcmVhdGUocGFyZW50UHJvdmlkZXMpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG59XG5mdW5jdGlvbiBpbmplY3Qoa2V5LCBkZWZhdWx0VmFsdWUsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSA9IGZhbHNlKSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gYGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZWAgc28gdGhhdCB0aGlzIGNhbiBiZSBjYWxsZWQgaW5cbiAgICAvLyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIC8vICMyNDAwXG4gICAgICAgIC8vIHRvIHN1cHBvcnQgYGFwcC51c2VgIHBsdWdpbnMsXG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIGFwcENvbnRleHQncyBgcHJvdmlkZXNgIGlmIHRoZSBpbnN0YW5jZSBpcyBhdCByb290XG4gICAgICAgIGNvbnN0IHByb3ZpZGVzID0gaW5zdGFuY2UuJHBhcmVudCAmJiBpbnN0YW5jZS4kcGFyZW50Ll9wcm92aWRlZDtcbiAgICAgICAgaWYgKHByb3ZpZGVzICYmIGtleSBpbiBwcm92aWRlcykge1xuICAgICAgICAgICAgLy8gVFMgZG9lc24ndCBhbGxvdyBzeW1ib2wgYXMgaW5kZXggdHlwZVxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpXG4gICAgICAgICAgICAgICAgPyBkZWZhdWx0VmFsdWUuY2FsbChpbnN0YW5jZSlcbiAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdhcm4oYGluamVjdGlvbiBcIiR7U3RyaW5nKGtleSl9XCIgbm90IGZvdW5kLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3YXJuKGBpbmplY3QoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50cy5gKTtcbiAgICB9XG59XG5cbmNvbnN0IG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKChuYW1lKSA9PiB7XG4gICAgY29uc3QgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gICAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgICBjb25zdCBvbmNlID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICAgIG5hbWUgPSBvbmNlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gICAgY29uc3QgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gICAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBvbmNlLFxuICAgICAgICBjYXB0dXJlLFxuICAgICAgICBwYXNzaXZlXG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyKGZucywgdm0pIHtcbiAgICBmdW5jdGlvbiBpbnZva2VyKCkge1xuICAgICAgICBjb25zdCBmbnMgPSBpbnZva2VyLmZucztcbiAgICAgICAgaWYgKGlzQXJyYXkoZm5zKSkge1xuICAgICAgICAgICAgY29uc3QgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNsb25lZFtpXSwgbnVsbCwgYXJndW1lbnRzLCB2bSwgYHYtb24gaGFuZGxlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgICAgICAgIHJldHVybiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhmbnMsIG51bGwsIGFyZ3VtZW50cywgdm0sIGB2LW9uIGhhbmRsZXJgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnZva2VyLmZucyA9IGZucztcbiAgICByZXR1cm4gaW52b2tlcjtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCwgcmVtb3ZlLCBjcmVhdGVPbmNlSGFuZGxlciwgdm0pIHtcbiAgICBsZXQgbmFtZSwgY3VyLCBvbGQsIGV2ZW50O1xuICAgIGZvciAobmFtZSBpbiBvbikge1xuICAgICAgICBjdXIgPSBvbltuYW1lXTtcbiAgICAgICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXCIke2V2ZW50Lm5hbWV9XCI6IGdvdCBgICsgU3RyaW5nKGN1ciksIHZtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgICAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyLCB2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNUcnVlKGV2ZW50Lm9uY2UpKSB7XG4gICAgICAgICAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVPbmNlSGFuZGxlcihldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgICAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgICAgICBpZiAoaXNVbmRlZihvbltuYW1lXSkpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICAgICAgICByZW1vdmUoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayhkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgICBpZiAoZGVmIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICAgICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgICB9XG4gICAgbGV0IGludm9rZXI7XG4gICAgY29uc3Qgb2xkSG9vayA9IGRlZltob29rS2V5XTtcbiAgICBmdW5jdGlvbiB3cmFwcGVkSG9vaygpIHtcbiAgICAgICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgICAgIHJlbW92ZSQyKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcbiAgICAgICAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICAgICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgICAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICAgIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKSB7XG4gICAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gICAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gICAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgICBjb25zdCBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBjb25zdCB7IGF0dHJzLCBwcm9wcyB9ID0gZGF0YTtcbiAgICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJiBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aXAoYFByb3AgXCIke2tleUluTG93ZXJDYXNlfVwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtmb3JtYXRDb21wb25lbnROYW1lKFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0YWcgaXMgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWcgfHwgQ3Rvcil9LCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc2AgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCBcIiR7a2V5fVwiLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYHByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgdGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcIiR7YWx0S2V5fVwiIGluc3RlYWQgb2YgXCIke2tleX1cIi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICAgICAgICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNoZWNrUHJvcChyZXMsIGhhc2gsIGtleSwgYWx0S2V5LCBwcmVzZXJ2ZSkge1xuICAgIGlmIChpc0RlZihoYXNoKSkge1xuICAgICAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgICAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICAgICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG59XG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgICAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgICAgICA6IGlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICAgICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzVGV4dE5vZGUobm9kZSkge1xuICAgIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBsZXQgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjID0gY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChpc1VuZGVmKGMpIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGFzdEluZGV4ID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGxhc3QgPSByZXNbbGFzdEluZGV4XTtcbiAgICAgICAgLy8gIG5lc3RlZFxuICAgICAgICBpZiAoaXNBcnJheShjKSkge1xuICAgICAgICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsIGAke25lc3RlZEluZGV4IHx8ICcnfV8ke2l9YCk7XG4gICAgICAgICAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAgICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgY1swXS50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXMucHVzaC5hcHBseShyZXMsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICAgICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgICAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgICAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgICAgICAgICAgaWYgKGlzVHJ1ZShjaGlsZHJlbi5faXNWTGlzdCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzRGVmKG5lc3RlZEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBjLmtleSA9IGBfX3ZsaXN0JHtuZXN0ZWRJbmRleH1fJHtpfV9fYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0KHZhbCwgcmVuZGVyKSB7XG4gICAgbGV0IHJldCA9IG51bGwsIGksIGwsIGtleXMsIGtleTtcbiAgICBpZiAoaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgICBpZiAoaGFzU3ltYm9sICYmIHZhbFtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdmFsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2gocmVuZGVyKHJlc3VsdC52YWx1ZSwgcmV0Lmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaXNEZWYocmV0KSkge1xuICAgICAgICByZXQgPSBbXTtcbiAgICB9XG4gICAgcmV0Ll9pc1ZMaXN0ID0gdHJ1ZTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QobmFtZSwgZmFsbGJhY2tSZW5kZXIsIHByb3BzLCBiaW5kT2JqZWN0KSB7XG4gICAgY29uc3Qgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gICAgbGV0IG5vZGVzO1xuICAgIGlmIChzY29wZWRTbG90Rm4pIHtcbiAgICAgICAgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICAgICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmICghaXNPYmplY3QoYmluZE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdzbG90IHYtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0JywgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZXMgPVxuICAgICAgICAgICAgc2NvcGVkU2xvdEZuKHByb3BzKSB8fFxuICAgICAgICAgICAgICAgIChpc0Z1bmN0aW9uKGZhbGxiYWNrUmVuZGVyKSA/IGZhbGxiYWNrUmVuZGVyKCkgOiBmYWxsYmFja1JlbmRlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub2RlcyA9XG4gICAgICAgICAgICB0aGlzLiRzbG90c1tuYW1lXSB8fFxuICAgICAgICAgICAgICAgIChpc0Z1bmN0aW9uKGZhbGxiYWNrUmVuZGVyKSA/IGZhbGxiYWNrUmVuZGVyKCkgOiBmYWxsYmFja1JlbmRlcik7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2Rlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyKGlkKSB7XG4gICAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eTtcbn1cblxuZnVuY3Rpb24gaXNLZXlOb3RNYXRjaChleHBlY3QsIGFjdHVhbCkge1xuICAgIGlmIChpc0FycmF5KGV4cGVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsO1xuICAgIH1cbn1cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXG4gKiBwYXNzaW5nIGluIGV2ZW50S2V5TmFtZSBhcyBsYXN0IGFyZ3VtZW50IHNlcGFyYXRlbHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyhldmVudEtleUNvZGUsIGtleSwgYnVpbHRJbktleUNvZGUsIGV2ZW50S2V5TmFtZSwgYnVpbHRJbktleU5hbWUpIHtcbiAgICBjb25zdCBtYXBwZWRLZXlDb2RlID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbktleUNvZGU7XG4gICAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2goYnVpbHRJbktleU5hbWUsIGV2ZW50S2V5TmFtZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICAgICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2gobWFwcGVkS2V5Q29kZSwgZXZlbnRLZXlDb2RlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5O1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRLZXlDb2RlID09PSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzKGRhdGEsIHRhZywgdmFsdWUsIGFzUHJvcCwgaXNTeW5jKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICB3YXJuKCd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaGFzaDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJyB8fCBrZXkgPT09ICdzdHlsZScgfHwgaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgICAgICAgICAgICBoYXNoID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoIShjYW1lbGl6ZWRLZXkgaW4gaGFzaCkgJiYgIShoeXBoZW5hdGVkS2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uW2B1cGRhdGU6JHtrZXl9YF0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyhpbmRleCwgaXNJbkZvcikge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcbiAgICBsZXQgdHJlZSA9IGNhY2hlZFtpbmRleF07XG4gICAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gICAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUuXG4gICAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxuICAgIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKHRoaXMuX3JlbmRlclByb3h5LCB0aGlzLl9jLCB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXG4gICAgKTtcbiAgICBtYXJrU3RhdGljKHRyZWUsIGBfX3N0YXRpY19fJHtpbmRleH1gLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRyZWU7XG59XG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAqL1xuZnVuY3Rpb24gbWFya09uY2UodHJlZSwgaW5kZXgsIGtleSkge1xuICAgIG1hcmtTdGF0aWModHJlZSwgYF9fb25jZV9fJHtpbmRleH0ke2tleSA/IGBfJHtrZXl9YCA6IGBgfWAsIHRydWUpO1xuICAgIHJldHVybiB0cmVlO1xufVxuZnVuY3Rpb24gbWFya1N0YXRpYyh0cmVlLCBrZXksIGlzT25jZSkge1xuICAgIGlmIChpc0FycmF5KHRyZWUpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgYCR7a2V5fV8ke2l9YCwgaXNPbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gICAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gICAgbm9kZS5rZXkgPSBrZXk7XG4gICAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbmZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMoZGF0YSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgd2Fybigndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJywgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvbiA9IChkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXJzID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIG91cnMpIDogb3VycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzKGZucywgcmVzLCBcbi8vIHRoZSBmb2xsb3dpbmcgYXJlIGFkZGVkIGluIDIuNlxuaGFzRHluYW1pY0tleXMsIGNvbnRlbnRIYXNoS2V5KSB7XG4gICAgcmVzID0gcmVzIHx8IHsgJHN0YWJsZTogIWhhc0R5bmFtaWNLZXlzIH07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2xvdCA9IGZuc1tpXTtcbiAgICAgICAgaWYgKGlzQXJyYXkoc2xvdCkpIHtcbiAgICAgICAgICAgIHJlc29sdmVTY29wZWRTbG90cyhzbG90LCByZXMsIGhhc0R5bmFtaWNLZXlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzbG90KSB7XG4gICAgICAgICAgICAvLyBtYXJrZXIgZm9yIHJldmVyc2UgcHJveHlpbmcgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGlmIChzbG90LnByb3h5KSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHNsb3QuZm4ucHJveHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzW3Nsb3Qua2V5XSA9IHNsb3QuZm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRlbnRIYXNoS2V5KSB7XG4gICAgICAgIHJlcy4ka2V5ID0gY29udGVudEhhc2hLZXk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIGhlbHBlciB0byBwcm9jZXNzIGR5bmFtaWMga2V5cyBmb3IgZHluYW1pYyBhcmd1bWVudHMgaW4gdi1iaW5kIGFuZCB2LW9uLlxuZnVuY3Rpb24gYmluZER5bmFtaWNLZXlzKGJhc2VPYmosIHZhbHVlcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHZhbHVlc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleSkge1xuICAgICAgICAgICAgYmFzZU9ialt2YWx1ZXNbaV1dID0gdmFsdWVzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgIT09ICcnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbnVsbCBpcyBhIHNwZWNpYWwgdmFsdWUgZm9yIGV4cGxpY2l0bHkgcmVtb3ZpbmcgYSBiaW5kaW5nXG4gICAgICAgICAgICB3YXJuKGBJbnZhbGlkIHZhbHVlIGZvciBkeW5hbWljIGRpcmVjdGl2ZSBhcmd1bWVudCAoZXhwZWN0ZWQgc3RyaW5nIG9yIG51bGwpOiAke2tleX1gLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmFzZU9iajtcbn1cbi8vIGhlbHBlciB0byBkeW5hbWljYWxseSBhcHBlbmQgbW9kaWZpZXIgcnVudGltZSBtYXJrZXJzIHRvIGV2ZW50IG5hbWVzLlxuLy8gZW5zdXJlIG9ubHkgYXBwZW5kIHdoZW4gdmFsdWUgaXMgYWxyZWFkeSBzdHJpbmcsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGNhc3Rcbi8vIHRvIHN0cmluZyBhbmQgY2F1c2UgdGhlIHR5cGUgY2hlY2sgdG8gbWlzcy5cbmZ1bmN0aW9uIHByZXBlbmRNb2RpZmllcih2YWx1ZSwgc3ltYm9sKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBzeW1ib2wgKyB2YWx1ZSA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBpbnN0YWxsUmVuZGVySGVscGVycyh0YXJnZXQpIHtcbiAgICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgICB0YXJnZXQuX24gPSB0b051bWJlcjtcbiAgICB0YXJnZXQuX3MgPSB0b1N0cmluZztcbiAgICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICAgIHRhcmdldC5fdCA9IHJlbmRlclNsb3Q7XG4gICAgdGFyZ2V0Ll9xID0gbG9vc2VFcXVhbDtcbiAgICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gICAgdGFyZ2V0Ll9tID0gcmVuZGVyU3RhdGljO1xuICAgIHRhcmdldC5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gICAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgICB0YXJnZXQuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gICAgdGFyZ2V0Ll92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICAgIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgdGFyZ2V0Ll91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xuICAgIHRhcmdldC5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG4gICAgdGFyZ2V0Ll9kID0gYmluZER5bmFtaWNLZXlzO1xuICAgIHRhcmdldC5fcCA9IHByZXBlbmRNb2RpZmllcjtcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBzbG90cyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjaGlsZC5kYXRhO1xuICAgICAgICAvLyByZW1vdmUgc2xvdCBhdHRyaWJ1dGUgaWYgdGhlIG5vZGUgaXMgcmVzb2x2ZWQgYXMgYSBWdWUgc2xvdCBub2RlXG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICAgICAgICBkZWxldGUgZGF0YS5hdHRycy5zbG90O1xuICAgICAgICB9XG4gICAgICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgICAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICAgICAgICBkYXRhICYmXG4gICAgICAgICAgICBkYXRhLnNsb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgICAgICAgIGNvbnN0IHNsb3QgPSBzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSk7XG4gICAgICAgICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaWdub3JlIHNsb3RzIHRoYXQgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlXG4gICAgZm9yIChjb25zdCBuYW1lIGluIHNsb3RzKSB7XG4gICAgICAgIGlmIChzbG90c1tuYW1lXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICAgICAgICBkZWxldGUgc2xvdHNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNsb3RzO1xufVxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUuaXNDb21tZW50ICYmICFub2RlLmFzeW5jRmFjdG9yeSkgfHwgbm9kZS50ZXh0ID09PSAnICc7XG59XG5cbmZ1bmN0aW9uIGlzQXN5bmNQbGFjZWhvbGRlcihub2RlKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBub3QgcmVhbGx5IGJvb2xlYW4gdHlwZVxuICAgIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdHMob3duZXJWbSwgc2NvcGVkU2xvdHMsIG5vcm1hbFNsb3RzLCBwcmV2U2NvcGVkU2xvdHMpIHtcbiAgICBsZXQgcmVzO1xuICAgIGNvbnN0IGhhc05vcm1hbFNsb3RzID0gT2JqZWN0LmtleXMobm9ybWFsU2xvdHMpLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgaXNTdGFibGUgPSBzY29wZWRTbG90cyA/ICEhc2NvcGVkU2xvdHMuJHN0YWJsZSA6ICFoYXNOb3JtYWxTbG90cztcbiAgICBjb25zdCBrZXkgPSBzY29wZWRTbG90cyAmJiBzY29wZWRTbG90cy4ka2V5O1xuICAgIGlmICghc2NvcGVkU2xvdHMpIHtcbiAgICAgICAgcmVzID0ge307XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjb3BlZFNsb3RzLl9ub3JtYWxpemVkKSB7XG4gICAgICAgIC8vIGZhc3QgcGF0aCAxOiBjaGlsZCBjb21wb25lbnQgcmUtcmVuZGVyIG9ubHksIHBhcmVudCBkaWQgbm90IGNoYW5nZVxuICAgICAgICByZXR1cm4gc2NvcGVkU2xvdHMuX25vcm1hbGl6ZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU3RhYmxlICYmXG4gICAgICAgIHByZXZTY29wZWRTbG90cyAmJlxuICAgICAgICBwcmV2U2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmXG4gICAgICAgIGtleSA9PT0gcHJldlNjb3BlZFNsb3RzLiRrZXkgJiZcbiAgICAgICAgIWhhc05vcm1hbFNsb3RzICYmXG4gICAgICAgICFwcmV2U2NvcGVkU2xvdHMuJGhhc05vcm1hbCkge1xuICAgICAgICAvLyBmYXN0IHBhdGggMjogc3RhYmxlIHNjb3BlZCBzbG90cyB3LyBubyBub3JtYWwgc2xvdHMgdG8gcHJveHksXG4gICAgICAgIC8vIG9ubHkgbmVlZCB0byBub3JtYWxpemUgb25jZVxuICAgICAgICByZXR1cm4gcHJldlNjb3BlZFNsb3RzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjb3BlZFNsb3RzKSB7XG4gICAgICAgICAgICBpZiAoc2NvcGVkU2xvdHNba2V5XSAmJiBrZXlbMF0gIT09ICckJykge1xuICAgICAgICAgICAgICAgIHJlc1trZXldID0gbm9ybWFsaXplU2NvcGVkU2xvdChvd25lclZtLCBub3JtYWxTbG90cywga2V5LCBzY29wZWRTbG90c1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBleHBvc2Ugbm9ybWFsIHNsb3RzIG9uIHNjb3BlZFNsb3RzXG4gICAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsU2xvdHMpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHJlcykpIHtcbiAgICAgICAgICAgIHJlc1trZXldID0gcHJveHlOb3JtYWxTbG90KG5vcm1hbFNsb3RzLCBrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGF2b3JpYXogc2VlbXMgdG8gbW9jayBhIG5vbi1leHRlbnNpYmxlICRzY29wZWRTbG90cyBvYmplY3RcbiAgICAvLyBhbmQgd2hlbiB0aGF0IGlzIHBhc3NlZCBkb3duIHRoaXMgd291bGQgY2F1c2UgYW4gZXJyb3JcbiAgICBpZiAoc2NvcGVkU2xvdHMgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShzY29wZWRTbG90cykpIHtcbiAgICAgICAgc2NvcGVkU2xvdHMuX25vcm1hbGl6ZWQgPSByZXM7XG4gICAgfVxuICAgIGRlZihyZXMsICckc3RhYmxlJywgaXNTdGFibGUpO1xuICAgIGRlZihyZXMsICcka2V5Jywga2V5KTtcbiAgICBkZWYocmVzLCAnJGhhc05vcm1hbCcsIGhhc05vcm1hbFNsb3RzKTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdCh2bSwgbm9ybWFsU2xvdHMsIGtleSwgZm4pIHtcbiAgICBjb25zdCBub3JtYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBjdXIgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZSh2bSk7XG4gICAgICAgIGxldCByZXMgPSBhcmd1bWVudHMubGVuZ3RoID8gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKSA6IGZuKHt9KTtcbiAgICAgICAgcmVzID1cbiAgICAgICAgICAgIHJlcyAmJiB0eXBlb2YgcmVzID09PSAnb2JqZWN0JyAmJiAhaXNBcnJheShyZXMpXG4gICAgICAgICAgICAgICAgPyBbcmVzXSAvLyBzaW5nbGUgdm5vZGVcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZUNoaWxkcmVuKHJlcyk7XG4gICAgICAgIGNvbnN0IHZub2RlID0gcmVzICYmIHJlc1swXTtcbiAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGN1cik7XG4gICAgICAgIHJldHVybiByZXMgJiZcbiAgICAgICAgICAgICghdm5vZGUgfHxcbiAgICAgICAgICAgICAgICAocmVzLmxlbmd0aCA9PT0gMSAmJiB2bm9kZS5pc0NvbW1lbnQgJiYgIWlzQXN5bmNQbGFjZWhvbGRlcih2bm9kZSkpKSAvLyAjOTY1OCwgIzEwMzkxXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiByZXM7XG4gICAgfTtcbiAgICAvLyB0aGlzIGlzIGEgc2xvdCB1c2luZyB0aGUgbmV3IHYtc2xvdCBzeW50YXggd2l0aG91dCBzY29wZS4gYWx0aG91Z2ggaXQgaXNcbiAgICAvLyBjb21waWxlZCBhcyBhIHNjb3BlZCBzbG90LCByZW5kZXIgZm4gdXNlcnMgd291bGQgZXhwZWN0IGl0IHRvIGJlIHByZXNlbnRcbiAgICAvLyBvbiB0aGlzLiRzbG90cyBiZWNhdXNlIHRoZSB1c2FnZSBpcyBzZW1hbnRpY2FsbHkgYSBub3JtYWwgc2xvdC5cbiAgICBpZiAoZm4ucHJveHkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbFNsb3RzLCBrZXksIHtcbiAgICAgICAgICAgIGdldDogbm9ybWFsaXplZCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkO1xufVxuZnVuY3Rpb24gcHJveHlOb3JtYWxTbG90KHNsb3RzLCBrZXkpIHtcbiAgICByZXR1cm4gKCkgPT4gc2xvdHNba2V5XTtcbn1cblxuZnVuY3Rpb24gaW5pdFNldHVwKHZtKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgIGNvbnN0IHNldHVwID0gb3B0aW9ucy5zZXR1cDtcbiAgICBpZiAoc2V0dXApIHtcbiAgICAgICAgY29uc3QgY3R4ID0gKHZtLl9zZXR1cENvbnRleHQgPSBjcmVhdGVTZXR1cENvbnRleHQodm0pKTtcbiAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKHZtKTtcbiAgICAgICAgcHVzaFRhcmdldCgpO1xuICAgICAgICBjb25zdCBzZXR1cFJlc3VsdCA9IGludm9rZVdpdGhFcnJvckhhbmRsaW5nKHNldHVwLCBudWxsLCBbdm0uX3Byb3BzIHx8IHNoYWxsb3dSZWFjdGl2ZSh7fSksIGN0eF0sIHZtLCBgc2V0dXBgKTtcbiAgICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihzZXR1cFJlc3VsdCkpIHtcbiAgICAgICAgICAgIC8vIHJlbmRlciBmdW5jdGlvblxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgb3B0aW9ucy5yZW5kZXIgPSBzZXR1cFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09iamVjdChzZXR1cFJlc3VsdCkpIHtcbiAgICAgICAgICAgIC8vIGJpbmRpbmdzXG4gICAgICAgICAgICBpZiAoc2V0dXBSZXN1bHQgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgICAgICAgICAgICAgIHdhcm4oYHNldHVwKCkgc2hvdWxkIG5vdCByZXR1cm4gVk5vZGVzIGRpcmVjdGx5IC0gYCArXG4gICAgICAgICAgICAgICAgICAgIGByZXR1cm4gYSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZtLl9zZXR1cFN0YXRlID0gc2V0dXBSZXN1bHQ7XG4gICAgICAgICAgICAvLyBfX3NmYyBpbmRpY2F0ZXMgY29tcGlsZWQgYmluZGluZ3MgZnJvbSA8c2NyaXB0IHNldHVwPlxuICAgICAgICAgICAgaWYgKCFzZXR1cFJlc3VsdC5fX3NmYykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNldHVwUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm94eVdpdGhSZWZVbndyYXAodm0sIHNldHVwUmVzdWx0LCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgQXZvaWQgdXNpbmcgdmFyaWFibGVzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQgaW4gc2V0dXAoKS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGV4cG9zZWQgZm9yIGNvbXBpbGVkIHJlbmRlciBmblxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gKHZtLl9zZXR1cFByb3h5ID0ge30pO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNldHVwUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdfX3NmYycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5V2l0aFJlZlVud3JhcChwcm94eSwgc2V0dXBSZXN1bHQsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2V0dXBSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2Fybihgc2V0dXAoKSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC4gUmVjZWl2ZWQ6ICR7c2V0dXBSZXN1bHQgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2Ygc2V0dXBSZXN1bHR9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVTZXR1cENvbnRleHQodm0pIHtcbiAgICBsZXQgZXhwb3NlQ2FsbGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICAgICAgaWYgKCF2bS5fYXR0cnNQcm94eSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gKHZtLl9hdHRyc1Byb3h5ID0ge30pO1xuICAgICAgICAgICAgICAgIGRlZihwcm94eSwgJ192X2F0dHJfcHJveHknLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzeW5jU2V0dXBQcm94eShwcm94eSwgdm0uJGF0dHJzLCBlbXB0eU9iamVjdCwgdm0sICckYXR0cnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2bS5fYXR0cnNQcm94eTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGxpc3RlbmVycygpIHtcbiAgICAgICAgICAgIGlmICghdm0uX2xpc3RlbmVyc1Byb3h5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJveHkgPSAodm0uX2xpc3RlbmVyc1Byb3h5ID0ge30pO1xuICAgICAgICAgICAgICAgIHN5bmNTZXR1cFByb3h5KHByb3h5LCB2bS4kbGlzdGVuZXJzLCBlbXB0eU9iamVjdCwgdm0sICckbGlzdGVuZXJzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdm0uX2xpc3RlbmVyc1Byb3h5O1xuICAgICAgICB9LFxuICAgICAgICBnZXQgc2xvdHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5pdFNsb3RzUHJveHkodm0pO1xuICAgICAgICB9LFxuICAgICAgICBlbWl0OiBiaW5kKHZtLiRlbWl0LCB2bSksXG4gICAgICAgIGV4cG9zZShleHBvc2VkKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9zZUNhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBleHBvc2UoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZSBwZXIgc2V0dXAoKS5gLCB2bSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cG9zZUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwb3NlZCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGV4cG9zZWQpLmZvckVhY2goa2V5ID0+IHByb3h5V2l0aFJlZlVud3JhcCh2bSwgZXhwb3NlZCwga2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gc3luY1NldHVwUHJveHkodG8sIGZyb20sIHByZXYsIGluc3RhbmNlLCB0eXBlKSB7XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgICAgIGlmICghKGtleSBpbiB0bykpIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgZGVmaW5lUHJveHlBdHRyKHRvLCBrZXksIGluc3RhbmNlLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcm9tW2tleV0gIT09IHByZXZba2V5XSkge1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdG8pIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIGZyb20pKSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbGV0ZSB0b1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gZGVmaW5lUHJveHlBdHRyKHByb3h5LCBrZXksIGluc3RhbmNlLCB0eXBlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3h5LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VbdHlwZV1ba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5pdFNsb3RzUHJveHkodm0pIHtcbiAgICBpZiAoIXZtLl9zbG90c1Byb3h5KSB7XG4gICAgICAgIHN5bmNTZXR1cFNsb3RzKCh2bS5fc2xvdHNQcm94eSA9IHt9KSwgdm0uJHNjb3BlZFNsb3RzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZtLl9zbG90c1Byb3h5O1xufVxuZnVuY3Rpb24gc3luY1NldHVwU2xvdHModG8sIGZyb20pIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHRvKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRvW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbCB1c2UgbWFudWFsIHR5cGUgZGVmIGJlY2F1c2UgcHVibGljIHNldHVwIGNvbnRleHQgdHlwZSByZWxpZXMgb25cbiAqIGxlZ2FjeSBWTm9kZSB0eXBlc1xuICovXG5mdW5jdGlvbiB1c2VTbG90cygpIHtcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLnNsb3RzO1xufVxuLyoqXG4gKiBAaW50ZXJuYWwgdXNlIG1hbnVhbCB0eXBlIGRlZiBiZWNhdXNlIHB1YmxpYyBzZXR1cCBjb250ZXh0IHR5cGUgcmVsaWVzIG9uXG4gKiBsZWdhY3kgVk5vZGUgdHlwZXNcbiAqL1xuZnVuY3Rpb24gdXNlQXR0cnMoKSB7XG4gICAgcmV0dXJuIGdldENvbnRleHQoKS5hdHRycztcbn1cbi8qKlxuICogVnVlIDIgb25seVxuICogQGludGVybmFsIHVzZSBtYW51YWwgdHlwZSBkZWYgYmVjYXVzZSBwdWJsaWMgc2V0dXAgY29udGV4dCB0eXBlIHJlbGllcyBvblxuICogbGVnYWN5IFZOb2RlIHR5cGVzXG4gKi9cbmZ1bmN0aW9uIHVzZUxpc3RlbmVycygpIHtcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLmxpc3RlbmVycztcbn1cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgaWYgKCFjdXJyZW50SW5zdGFuY2UpIHtcbiAgICAgICAgd2FybihgdXNlQ29udGV4dCgpIGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBpbnN0YW5jZS5gKTtcbiAgICB9XG4gICAgY29uc3Qgdm0gPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgcmV0dXJuIHZtLl9zZXR1cENvbnRleHQgfHwgKHZtLl9zZXR1cENvbnRleHQgPSBjcmVhdGVTZXR1cENvbnRleHQodm0pKTtcbn1cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgZGVmYXVsdCBkZWNsYXJhdGlvbnMuIEltcG9ydGVkIGJ5IGNvbXBpbGVkIGNvZGVcbiAqIG9ubHkuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEZWZhdWx0cyhyYXcsIGRlZmF1bHRzKSB7XG4gICAgY29uc3QgcHJvcHMgPSBpc0FycmF5KHJhdylcbiAgICAgICAgPyByYXcucmVkdWNlKChub3JtYWxpemVkLCBwKSA9PiAoKG5vcm1hbGl6ZWRbcF0gPSB7fSksIG5vcm1hbGl6ZWQpLCB7fSlcbiAgICAgICAgOiByYXc7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgY29uc3Qgb3B0ID0gcHJvcHNba2V5XTtcbiAgICAgICAgaWYgKG9wdCkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkob3B0KSB8fCBpc0Z1bmN0aW9uKG9wdCkpIHtcbiAgICAgICAgICAgICAgICBwcm9wc1trZXldID0geyB0eXBlOiBvcHQsIGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdC5kZWZhdWx0ID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB7IGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdhcm4oYHByb3BzIGRlZmF1bHQga2V5IFwiJHtrZXl9XCIgaGFzIG5vIGNvcnJlc3BvbmRpbmcgZGVjbGFyYXRpb24uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BzO1xufVxuXG5mdW5jdGlvbiBpbml0UmVuZGVyKHZtKSB7XG4gICAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgICB2bS5fc3RhdGljVHJlZXMgPSBudWxsOyAvLyB2LW9uY2UgY2FjaGVkIHRyZWVzXG4gICAgY29uc3Qgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgIGNvbnN0IHBhcmVudFZub2RlID0gKHZtLiR2bm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlKTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgICBjb25zdCByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMob3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICAgIHZtLiRzY29wZWRTbG90cyA9IHBhcmVudFZub2RlXG4gICAgICAgID8gbm9ybWFsaXplU2NvcGVkU2xvdHModm0uJHBhcmVudCwgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cywgdm0uJHNsb3RzKVxuICAgICAgICA6IGVtcHR5T2JqZWN0O1xuICAgIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAgIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gICAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAgIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHZtLl9jID0gKGEsIGIsIGMsIGQpID0+IGNyZWF0ZUVsZW1lbnQkMSh2bSwgYSwgYiwgYywgZCwgZmFsc2UpO1xuICAgIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAgIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICB2bS4kY3JlYXRlRWxlbWVudCA9IChhLCBiLCBjLCBkKSA9PiBjcmVhdGVFbGVtZW50JDEodm0sIGEsIGIsIGMsIGQsIHRydWUpO1xuICAgIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXG4gICAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxuICAgIGNvbnN0IHBhcmVudERhdGEgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5kYXRhO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRhdHRycycsIChwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMpIHx8IGVtcHR5T2JqZWN0LCAoKSA9PiB7XG4gICAgICAgICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oYCRhdHRycyBpcyByZWFkb25seS5gLCB2bSk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsICgpID0+IHtcbiAgICAgICAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihgJGxpc3RlbmVycyBpcyByZWFkb25seS5gLCB2bSk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgIH1cbn1cbmxldCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuZnVuY3Rpb24gcmVuZGVyTWl4aW4oVnVlKSB7XG4gICAgLy8gaW5zdGFsbCBydW50aW1lIGNvbnZlbmllbmNlIGhlbHBlcnNcbiAgICBpbnN0YWxsUmVuZGVySGVscGVycyhWdWUucHJvdG90eXBlKTtcbiAgICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpO1xuICAgIH07XG4gICAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgcmVuZGVyLCBfcGFyZW50Vm5vZGUgfSA9IHZtLiRvcHRpb25zO1xuICAgICAgICBpZiAoX3BhcmVudFZub2RlICYmIHZtLl9pc01vdW50ZWQpIHtcbiAgICAgICAgICAgIHZtLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKHZtLiRwYXJlbnQsIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzLCB2bS4kc2xvdHMsIHZtLiRzY29wZWRTbG90cyk7XG4gICAgICAgICAgICBpZiAodm0uX3Nsb3RzUHJveHkpIHtcbiAgICAgICAgICAgICAgICBzeW5jU2V0dXBTbG90cyh2bS5fc2xvdHNQcm94eSwgdm0uJHNjb3BlZFNsb3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgICAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgICAgIC8vIHJlbmRlciBzZWxmXG4gICAgICAgIGxldCB2bm9kZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBtYWludGFpbiBhIHN0YWNrIGJlY2F1c2UgYWxsIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgICAgICAgLy8gc2VwYXJhdGVseSBmcm9tIG9uZSBhbm90aGVyLiBOZXN0ZWQgY29tcG9uZW50J3MgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAgICAgICAvLyB3aGVuIHBhcmVudCBjb21wb25lbnQgaXMgcGF0Y2hlZC5cbiAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZSh2bSk7XG4gICAgICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSB2bTtcbiAgICAgICAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBgcmVuZGVyYCk7XG4gICAgICAgICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgICAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHZtLiRvcHRpb25zLnJlbmRlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgYHJlbmRlckVycm9yYCk7XG4gICAgICAgICAgICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSByZXR1cm5lZCBhcnJheSBjb250YWlucyBvbmx5IGEgc2luZ2xlIG5vZGUsIGFsbG93IGl0XG4gICAgICAgIGlmIChpc0FycmF5KHZub2RlKSAmJiB2bm9kZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHZub2RlID0gdm5vZGVbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgICAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgd2FybignTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJywgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHBhcmVudFxuICAgICAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgICAgIHJldHVybiB2bm9kZTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBlbnN1cmVDdG9yKGNvbXAsIGJhc2UpIHtcbiAgICBpZiAoY29tcC5fX2VzTW9kdWxlIHx8IChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJykpIHtcbiAgICAgICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgICB9XG4gICAgcmV0dXJuIGlzT2JqZWN0KGNvbXApID8gYmFzZS5leHRlbmQoY29tcCkgOiBjb21wO1xufVxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihmYWN0b3J5LCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKSB7XG4gICAgY29uc3Qgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcgfTtcbiAgICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudChmYWN0b3J5LCBiYXNlQ3Rvcikge1xuICAgIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcDtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkO1xuICAgIH1cbiAgICBjb25zdCBvd25lciA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgICBpZiAob3duZXIgJiYgaXNEZWYoZmFjdG9yeS5vd25lcnMpICYmIGZhY3Rvcnkub3duZXJzLmluZGV4T2Yob3duZXIpID09PSAtMSkge1xuICAgICAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICAgICAgZmFjdG9yeS5vd25lcnMucHVzaChvd25lcik7XG4gICAgfVxuICAgIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgICAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcDtcbiAgICB9XG4gICAgaWYgKG93bmVyICYmICFpc0RlZihmYWN0b3J5Lm93bmVycykpIHtcbiAgICAgICAgY29uc3Qgb3duZXJzID0gKGZhY3Rvcnkub3duZXJzID0gW293bmVyXSk7XG4gICAgICAgIGxldCBzeW5jID0gdHJ1ZTtcbiAgICAgICAgbGV0IHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgICAgIGxldCB0aW1lclRpbWVvdXQgPSBudWxsO1xuICAgICAgICBvd25lci4kb24oJ2hvb2s6ZGVzdHJveWVkJywgKCkgPT4gcmVtb3ZlJDIob3duZXJzLCBvd25lcikpO1xuICAgICAgICBjb25zdCBmb3JjZVJlbmRlciA9IChyZW5kZXJDb21wbGV0ZWQpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gb3duZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIG93bmVyc1tpXS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZW5kZXJDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodGltZXJMb2FkaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lckxvYWRpbmcpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGltZXJUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lclRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB0aW1lclRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZSA9IG9uY2UoKHJlcykgPT4ge1xuICAgICAgICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgICAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICAgICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVqZWN0ID0gb25jZShyZWFzb24gPT4ge1xuICAgICAgICAgICAgd2FybihgRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiAke1N0cmluZyhmYWN0b3J5KX1gICtcbiAgICAgICAgICAgICAgICAgICAgKHJlYXNvbiA/IGBcXG5SZWFzb246ICR7cmVhc29ufWAgOiAnJykpO1xuICAgICAgICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICAgICAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNQcm9taXNlKHJlcy5jb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5vZGVKUyB0aW1lb3V0IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyTG9hZGluZyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5vZGVKUyB0aW1lb3V0IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgdGltZXJUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lclRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoYHRpbWVvdXQgKCR7cmVzLnRpbWVvdXR9bXMpYCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN5bmMgPSBmYWxzZTtcbiAgICAgICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgICAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nID8gZmFjdG9yeS5sb2FkaW5nQ29tcCA6IGZhY3RvcnkucmVzb2x2ZWQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkKGNoaWxkcmVuKSB7XG4gICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xuY29uc3QgQUxXQVlTX05PUk1BTElaRSA9IDI7XG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZSkge1xuICAgIGlmIChpc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG4gICAgICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgICB9XG4gICAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKSB7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuX19vYl9fKSkge1xuICAgICAgICB3YXJuKGBBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfVxcbmAgKyAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgICAgIHRhZyA9IGRhdGEuaXM7XG4gICAgfVxuICAgIGlmICghdGFnKSB7XG4gICAgICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpKSB7XG4gICAgICAgIHdhcm4oJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsIGNvbnRleHQpO1xuICAgIH1cbiAgICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pICYmIGlzRnVuY3Rpb24oY2hpbGRyZW5bMF0pKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgICAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgIH1cbiAgICBsZXQgdm5vZGUsIG5zO1xuICAgIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgICAgICBsZXQgQ3RvcjtcbiAgICAgICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgICAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoaXNEZWYoZGF0YSkgJiZcbiAgICAgICAgICAgICAgICBpc0RlZihkYXRhLm5hdGl2ZU9uKSAmJlxuICAgICAgICAgICAgICAgIGRhdGEudGFnICE9PSAnY29tcG9uZW50Jykge1xuICAgICAgICAgICAgICAgIHdhcm4oYFRoZSAubmF0aXZlIG1vZGlmaWVyIGZvciB2LW9uIGlzIG9ubHkgdmFsaWQgb24gY29tcG9uZW50cyBidXQgaXQgd2FzIHVzZWQgb24gPCR7dGFnfT4uYCwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2bm9kZSA9IG5ldyBWTm9kZShjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoIWRhdGEgfHwgIWRhdGEucHJlKSAmJlxuICAgICAgICAgICAgaXNEZWYoKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkpIHtcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgICAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAgICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgICAgICAgdm5vZGUgPSBuZXcgVk5vZGUodGFnLCBkYXRhLCBjaGlsZHJlbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHJldHVybiB2bm9kZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgICAgIGlmIChpc0RlZihucykpXG4gICAgICAgICAgICBhcHBseU5TKHZub2RlLCBucyk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSlcbiAgICAgICAgICAgIHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpO1xuICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5TlModm5vZGUsIG5zLCBmb3JjZSkge1xuICAgIHZub2RlLm5zID0gbnM7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgICAgICBucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiZcbiAgICAgICAgICAgICAgICAoaXNVbmRlZihjaGlsZC5ucykgfHwgKGlzVHJ1ZShmb3JjZSkgJiYgY2hpbGQudGFnICE9PSAnc3ZnJykpKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIHJlZiAjNTMxOFxuLy8gbmVjZXNzYXJ5IHRvIGVuc3VyZSBwYXJlbnQgcmUtcmVuZGVyIHdoZW4gZGVlcCBiaW5kaW5ncyBsaWtlIDpzdHlsZSBhbmRcbi8vIDpjbGFzcyBhcmUgdXNlZCBvbiBzbG90IG5vZGVzXG5mdW5jdGlvbiByZWdpc3RlckRlZXBCaW5kaW5ncyhkYXRhKSB7XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XG4gICAgICAgIHRyYXZlcnNlKGRhdGEuc3R5bGUpO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3QoZGF0YS5jbGFzcykpIHtcbiAgICAgICAgdHJhdmVyc2UoZGF0YS5jbGFzcyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbCB0aGlzIGZ1bmN0aW9uIG5lZWRzIG1hbnVhbCBwdWJsaWMgdHlwZSBkZWNsYXJhdGlvbiBiZWNhdXNlIGl0IHJlbGllc1xuICogb24gcHJldmlvdXNseSBtYW51YWxseSBhdXRob3JlZCB0eXBlcyBmcm9tIFZ1ZSAyXG4gKi9cbmZ1bmN0aW9uIGgodHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgaWYgKCFjdXJyZW50SW5zdGFuY2UpIHtcbiAgICAgICAgd2FybihgZ2xvYmFsbHkgaW1wb3J0ZWQgaCgpIGNhbiBvbmx5IGJlIGludm9rZWQgd2hlbiB0aGVyZSBpcyBhbiBhY3RpdmUgYCArXG4gICAgICAgICAgICAgICAgYGNvbXBvbmVudCBpbnN0YW5jZSwgZS5nLiBzeW5jaHJvbm91c2x5IGluIGEgY29tcG9uZW50J3MgcmVuZGVyIG9yIHNldHVwIGZ1bmN0aW9uLmApO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCQxKGN1cnJlbnRJbnN0YW5jZSwgdHlwZSwgcHJvcHMsIGNoaWxkcmVuLCAyLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbykge1xuICAgIC8vIERlYWN0aXZhdGUgZGVwcyB0cmFja2luZyB3aGlsZSBwcm9jZXNzaW5nIGVycm9yIGhhbmRsZXIgdG8gYXZvaWQgcG9zc2libGUgaW5maW5pdGUgcmVuZGVyaW5nLlxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZXgvaXNzdWVzLzE1MDVcbiAgICBwdXNoVGFyZ2V0KCk7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHZtKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gdm07XG4gICAgICAgICAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhcHR1cmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsSGFuZGxlRXJyb3IoZSwgY3VyLCAnZXJyb3JDYXB0dXJlZCBob29rJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBwb3BUYXJnZXQoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhoYW5kbGVyLCBjb250ZXh0LCBhcmdzLCB2bSwgaW5mbykge1xuICAgIGxldCByZXM7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzID0gYXJncyA/IGhhbmRsZXIuYXBwbHkoY29udGV4dCwgYXJncykgOiBoYW5kbGVyLmNhbGwoY29udGV4dCk7XG4gICAgICAgIGlmIChyZXMgJiYgIXJlcy5faXNWdWUgJiYgaXNQcm9taXNlKHJlcykgJiYgIXJlcy5faGFuZGxlZCkge1xuICAgICAgICAgICAgcmVzLmNhdGNoKGUgPT4gaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8gKyBgIChQcm9taXNlL2FzeW5jKWApKTtcbiAgICAgICAgICAgIHJlcy5faGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbykge1xuICAgIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgdXNlciBpbnRlbnRpb25hbGx5IHRocm93cyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gdGhlIGhhbmRsZXIsXG4gICAgICAgICAgICAvLyBkbyBub3QgbG9nIGl0IHR3aWNlXG4gICAgICAgICAgICBpZiAoZSAhPT0gZXJyKSB7XG4gICAgICAgICAgICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2dFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cbmZ1bmN0aW9uIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pIHtcbiAgICB7XG4gICAgICAgIHdhcm4oYEVycm9yIGluICR7aW5mb306IFwiJHtlcnIudG9TdHJpbmcoKX1cImAsIHZtKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufVxuXG4vKiBnbG9iYWxzIE11dGF0aW9uT2JzZXJ2ZXIgKi9cbmxldCBpc1VzaW5nTWljcm9UYXNrID0gZmFsc2U7XG5jb25zdCBjYWxsYmFja3MgPSBbXTtcbmxldCBwZW5kaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBmbHVzaENhbGxiYWNrcygpIHtcbiAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgY29uc3QgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbn1cbi8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgbWljcm90YXNrcy5cbi8vIEluIDIuNSB3ZSB1c2VkIChtYWNybykgdGFza3MgKGluIGNvbWJpbmF0aW9uIHdpdGggbWljcm90YXNrcykuXG4vLyBIb3dldmVyLCBpdCBoYXMgc3VidGxlIHByb2JsZW1zIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludFxuLy8gKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXG4vLyBBbHNvLCB1c2luZyAobWFjcm8pIHRhc2tzIGluIGV2ZW50IGhhbmRsZXIgd291bGQgY2F1c2Ugc29tZSB3ZWlyZCBiZWhhdmlvcnNcbi8vIHRoYXQgY2Fubm90IGJlIGNpcmN1bXZlbnRlZCAoZS5nLiAjNzEwOSwgIzcxNTMsICM3NTQ2LCAjNzgzNCwgIzgxMDkpLlxuLy8gU28gd2Ugbm93IHVzZSBtaWNyb3Rhc2tzIGV2ZXJ5d2hlcmUsIGFnYWluLlxuLy8gQSBtYWpvciBkcmF3YmFjayBvZiB0aGlzIHRyYWRlb2ZmIGlzIHRoYXQgdGhlcmUgYXJlIHNvbWUgc2NlbmFyaW9zXG4vLyB3aGVyZSBtaWNyb3Rhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZSBpbiBiZXR3ZWVuIHN1cHBvc2VkbHlcbi8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCwgd2hpY2ggaGF2ZSB3b3JrYXJvdW5kcylcbi8vIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZSBldmVudCAoIzY1NjYpLlxubGV0IHRpbWVyRnVuYztcbi8vIFRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG4vLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbi8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcbi8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbi8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0LCAkZmxvdy1kaXNhYmxlLWxpbmUgKi9cbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgICBjb25zdCBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdGltZXJGdW5jID0gKCkgPT4ge1xuICAgICAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgICAgICAvLyBJbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAgICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgICAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICAgICAgaWYgKGlzSU9TKVxuICAgICAgICAgICAgc2V0VGltZW91dChub29wKTtcbiAgICB9O1xuICAgIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufVxuZWxzZSBpZiAoIWlzSUUgJiZcbiAgICB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAoaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgICAgICAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG4gICAgICAgIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXScpKSB7XG4gICAgLy8gVXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcbiAgICAvLyBlLmcuIFBoYW50b21KUywgaU9TNywgQW5kcm9pZCA0LjRcbiAgICAvLyAoIzY0NjYgTXV0YXRpb25PYnNlcnZlciBpcyB1bnJlbGlhYmxlIGluIElFMTEpXG4gICAgbGV0IGNvdW50ZXIgPSAxO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2hDYWxsYmFja3MpO1xuICAgIGNvbnN0IHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICB0aW1lckZ1bmMgPSAoKSA9PiB7XG4gICAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgICB9O1xuICAgIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufVxuZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoc2V0SW1tZWRpYXRlKSkge1xuICAgIC8vIEZhbGxiYWNrIHRvIHNldEltbWVkaWF0ZS5cbiAgICAvLyBUZWNobmljYWxseSBpdCBsZXZlcmFnZXMgdGhlIChtYWNybykgdGFzayBxdWV1ZSxcbiAgICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cbiAgICB0aW1lckZ1bmMgPSAoKSA9PiB7XG4gICAgICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gICAgfTtcbn1cbmVsc2Uge1xuICAgIC8vIEZhbGxiYWNrIHRvIHNldFRpbWVvdXQuXG4gICAgdGltZXJGdW5jID0gKCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KGZsdXNoQ2FsbGJhY2tzLCAwKTtcbiAgICB9O1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gbmV4dFRpY2soY2IsIGN0eCkge1xuICAgIGxldCBfcmVzb2x2ZTtcbiAgICBjYWxsYmFja3MucHVzaCgoKSA9PiB7XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgICAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICAgIHRpbWVyRnVuYygpO1xuICAgIH1cbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdXNlQ3NzTW9kdWxlKG5hbWUgPSAnJHN0eWxlJykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAge1xuICAgICAgICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgd2FybihgdXNlQ3NzTW9kdWxlIG11c3QgYmUgY2FsbGVkIGluc2lkZSBzZXR1cCgpYCk7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kID0gY3VycmVudEluc3RhbmNlW25hbWVdO1xuICAgICAgICBpZiAoIW1vZCkge1xuICAgICAgICAgICAgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGUgbmFtZWQgXCIke25hbWV9XCIuYCk7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZDtcbiAgICB9XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIFNGQydzIENTUyB2YXJpYWJsZSBpbmplY3Rpb24gZmVhdHVyZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVzZUNzc1ZhcnMoZ2V0dGVyKSB7XG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgIWZhbHNlKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgICB3YXJuKGB1c2VDc3NWYXJzIGlzIGNhbGxlZCB3aXRob3V0IGN1cnJlbnQgYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZS5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3YXRjaFBvc3RFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IGluc3RhbmNlLiRlbDtcbiAgICAgICAgY29uc3QgdmFycyA9IGdldHRlcihpbnN0YW5jZSwgaW5zdGFuY2UuX3NldHVwUHJveHkpO1xuICAgICAgICBpZiAoZWwgJiYgZWwubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YXJzKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoYC0tJHtrZXl9YCwgdmFyc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIHYzLWNvbXBhdGlibGUgYXN5bmMgY29tcG9uZW50IEFQSS5cbiAqIEBpbnRlcm5hbCB0aGUgdHlwZSBpcyBtYW51YWxseSBkZWNsYXJlZCBpbiA8cm9vdD4vdHlwZXMvdjMtZGVmaW5lLWFzeW5jLWNvbXBvbmVudC5kLnRzXG4gKiBiZWNhdXNlIGl0IHJlbGllcyBvbiBleGlzdGluZyBtYW51YWwgdHlwZXNcbiAqL1xuZnVuY3Rpb24gZGVmaW5lQXN5bmNDb21wb25lbnQoc291cmNlKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgICAgICBzb3VyY2UgPSB7IGxvYWRlcjogc291cmNlIH07XG4gICAgfVxuICAgIGNvbnN0IHsgbG9hZGVyLCBsb2FkaW5nQ29tcG9uZW50LCBlcnJvckNvbXBvbmVudCwgZGVsYXkgPSAyMDAsIHRpbWVvdXQsIC8vIHVuZGVmaW5lZCA9IG5ldmVyIHRpbWVzIG91dFxuICAgIHN1c3BlbnNpYmxlID0gZmFsc2UsIC8vIGluIFZ1ZSAzIGRlZmF1bHQgaXMgdHJ1ZVxuICAgIG9uRXJyb3I6IHVzZXJPbkVycm9yIH0gPSBzb3VyY2U7XG4gICAgaWYgKHN1c3BlbnNpYmxlKSB7XG4gICAgICAgIHdhcm4oYFRoZSBzdXNwZW5zaWJsYmUgb3B0aW9uIGZvciBhc3luYyBjb21wb25lbnRzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVnVlMi4gSXQgaXMgaWdub3JlZC5gKTtcbiAgICB9XG4gICAgbGV0IHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgICBsZXQgcmV0cmllcyA9IDA7XG4gICAgY29uc3QgcmV0cnkgPSAoKSA9PiB7XG4gICAgICAgIHJldHJpZXMrKztcbiAgICAgICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICAgICAgICByZXR1cm4gbG9hZCgpO1xuICAgIH07XG4gICAgY29uc3QgbG9hZCA9ICgpID0+IHtcbiAgICAgICAgbGV0IHRoaXNSZXF1ZXN0O1xuICAgICAgICByZXR1cm4gKHBlbmRpbmdSZXF1ZXN0IHx8XG4gICAgICAgICAgICAodGhpc1JlcXVlc3QgPSBwZW5kaW5nUmVxdWVzdCA9XG4gICAgICAgICAgICAgICAgbG9hZGVyKClcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVyciA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKFN0cmluZyhlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJSZXRyeSA9ICgpID0+IHJlc29sdmUocmV0cnkoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlckZhaWwgPSAoKSA9PiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyT25FcnJvcihlcnIsIHVzZXJSZXRyeSwgdXNlckZhaWwsIHJldHJpZXMgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGNvbXApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNSZXF1ZXN0ICE9PSBwZW5kaW5nUmVxdWVzdCAmJiBwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgQXN5bmMgY29tcG9uZW50IGxvYWRlciByZXNvbHZlZCB0byB1bmRlZmluZWQuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB5b3UgYXJlIHVzaW5nIHJldHJ5KCksIG1ha2Ugc3VyZSB0byByZXR1cm4gaXRzIHJldHVybiB2YWx1ZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcm9wIG1vZHVsZSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29tcC5fX2VzTW9kdWxlIHx8IGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wICYmICFpc09iamVjdChjb21wKSAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFzeW5jIGNvbXBvbmVudCBsb2FkIHJlc3VsdDogJHtjb21wfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wO1xuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgfTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBsb2FkKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21wb25lbnQsXG4gICAgICAgICAgICBkZWxheSxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3JDb21wb25lbnQsXG4gICAgICAgICAgICBsb2FkaW5nOiBsb2FkaW5nQ29tcG9uZW50XG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlmZUN5Y2xlKGhvb2tOYW1lKSB7XG4gICAgcmV0dXJuIChmbiwgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSA9PiB7XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICB3YXJuKGAke2Zvcm1hdE5hbWUoaG9va05hbWUpfSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGAgK1xuICAgICAgICAgICAgICAgICAgICBgYXNzb2NpYXRlZCB3aXRoLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYExpZmVjeWNsZSBpbmplY3Rpb24gQVBJcyBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBleGVjdXRpb24gb2Ygc2V0dXAoKS5gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5qZWN0SG9vayh0YXJnZXQsIGhvb2tOYW1lLCBmbik7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZvcm1hdE5hbWUobmFtZSkge1xuICAgIGlmIChuYW1lID09PSAnYmVmb3JlRGVzdHJveScpIHtcbiAgICAgICAgbmFtZSA9ICdiZWZvcmVVbm1vdW50JztcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ2Rlc3Ryb3llZCcpIHtcbiAgICAgICAgbmFtZSA9ICd1bm1vdW50ZWQnO1xuICAgIH1cbiAgICByZXR1cm4gYG9uJHtuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpfWA7XG59XG5mdW5jdGlvbiBpbmplY3RIb29rKGluc3RhbmNlLCBob29rTmFtZSwgZm4pIHtcbiAgICBjb25zdCBvcHRpb25zID0gaW5zdGFuY2UuJG9wdGlvbnM7XG4gICAgb3B0aW9uc1tob29rTmFtZV0gPSBtZXJnZUxpZmVjeWNsZUhvb2sob3B0aW9uc1tob29rTmFtZV0sIGZuKTtcbn1cbmNvbnN0IG9uQmVmb3JlTW91bnQgPSBjcmVhdGVMaWZlQ3ljbGUoJ2JlZm9yZU1vdW50Jyk7XG5jb25zdCBvbk1vdW50ZWQgPSBjcmVhdGVMaWZlQ3ljbGUoJ21vdW50ZWQnKTtcbmNvbnN0IG9uQmVmb3JlVXBkYXRlID0gY3JlYXRlTGlmZUN5Y2xlKCdiZWZvcmVVcGRhdGUnKTtcbmNvbnN0IG9uVXBkYXRlZCA9IGNyZWF0ZUxpZmVDeWNsZSgndXBkYXRlZCcpO1xuY29uc3Qgb25CZWZvcmVVbm1vdW50ID0gY3JlYXRlTGlmZUN5Y2xlKCdiZWZvcmVEZXN0cm95Jyk7XG5jb25zdCBvblVubW91bnRlZCA9IGNyZWF0ZUxpZmVDeWNsZSgnZGVzdHJveWVkJyk7XG5jb25zdCBvbkFjdGl2YXRlZCA9IGNyZWF0ZUxpZmVDeWNsZSgnYWN0aXZhdGVkJyk7XG5jb25zdCBvbkRlYWN0aXZhdGVkID0gY3JlYXRlTGlmZUN5Y2xlKCdkZWFjdGl2YXRlZCcpO1xuY29uc3Qgb25TZXJ2ZXJQcmVmZXRjaCA9IGNyZWF0ZUxpZmVDeWNsZSgnc2VydmVyUHJlZmV0Y2gnKTtcbmNvbnN0IG9uUmVuZGVyVHJhY2tlZCA9IGNyZWF0ZUxpZmVDeWNsZSgncmVuZGVyVHJhY2tlZCcpO1xuY29uc3Qgb25SZW5kZXJUcmlnZ2VyZWQgPSBjcmVhdGVMaWZlQ3ljbGUoJ3JlbmRlclRyaWdnZXJlZCcpO1xuY29uc3QgaW5qZWN0RXJyb3JDYXB0dXJlZEhvb2sgPSBjcmVhdGVMaWZlQ3ljbGUoJ2Vycm9yQ2FwdHVyZWQnKTtcbmZ1bmN0aW9uIG9uRXJyb3JDYXB0dXJlZChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcbiAgICBpbmplY3RFcnJvckNhcHR1cmVkSG9vayhob29rLCB0YXJnZXQpO1xufVxuXG4vKipcbiAqIE5vdGU6IGFsc28gdXBkYXRlIGRpc3QvdnVlLnJ1bnRpbWUubWpzIHdoZW4gYWRkaW5nIG5ldyBleHBvcnRzIHRvIHRoaXMgZmlsZS5cbiAqL1xuY29uc3QgdmVyc2lvbiA9ICcyLjcuMTQnO1xuLyoqXG4gKiBAaW50ZXJuYWwgdHlwZSBpcyBtYW51YWxseSBkZWNsYXJlZCBpbiA8cm9vdD4vdHlwZXMvdjMtZGVmaW5lLWNvbXBvbmVudC5kLnRzXG4gKi9cbmZ1bmN0aW9uIGRlZmluZUNvbXBvbmVudChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbnZhciB2Y2EgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgdmVyc2lvbjogdmVyc2lvbixcbiAgZGVmaW5lQ29tcG9uZW50OiBkZWZpbmVDb21wb25lbnQsXG4gIHJlZjogcmVmJDEsXG4gIHNoYWxsb3dSZWY6IHNoYWxsb3dSZWYsXG4gIGlzUmVmOiBpc1JlZixcbiAgdG9SZWY6IHRvUmVmLFxuICB0b1JlZnM6IHRvUmVmcyxcbiAgdW5yZWY6IHVucmVmLFxuICBwcm94eVJlZnM6IHByb3h5UmVmcyxcbiAgY3VzdG9tUmVmOiBjdXN0b21SZWYsXG4gIHRyaWdnZXJSZWY6IHRyaWdnZXJSZWYsXG4gIHJlYWN0aXZlOiByZWFjdGl2ZSxcbiAgaXNSZWFjdGl2ZTogaXNSZWFjdGl2ZSxcbiAgaXNSZWFkb25seTogaXNSZWFkb25seSxcbiAgaXNTaGFsbG93OiBpc1NoYWxsb3csXG4gIGlzUHJveHk6IGlzUHJveHksXG4gIHNoYWxsb3dSZWFjdGl2ZTogc2hhbGxvd1JlYWN0aXZlLFxuICBtYXJrUmF3OiBtYXJrUmF3LFxuICB0b1JhdzogdG9SYXcsXG4gIHJlYWRvbmx5OiByZWFkb25seSxcbiAgc2hhbGxvd1JlYWRvbmx5OiBzaGFsbG93UmVhZG9ubHksXG4gIGNvbXB1dGVkOiBjb21wdXRlZCxcbiAgd2F0Y2g6IHdhdGNoLFxuICB3YXRjaEVmZmVjdDogd2F0Y2hFZmZlY3QsXG4gIHdhdGNoUG9zdEVmZmVjdDogd2F0Y2hQb3N0RWZmZWN0LFxuICB3YXRjaFN5bmNFZmZlY3Q6IHdhdGNoU3luY0VmZmVjdCxcbiAgRWZmZWN0U2NvcGU6IEVmZmVjdFNjb3BlLFxuICBlZmZlY3RTY29wZTogZWZmZWN0U2NvcGUsXG4gIG9uU2NvcGVEaXNwb3NlOiBvblNjb3BlRGlzcG9zZSxcbiAgZ2V0Q3VycmVudFNjb3BlOiBnZXRDdXJyZW50U2NvcGUsXG4gIHByb3ZpZGU6IHByb3ZpZGUsXG4gIGluamVjdDogaW5qZWN0LFxuICBoOiBoLFxuICBnZXRDdXJyZW50SW5zdGFuY2U6IGdldEN1cnJlbnRJbnN0YW5jZSxcbiAgdXNlU2xvdHM6IHVzZVNsb3RzLFxuICB1c2VBdHRyczogdXNlQXR0cnMsXG4gIHVzZUxpc3RlbmVyczogdXNlTGlzdGVuZXJzLFxuICBtZXJnZURlZmF1bHRzOiBtZXJnZURlZmF1bHRzLFxuICBuZXh0VGljazogbmV4dFRpY2ssXG4gIHNldDogc2V0LFxuICBkZWw6IGRlbCxcbiAgdXNlQ3NzTW9kdWxlOiB1c2VDc3NNb2R1bGUsXG4gIHVzZUNzc1ZhcnM6IHVzZUNzc1ZhcnMsXG4gIGRlZmluZUFzeW5jQ29tcG9uZW50OiBkZWZpbmVBc3luY0NvbXBvbmVudCxcbiAgb25CZWZvcmVNb3VudDogb25CZWZvcmVNb3VudCxcbiAgb25Nb3VudGVkOiBvbk1vdW50ZWQsXG4gIG9uQmVmb3JlVXBkYXRlOiBvbkJlZm9yZVVwZGF0ZSxcbiAgb25VcGRhdGVkOiBvblVwZGF0ZWQsXG4gIG9uQmVmb3JlVW5tb3VudDogb25CZWZvcmVVbm1vdW50LFxuICBvblVubW91bnRlZDogb25Vbm1vdW50ZWQsXG4gIG9uQWN0aXZhdGVkOiBvbkFjdGl2YXRlZCxcbiAgb25EZWFjdGl2YXRlZDogb25EZWFjdGl2YXRlZCxcbiAgb25TZXJ2ZXJQcmVmZXRjaDogb25TZXJ2ZXJQcmVmZXRjaCxcbiAgb25SZW5kZXJUcmFja2VkOiBvblJlbmRlclRyYWNrZWQsXG4gIG9uUmVuZGVyVHJpZ2dlcmVkOiBvblJlbmRlclRyaWdnZXJlZCxcbiAgb25FcnJvckNhcHR1cmVkOiBvbkVycm9yQ2FwdHVyZWRcbn0pO1xuXG5jb25zdCBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2UodmFsKSB7XG4gICAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICAgIHNlZW5PYmplY3RzLmNsZWFyKCk7XG4gICAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIF90cmF2ZXJzZSh2YWwsIHNlZW4pIHtcbiAgICBsZXQgaSwga2V5cztcbiAgICBjb25zdCBpc0EgPSBpc0FycmF5KHZhbCk7XG4gICAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fFxuICAgICAgICB2YWwuX192X3NraXAgLyogUmVhY3RpdmVGbGFncy5TS0lQICovIHx8XG4gICAgICAgIE9iamVjdC5pc0Zyb3plbih2YWwpIHx8XG4gICAgICAgIHZhbCBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbC5fX29iX18pIHtcbiAgICAgICAgY29uc3QgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICAgICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgICB9XG4gICAgaWYgKGlzQSkge1xuICAgICAgICBpID0gdmFsLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgIF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1JlZih2YWwpKSB7XG4gICAgICAgIF90cmF2ZXJzZSh2YWwudmFsdWUsIHNlZW4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgIF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pO1xuICAgIH1cbn1cblxubGV0IHVpZCQxID0gMDtcbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgV2F0Y2hlciB7XG4gICAgY29uc3RydWN0b3Iodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zLCBpc1JlbmRlcldhdGNoZXIpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0U2NvcGUodGhpcywgXG4gICAgICAgIC8vIGlmIHRoZSBhY3RpdmUgZWZmZWN0IHNjb3BlIGlzIG1hbnVhbGx5IGNyZWF0ZWQgKG5vdCBhIGNvbXBvbmVudCBzY29wZSksXG4gICAgICAgIC8vIHByaW9yaXRpemUgaXRcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgJiYgIWFjdGl2ZUVmZmVjdFNjb3BlLl92bVxuICAgICAgICAgICAgPyBhY3RpdmVFZmZlY3RTY29wZVxuICAgICAgICAgICAgOiB2bVxuICAgICAgICAgICAgICAgID8gdm0uX3Njb3BlXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoKHRoaXMudm0gPSB2bSkgJiYgaXNSZW5kZXJXYXRjaGVyKSB7XG4gICAgICAgICAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3B0aW9uc1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgICAgICAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICAgICAgICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgICAgICAgICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gICAgICAgICAgICB0aGlzLmJlZm9yZSA9IG9wdGlvbnMuYmVmb3JlO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMub25UcmFjayA9IG9wdGlvbnMub25UcmFjaztcbiAgICAgICAgICAgICAgICB0aGlzLm9uVHJpZ2dlciA9IG9wdGlvbnMub25UcmlnZ2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYiA9IGNiO1xuICAgICAgICB0aGlzLmlkID0gKyt1aWQkMTsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMucG9zdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICAgICAgICB0aGlzLmRlcHMgPSBbXTtcbiAgICAgICAgdGhpcy5uZXdEZXBzID0gW107XG4gICAgICAgIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgICAgICAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHBPckZuLnRvU3RyaW5nKCkgO1xuICAgICAgICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZXhwT3JGbikpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0dGVyID0gbm9vcDtcbiAgICAgICAgICAgICAgICB3YXJuKGBGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXCIke2V4cE9yRm59XCIgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJywgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmxhenkgPyB1bmRlZmluZWQgOiB0aGlzLmdldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gICAgICovXG4gICAgZ2V0KCkge1xuICAgICAgICBwdXNoVGFyZ2V0KHRoaXMpO1xuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGNvbnN0IHZtID0gdGhpcy52bTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIGBnZXR0ZXIgZm9yIHdhdGNoZXIgXCIke3RoaXMuZXhwcmVzc2lvbn1cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAgICAgICAgICAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gICAgICAgICAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICAgICAgICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICAgICAqL1xuICAgIGFkZERlcChkZXApIHtcbiAgICAgICAgY29uc3QgaWQgPSBkZXAuaWQ7XG4gICAgICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICAgICAgICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gICAgICovXG4gICAgY2xlYW51cERlcHMoKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY29uc3QgZGVwID0gdGhpcy5kZXBzW2ldO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgICAgICAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRtcCA9IHRoaXMuZGVwSWRzO1xuICAgICAgICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICAgICAgICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgICAgICAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgICAgICAgdG1wID0gdGhpcy5kZXBzO1xuICAgICAgICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gICAgICAgIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgICAgICAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICAgICAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodGhpcy5sYXp5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICAgICAgICAgIHRoaXMucnVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gICAgICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAgICAgKi9cbiAgICBydW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAgICAgICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgICAgICAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgICAgICAgICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmRlZXApIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZm8gPSBgY2FsbGJhY2sgZm9yIHdhdGNoZXIgXCIke3RoaXMuZXhwcmVzc2lvbn1cImA7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKHRoaXMuY2IsIHRoaXMudm0sIFt2YWx1ZSwgb2xkVmFsdWVdLCB0aGlzLnZtLCBpbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gICAgICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICAgICAqL1xuICAgIGV2YWx1YXRlKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAgICAgKi9cbiAgICBkZXBlbmQoKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdGhpcy5kZXBzW2ldLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICAgICAqL1xuICAgIHRlYXJkb3duKCkge1xuICAgICAgICBpZiAodGhpcy52bSAmJiAhdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmVtb3ZlJDIodGhpcy52bS5fc2NvcGUuZWZmZWN0cywgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICBsZXQgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5vblN0b3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uU3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5sZXQgbWFyaztcbmxldCBtZWFzdXJlO1xue1xuICAgIGNvbnN0IHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwZXJmICYmXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcGVyZi5tYXJrICYmXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcGVyZi5tZWFzdXJlICYmXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcGVyZi5jbGVhck1lYXN1cmVzKSB7XG4gICAgICAgIG1hcmsgPSB0YWcgPT4gcGVyZi5tYXJrKHRhZyk7XG4gICAgICAgIG1lYXN1cmUgPSAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykgPT4ge1xuICAgICAgICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgICAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgICAgICAgLy8gcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbml0RXZlbnRzKHZtKSB7XG4gICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAgIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gICAgfVxufVxubGV0IHRhcmdldCQxO1xuZnVuY3Rpb24gYWRkJDEoZXZlbnQsIGZuKSB7XG4gICAgdGFyZ2V0JDEuJG9uKGV2ZW50LCBmbik7XG59XG5mdW5jdGlvbiByZW1vdmUkMShldmVudCwgZm4pIHtcbiAgICB0YXJnZXQkMS4kb2ZmKGV2ZW50LCBmbik7XG59XG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciQxKGV2ZW50LCBmbikge1xuICAgIGNvbnN0IF90YXJnZXQgPSB0YXJnZXQkMTtcbiAgICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIoKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIF90YXJnZXQuJG9mZihldmVudCwgb25jZUhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpIHtcbiAgICB0YXJnZXQkMSA9IHZtO1xuICAgIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkJDEsIHJlbW92ZSQxLCBjcmVhdGVPbmNlSGFuZGxlciQxLCB2bSk7XG4gICAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBldmVudHNNaXhpbihWdWUpIHtcbiAgICBjb25zdCBob29rUkUgPSAvXmhvb2s6LztcbiAgICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICAgICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgICAgICBpZiAoaXNBcnJheShldmVudCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdm0uJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgICAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgICAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm07XG4gICAgfTtcbiAgICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgICAgIGZ1bmN0aW9uIG9uKCkge1xuICAgICAgICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgb24uZm4gPSBmbjtcbiAgICAgICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgICAgIHJldHVybiB2bTtcbiAgICB9O1xuICAgIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICAgICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgICAgICAvLyBhbGxcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIHJldHVybiB2bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcnJheSBvZiBldmVudHNcbiAgICAgICAgaWYgKGlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZtLiRvZmYoZXZlbnRbaV0sIGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgICAgICBjb25zdCBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICAgICAgaWYgKCFjYnMpIHtcbiAgICAgICAgICAgIHJldHVybiB2bTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdm07XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgICAgICBsZXQgY2I7XG4gICAgICAgIGxldCBpID0gY2JzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY2IgPSBjYnNbaV07XG4gICAgICAgICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICAgICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZtO1xuICAgIH07XG4gICAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgICAgICAgICB0aXAoYEV2ZW50IFwiJHtsb3dlckNhc2VFdmVudH1cIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBgICtcbiAgICAgICAgICAgICAgICAgICAgYCR7Zm9ybWF0Q29tcG9uZW50TmFtZSh2bSl9IGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcIiR7ZXZlbnR9XCIuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgYCArXG4gICAgICAgICAgICAgICAgICAgIGB2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcIiR7aHlwaGVuYXRlKGV2ZW50KX1cIiBpbnN0ZWFkIG9mIFwiJHtldmVudH1cIi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgICAgIGlmIChjYnMpIHtcbiAgICAgICAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSBgZXZlbnQgaGFuZGxlciBmb3IgXCIke2V2ZW50fVwiYDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNic1tpXSwgdm0sIGFyZ3MsIHZtLCBpbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm07XG4gICAgfTtcbn1cblxubGV0IGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbmxldCBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbmZ1bmN0aW9uIHNldEFjdGl2ZUluc3RhbmNlKHZtKSB7XG4gICAgY29uc3QgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSh2bSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICAgIGxldCBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gICAgfVxuICAgIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gICAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcbiAgICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgICB2bS4kcmVmcyA9IHt9O1xuICAgIHZtLl9wcm92aWRlZCA9IHBhcmVudCA/IHBhcmVudC5fcHJvdmlkZWQgOiBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4oVnVlKSB7XG4gICAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICAgICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgICAgICBjb25zdCBwcmV2RWwgPSB2bS4kZWw7XG4gICAgICAgIGNvbnN0IHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgY29uc3QgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2Uodm0pO1xuICAgICAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAgICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgICAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgICAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyh2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdXBkYXRlc1xuICAgICAgICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgICAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICAgICAgaWYgKHByZXZFbCkge1xuICAgICAgICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bS4kZWwpIHtcbiAgICAgICAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgICAgICBsZXQgd3JhcHBlciA9IHZtO1xuICAgICAgICB3aGlsZSAod3JhcHBlciAmJlxuICAgICAgICAgICAgd3JhcHBlci4kdm5vZGUgJiZcbiAgICAgICAgICAgIHdyYXBwZXIuJHBhcmVudCAmJlxuICAgICAgICAgICAgd3JhcHBlci4kdm5vZGUgPT09IHdyYXBwZXIuJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgICAgICAgIHdyYXBwZXIuJHBhcmVudC4kZWwgPSB3cmFwcGVyLiRlbDtcbiAgICAgICAgICAgIHdyYXBwZXIgPSB3cmFwcGVyLiRwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgICAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICAgIH07XG4gICAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICAgICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICAgICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgICAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYWxsSG9vayQxKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgICAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgICAgICAgIHJlbW92ZSQyKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZWFyZG93biBzY29wZS4gdGhpcyBpbmNsdWRlcyBib3RoIHRoZSByZW5kZXIgd2F0Y2hlciBhbmQgb3RoZXJcbiAgICAgICAgLy8gd2F0Y2hlcnMgY3JlYXRlZFxuICAgICAgICB2bS5fc2NvcGUuc3RvcCgpO1xuICAgICAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgICAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICAgICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICAgICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgICAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgICAgIGNhbGxIb29rJDEodm0sICdkZXN0cm95ZWQnKTtcbiAgICAgICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICAgICAgdm0uJG9mZigpO1xuICAgICAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICAgICAgaWYgKHZtLiRlbCkge1xuICAgICAgICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbGVhc2UgY2lyY3VsYXIgcmVmZXJlbmNlICgjNjc1OSlcbiAgICAgICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQodm0sIGVsLCBoeWRyYXRpbmcpIHtcbiAgICB2bS4kZWwgPSBlbDtcbiAgICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGludmFsaWQgdHlwZVxuICAgICAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgICAgICB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgICAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHxcbiAgICAgICAgICAgICAgICBlbCkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJywgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2FybignRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsSG9vayQxKHZtLCAnYmVmb3JlTW91bnQnKTtcbiAgICBsZXQgdXBkYXRlQ29tcG9uZW50O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICB1cGRhdGVDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdm0uX25hbWU7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHZtLl91aWQ7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRhZyA9IGB2dWUtcGVyZi1zdGFydDoke2lkfWA7XG4gICAgICAgICAgICBjb25zdCBlbmRUYWcgPSBgdnVlLXBlcmYtZW5kOiR7aWR9YDtcbiAgICAgICAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICAgICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICAgICAgICBtZWFzdXJlKGB2dWUgJHtuYW1lfSByZW5kZXJgLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgICAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgICAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgICAgICAgIG1lYXN1cmUoYHZ1ZSAke25hbWV9IHBhdGNoYCwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1cGRhdGVDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgd2F0Y2hlck9wdGlvbnMgPSB7XG4gICAgICAgIGJlZm9yZSgpIHtcbiAgICAgICAgICAgIGlmICh2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICBjYWxsSG9vayQxKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHtcbiAgICAgICAgd2F0Y2hlck9wdGlvbnMub25UcmFjayA9IGUgPT4gY2FsbEhvb2skMSh2bSwgJ3JlbmRlclRyYWNrZWQnLCBbZV0pO1xuICAgICAgICB3YXRjaGVyT3B0aW9ucy5vblRyaWdnZXIgPSBlID0+IGNhbGxIb29rJDEodm0sICdyZW5kZXJUcmlnZ2VyZWQnLCBbZV0pO1xuICAgIH1cbiAgICAvLyB3ZSBzZXQgdGhpcyB0byB2bS5fd2F0Y2hlciBpbnNpZGUgdGhlIHdhdGNoZXIncyBjb25zdHJ1Y3RvclxuICAgIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXG4gICAgLy8gY29tcG9uZW50J3MgbW91bnRlZCBob29rKSwgd2hpY2ggcmVsaWVzIG9uIHZtLl93YXRjaGVyIGJlaW5nIGFscmVhZHkgZGVmaW5lZFxuICAgIG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3AsIHdhdGNoZXJPcHRpb25zLCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XG4gICAgaHlkcmF0aW5nID0gZmFsc2U7XG4gICAgLy8gZmx1c2ggYnVmZmVyIGZvciBmbHVzaDogXCJwcmVcIiB3YXRjaGVycyBxdWV1ZWQgaW4gc2V0dXAoKVxuICAgIGNvbnN0IHByZVdhdGNoZXJzID0gdm0uX3ByZVdhdGNoZXJzO1xuICAgIGlmIChwcmVXYXRjaGVycykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZVdhdGNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwcmVXYXRjaGVyc1tpXS5ydW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAgIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gICAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICBjYWxsSG9vayQxKHZtLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdm07XG59XG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCh2bSwgcHJvcHNEYXRhLCBsaXN0ZW5lcnMsIHBhcmVudFZub2RlLCByZW5kZXJDaGlsZHJlbikge1xuICAgIHtcbiAgICAgICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gICAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4uXG4gICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGR5bmFtaWMgc2NvcGVkU2xvdHMgKGhhbmQtd3JpdHRlbiBvciBjb21waWxlZCBidXQgd2l0aFxuICAgIC8vIGR5bmFtaWMgc2xvdCBuYW1lcykuIFN0YXRpYyBzY29wZWQgc2xvdHMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZSBoYXMgdGhlXG4gICAgLy8gXCIkc3RhYmxlXCIgbWFya2VyLlxuICAgIGNvbnN0IG5ld1Njb3BlZFNsb3RzID0gcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cztcbiAgICBjb25zdCBvbGRTY29wZWRTbG90cyA9IHZtLiRzY29wZWRTbG90cztcbiAgICBjb25zdCBoYXNEeW5hbWljU2NvcGVkU2xvdCA9ICEhKChuZXdTY29wZWRTbG90cyAmJiAhbmV3U2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAgICAgKG9sZFNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAmJiAhb2xkU2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAgICAgKG5ld1Njb3BlZFNsb3RzICYmIHZtLiRzY29wZWRTbG90cy4ka2V5ICE9PSBuZXdTY29wZWRTbG90cy4ka2V5KSB8fFxuICAgICAgICAoIW5ld1Njb3BlZFNsb3RzICYmIHZtLiRzY29wZWRTbG90cy4ka2V5KSk7XG4gICAgLy8gQW55IHN0YXRpYyBzbG90IGNoaWxkcmVuIGZyb20gdGhlIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGR1cmluZyBwYXJlbnQnc1xuICAgIC8vIHVwZGF0ZS4gRHluYW1pYyBzY29wZWQgc2xvdHMgbWF5IGFsc28gaGF2ZSBjaGFuZ2VkLiBJbiBzdWNoIGNhc2VzLCBhIGZvcmNlZFxuICAgIC8vIHVwZGF0ZSBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIGNvcnJlY3RuZXNzLlxuICAgIGxldCBuZWVkc0ZvcmNlVXBkYXRlID0gISEocmVuZGVyQ2hpbGRyZW4gfHwgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICAgICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8IC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgICAgIGhhc0R5bmFtaWNTY29wZWRTbG90KTtcbiAgICBjb25zdCBwcmV2Vk5vZGUgPSB2bS4kdm5vZGU7XG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gICAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcbiAgICBpZiAodm0uX3Zub2RlKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgICB9XG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG4gICAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gICAgLy8gdGhlc2UgYXJlIGFsc28gcmVhY3RpdmUgc28gdGhleSBtYXkgdHJpZ2dlciBjaGlsZCB1cGRhdGUgaWYgdGhlIGNoaWxkXG4gICAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgICBjb25zdCBhdHRycyA9IHBhcmVudFZub2RlLmRhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3Q7XG4gICAgaWYgKHZtLl9hdHRyc1Byb3h5KSB7XG4gICAgICAgIC8vIGZvcmNlIHVwZGF0ZSBpZiBhdHRycyBhcmUgYWNjZXNzZWQgYW5kIGhhcyBjaGFuZ2VkIHNpbmNlIGl0IG1heSBiZVxuICAgICAgICAvLyBwYXNzZWQgdG8gYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICAgIGlmIChzeW5jU2V0dXBQcm94eSh2bS5fYXR0cnNQcm94eSwgYXR0cnMsIChwcmV2Vk5vZGUuZGF0YSAmJiBwcmV2Vk5vZGUuZGF0YS5hdHRycykgfHwgZW1wdHlPYmplY3QsIHZtLCAnJGF0dHJzJykpIHtcbiAgICAgICAgICAgIG5lZWRzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZtLiRhdHRycyA9IGF0dHJzO1xuICAgIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG4gICAgY29uc3QgcHJldkxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgaWYgKHZtLl9saXN0ZW5lcnNQcm94eSkge1xuICAgICAgICBzeW5jU2V0dXBQcm94eSh2bS5fbGlzdGVuZXJzUHJveHksIGxpc3RlbmVycywgcHJldkxpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgdm0sICckbGlzdGVuZXJzJyk7XG4gICAgfVxuICAgIHZtLiRsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBwcmV2TGlzdGVuZXJzKTtcbiAgICAvLyB1cGRhdGUgcHJvcHNcbiAgICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgICAgIGNvbnN0IHByb3BzID0gdm0uX3Byb3BzO1xuICAgICAgICBjb25zdCBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICAgICAgICBjb25zdCBwcm9wT3B0aW9ucyA9IHZtLiRvcHRpb25zLnByb3BzOyAvLyB3dGYgZmxvdz9cbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgICAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgICB9XG4gICAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgICBpZiAobmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgICAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgICAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgICB9XG4gICAge1xuICAgICAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlKHZtKSB7XG4gICAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgICAgIGlmICh2bS5faW5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bSwgZGlyZWN0KSB7XG4gICAgaWYgKGRpcmVjdCkge1xuICAgICAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICAgICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbEhvb2skMSh2bSwgJ2FjdGl2YXRlZCcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bSwgZGlyZWN0KSB7XG4gICAgaWYgKGRpcmVjdCkge1xuICAgICAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgICAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgICAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbEhvb2skMSh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2FsbEhvb2skMSh2bSwgaG9vaywgYXJncywgc2V0Q29udGV4dCA9IHRydWUpIHtcbiAgICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgbGlmZWN5Y2xlIGhvb2tzXG4gICAgcHVzaFRhcmdldCgpO1xuICAgIGNvbnN0IHByZXYgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgc2V0Q29udGV4dCAmJiBzZXRDdXJyZW50SW5zdGFuY2Uodm0pO1xuICAgIGNvbnN0IGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gICAgY29uc3QgaW5mbyA9IGAke2hvb2t9IGhvb2tgO1xuICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlcnNbaV0sIHZtLCBhcmdzIHx8IG51bGwsIHZtLCBpbmZvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgICAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gICAgfVxuICAgIHNldENvbnRleHQgJiYgc2V0Q3VycmVudEluc3RhbmNlKHByZXYpO1xuICAgIHBvcFRhcmdldCgpO1xufVxuXG5jb25zdCBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuY29uc3QgcXVldWUgPSBbXTtcbmNvbnN0IGFjdGl2YXRlZENoaWxkcmVuID0gW107XG5sZXQgaGFzID0ge307XG5sZXQgY2lyY3VsYXIgPSB7fTtcbmxldCB3YWl0aW5nID0gZmFsc2U7XG5sZXQgZmx1c2hpbmcgPSBmYWxzZTtcbmxldCBpbmRleCA9IDA7XG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSgpIHtcbiAgICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgaGFzID0ge307XG4gICAge1xuICAgICAgICBjaXJjdWxhciA9IHt9O1xuICAgIH1cbiAgICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cbi8vIEFzeW5jIGVkZ2UgY2FzZSAjNjU2NiByZXF1aXJlcyBzYXZpbmcgdGhlIHRpbWVzdGFtcCB3aGVuIGV2ZW50IGxpc3RlbmVycyBhcmVcbi8vIGF0dGFjaGVkLiBIb3dldmVyLCBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpIGhhcyBhIHBlcmYgb3ZlcmhlYWQgZXNwZWNpYWxseVxuLy8gaWYgdGhlIHBhZ2UgaGFzIHRob3VzYW5kcyBvZiBldmVudCBsaXN0ZW5lcnMuIEluc3RlYWQsIHdlIHRha2UgYSB0aW1lc3RhbXBcbi8vIGV2ZXJ5IHRpbWUgdGhlIHNjaGVkdWxlciBmbHVzaGVzIGFuZCB1c2UgdGhhdCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVyc1xuLy8gYXR0YWNoZWQgZHVyaW5nIHRoYXQgZmx1c2guXG5sZXQgY3VycmVudEZsdXNoVGltZXN0YW1wID0gMDtcbi8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXG5sZXQgZ2V0Tm93ID0gRGF0ZS5ub3c7XG4vLyBEZXRlcm1pbmUgd2hhdCBldmVudCB0aW1lc3RhbXAgdGhlIGJyb3dzZXIgaXMgdXNpbmcuIEFubm95aW5nbHksIHRoZVxuLy8gdGltZXN0YW1wIGNhbiBlaXRoZXIgYmUgaGktcmVzIChyZWxhdGl2ZSB0byBwYWdlIGxvYWQpIG9yIGxvdy1yZXNcbi8vIChyZWxhdGl2ZSB0byBVTklYIGVwb2NoKSwgc28gaW4gb3JkZXIgdG8gY29tcGFyZSB0aW1lIHdlIGhhdmUgdG8gdXNlIHRoZVxuLy8gc2FtZSB0aW1lc3RhbXAgdHlwZSB3aGVuIHNhdmluZyB0aGUgZmx1c2ggdGltZXN0YW1wLlxuLy8gQWxsIElFIHZlcnNpb25zIHVzZSBsb3ctcmVzIGV2ZW50IHRpbWVzdGFtcHMsIGFuZCBoYXZlIHByb2JsZW1hdGljIGNsb2NrXG4vLyBpbXBsZW1lbnRhdGlvbnMgKCM5NjMyKVxuaWYgKGluQnJvd3NlciAmJiAhaXNJRSkge1xuICAgIGNvbnN0IHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlO1xuICAgIGlmIChwZXJmb3JtYW5jZSAmJlxuICAgICAgICB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIGdldE5vdygpID4gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JykudGltZVN0YW1wKSB7XG4gICAgICAgIC8vIGlmIHRoZSBldmVudCB0aW1lc3RhbXAsIGFsdGhvdWdoIGV2YWx1YXRlZCBBRlRFUiB0aGUgRGF0ZS5ub3coKSwgaXNcbiAgICAgICAgLy8gc21hbGxlciB0aGFuIGl0LCBpdCBtZWFucyB0aGUgZXZlbnQgaXMgdXNpbmcgYSBoaS1yZXMgdGltZXN0YW1wLFxuICAgICAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lciB0aW1lc3RhbXBzIGFzXG4gICAgICAgIC8vIHdlbGwuXG4gICAgICAgIGdldE5vdyA9ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH1cbn1cbmNvbnN0IHNvcnRDb21wYXJlRm4gPSAoYSwgYikgPT4ge1xuICAgIGlmIChhLnBvc3QpIHtcbiAgICAgICAgaWYgKCFiLnBvc3QpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYi5wb3N0KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIGEuaWQgLSBiLmlkO1xufTtcbi8qKlxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUoKSB7XG4gICAgY3VycmVudEZsdXNoVGltZXN0YW1wID0gZ2V0Tm93KCk7XG4gICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgIGxldCB3YXRjaGVyLCBpZDtcbiAgICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gICAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAgIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gICAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gICAgcXVldWUuc29ydChzb3J0Q29tcGFyZUZuKTtcbiAgICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICAgICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XG4gICAgICAgICAgICB3YXRjaGVyLmJlZm9yZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlkID0gd2F0Y2hlci5pZDtcbiAgICAgICAgaGFzW2lkXSA9IG51bGw7XG4gICAgICAgIHdhdGNoZXIucnVuKCk7XG4gICAgICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICAgICAgaWYgKGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICAgICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICtcbiAgICAgICAgICAgICAgICAgICAgKHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXCIke3dhdGNoZXIuZXhwcmVzc2lvbn1cImBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYGluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5gKSwgd2F0Y2hlci52bSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8ga2VlcCBjb3BpZXMgb2YgcG9zdCBxdWV1ZXMgYmVmb3JlIHJlc2V0dGluZyBzdGF0ZVxuICAgIGNvbnN0IGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgICBjb25zdCB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuICAgIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcbiAgICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICAgIGNhbGxVcGRhdGVkSG9va3ModXBkYXRlZFF1ZXVlKTtcbiAgICBjbGVhbnVwRGVwcygpO1xuICAgIC8vIGRldnRvb2wgaG9va1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzKHF1ZXVlKSB7XG4gICAgbGV0IGkgPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgICAgIGNvbnN0IHZtID0gd2F0Y2hlci52bTtcbiAgICAgICAgaWYgKHZtICYmIHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgY2FsbEhvb2skMSh2bSwgJ3VwZGF0ZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCh2bSkge1xuICAgIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xufVxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzKHF1ZXVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICAgIH1cbn1cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlcih3YXRjaGVyKSB7XG4gICAgY29uc3QgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGlmIChoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAod2F0Y2hlciA9PT0gRGVwLnRhcmdldCAmJiB3YXRjaGVyLm5vUmVjdXJzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgICAgbGV0IGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFjb25maWcuYXN5bmMpIHtcbiAgICAgICAgICAgIGZsdXNoU2NoZWR1bGVyUXVldWUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlKHZtKSB7XG4gICAgY29uc3QgcHJvdmlkZU9wdGlvbiA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gICAgaWYgKHByb3ZpZGVPcHRpb24pIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZWQgPSBpc0Z1bmN0aW9uKHByb3ZpZGVPcHRpb24pXG4gICAgICAgICAgICA/IHByb3ZpZGVPcHRpb24uY2FsbCh2bSlcbiAgICAgICAgICAgIDogcHJvdmlkZU9wdGlvbjtcbiAgICAgICAgaWYgKCFpc09iamVjdChwcm92aWRlZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2UgPSByZXNvbHZlUHJvdmlkZWQodm0pO1xuICAgICAgICAvLyBJRTkgZG9lc24ndCBzdXBwb3J0IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIHNvIHdlIGhhdmUgdG9cbiAgICAgICAgLy8gaXRlcmF0ZSB0aGUga2V5cyBvdXJzZWx2ZXMuXG4gICAgICAgIGNvbnN0IGtleXMgPSBoYXNTeW1ib2wgPyBSZWZsZWN0Lm93bktleXMocHJvdmlkZWQpIDogT2JqZWN0LmtleXMocHJvdmlkZWQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc291cmNlLCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdmlkZWQsIGtleSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnModm0pIHtcbiAgICBjb25zdCByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICAgICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlKHZtLCBrZXksIHJlc3VsdFtrZXldLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgb3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpbmplY3Rpb24gYmVpbmcgbXV0YXRlZDogXCIke2tleX1cImAsIHZtKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0KGluamVjdCwgdm0pIHtcbiAgICBpZiAoaW5qZWN0KSB7XG4gICAgICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSBoYXNTeW1ib2wgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KSA6IE9iamVjdC5rZXlzKGluamVjdCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIC8vICM2NTc0IGluIGNhc2UgdGhlIGluamVjdCBvYmplY3QgaXMgb2JzZXJ2ZWQuLi5cbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdfX29iX18nKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICAgICAgICBpZiAocHJvdmlkZUtleSBpbiB2bS5fcHJvdmlkZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZtLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGlzRnVuY3Rpb24ocHJvdmlkZURlZmF1bHQpXG4gICAgICAgICAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdhcm4oYEluamVjdGlvbiBcIiR7a2V5fVwiIG5vdCBmb3VuZGAsIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoZGF0YSwgcHJvcHMsIGNoaWxkcmVuLCBwYXJlbnQsIEN0b3IpIHtcbiAgICBjb25zdCBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gICAgbGV0IGNvbnRleHRWbTtcbiAgICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgICAgICBjb250ZXh0Vm0gPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gICAgICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyB0aGUgY29udGV4dCB2bSBwYXNzZWQgaW4gaXMgYSBmdW5jdGlvbmFsIGNvbnRleHQgYXMgd2VsbC5cbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFyZSBhYmxlIHRvIGdldCBhIGhvbGQgdG8gdGhlXG4gICAgICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICAgICAgY29udGV4dFZtID0gcGFyZW50O1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5fb3JpZ2luYWw7XG4gICAgfVxuICAgIGNvbnN0IGlzQ29tcGlsZWQgPSBpc1RydWUob3B0aW9ucy5fY29tcGlsZWQpO1xuICAgIGNvbnN0IG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMubGlzdGVuZXJzID0gZGF0YS5vbiB8fCBlbXB0eU9iamVjdDtcbiAgICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICAgIHRoaXMuc2xvdHMgPSAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy4kc2xvdHMpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKHBhcmVudCwgZGF0YS5zY29wZWRTbG90cywgKHRoaXMuJHNsb3RzID0gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuJHNsb3RzO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY29wZWRTbG90cycsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKHBhcmVudCwgZGF0YS5zY29wZWRTbG90cywgdGhpcy5zbG90cygpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgICBpZiAoaXNDb21waWxlZCkge1xuICAgICAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICAgICAgdGhpcy4kb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICAgICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgICAgIHRoaXMuJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMocGFyZW50LCBkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLiRzbG90cyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XG4gICAgICAgIHRoaXMuX2MgPSAoYSwgYiwgYywgZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVFbGVtZW50JDEoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICAgICAgICBpZiAodm5vZGUgJiYgIWlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9jID0gKGEsIGIsIGMsIGQpID0+IGNyZWF0ZUVsZW1lbnQkMShjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICB9XG59XG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHRWbSwgY2hpbGRyZW4pIHtcbiAgICBjb25zdCBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIGNvbnN0IHByb3BzID0ge307XG4gICAgY29uc3QgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICAgIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IGVtcHR5T2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKVxuICAgICAgICAgICAgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSlcbiAgICAgICAgICAgIG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpO1xuICAgIH1cbiAgICBjb25zdCByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KGRhdGEsIHByb3BzLCBjaGlsZHJlbiwgY29udGV4dFZtLCBDdG9yKTtcbiAgICBjb25zdCB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG4gICAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGUsIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgY29uc3Qgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgY29udGV4dFZtLCBvcHRpb25zLCByZW5kZXJDb250ZXh0KSB7XG4gICAgLy8gIzc4MTcgY2xvbmUgbm9kZSBiZWZvcmUgc2V0dGluZyBmbkNvbnRleHQsIG90aGVyd2lzZSBpZiB0aGUgbm9kZSBpcyByZXVzZWRcbiAgICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcbiAgICAvLyB0aGF0IHNob3VsZCBub3QgYmUgbWF0Y2hlZCB0byBtYXRjaC5cbiAgICBjb25zdCBjbG9uZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgICBjbG9uZS5mbk9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHtcbiAgICAgICAgKGNsb25lLmRldnRvb2xzTWV0YSA9IGNsb25lLmRldnRvb2xzTWV0YSB8fCB7fSkucmVuZGVyQ29udGV4dCA9XG4gICAgICAgICAgICByZW5kZXJDb250ZXh0O1xuICAgIH1cbiAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG59XG5mdW5jdGlvbiBtZXJnZVByb3BzKHRvLCBmcm9tKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgICAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fX25hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xufVxuLy8gaW5saW5lIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbmNvbnN0IGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gICAgaW5pdCh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgICAgIGlmICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxuICAgICAgICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgICAgICAgY29uc3QgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKHZub2RlLCBhY3RpdmVJbnN0YW5jZSkpO1xuICAgICAgICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcHJlcGF0Y2gob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICBjb25zdCBjaGlsZCA9ICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoY2hpbGQsIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICAgICApO1xuICAgIH0sXG4gICAgaW5zZXJ0KHZub2RlKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGV4dCwgY29tcG9uZW50SW5zdGFuY2UgfSA9IHZub2RlO1xuICAgICAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2FsbEhvb2skMShjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgICAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAgICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3kodm5vZGUpIHtcbiAgICAgICAgY29uc3QgeyBjb21wb25lbnRJbnN0YW5jZSB9ID0gdm5vZGU7XG4gICAgICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpIHtcbiAgICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcbiAgICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICAgICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgICB9XG4gICAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAgIC8vIHJlamVjdC5cbiAgICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAge1xuICAgICAgICAgICAgd2FybihgSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogJHtTdHJpbmcoQ3Rvcil9YCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBhc3luYyBjb21wb25lbnRcbiAgICBsZXQgYXN5bmNGYWN0b3J5O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICAgICAgYXN5bmNGYWN0b3J5ID0gQ3RvcjtcbiAgICAgICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yKTtcbiAgICAgICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgbm9kZSBmb3IgYXN5bmMgY29tcG9uZW50LCB3aGljaCBpcyByZW5kZXJlZFxuICAgICAgICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXG4gICAgICAgICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihhc3luY0ZhY3RvcnksIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuICAgIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuICAgIH1cbiAgICAvLyBleHRyYWN0IHByb3BzXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGNvbnN0IHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcbiAgICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IGRhdGEub247XG4gICAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgICAvLyBzbyBpdCBnZXRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyZW50IGNvbXBvbmVudCBwYXRjaC5cbiAgICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAgICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcbiAgICAgICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgICBjb25zdCBzbG90ID0gZGF0YS5zbG90O1xuICAgICAgICBkYXRhID0ge307XG4gICAgICAgIGlmIChzbG90KSB7XG4gICAgICAgICAgICBkYXRhLnNsb3QgPSBzbG90O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGluc3RhbGwgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICAgIGluc3RhbGxDb21wb25lbnRIb29rcyhkYXRhKTtcbiAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDdG9yLm9wdGlvbnMpIHx8IHRhZztcbiAgICBjb25zdCB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgYHZ1ZS1jb21wb25lbnQtJHtDdG9yLmNpZH0ke25hbWUgPyBgLSR7bmFtZX1gIDogJyd9YCwgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCwgXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHsgQ3RvciwgcHJvcHNEYXRhLCBsaXN0ZW5lcnMsIHRhZywgY2hpbGRyZW4gfSwgYXN5bmNGYWN0b3J5KTtcbiAgICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG52bm9kZSwgXG4vLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbnBhcmVudCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICAgICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICAgICAgcGFyZW50XG4gICAgfTtcbiAgICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICAgIGNvbnN0IGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucyk7XG59XG5mdW5jdGlvbiBpbnN0YWxsQ29tcG9uZW50SG9va3MoZGF0YSkge1xuICAgIGNvbnN0IGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IGhvb2tzW2tleV07XG4gICAgICAgIGNvbnN0IHRvTWVyZ2UgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgaWYgKGV4aXN0aW5nICE9PSB0b01lcmdlICYmICEoZXhpc3RpbmcgJiYgZXhpc3RpbmcuX21lcmdlZCkpIHtcbiAgICAgICAgICAgIGhvb2tzW2tleV0gPSBleGlzdGluZyA/IG1lcmdlSG9vayh0b01lcmdlLCBleGlzdGluZykgOiB0b01lcmdlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWVyZ2VIb29rKGYxLCBmMikge1xuICAgIGNvbnN0IG1lcmdlZCA9IChhLCBiKSA9PiB7XG4gICAgICAgIC8vIGZsb3cgY29tcGxhaW5zIGFib3V0IGV4dHJhIGFyZ3Mgd2hpY2ggaXMgd2h5IHdlIHVzZSBhbnlcbiAgICAgICAgZjEoYSwgYik7XG4gICAgICAgIGYyKGEsIGIpO1xuICAgIH07XG4gICAgbWVyZ2VkLl9tZXJnZWQgPSB0cnVlO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsKG9wdGlvbnMsIGRhdGEpIHtcbiAgICBjb25zdCBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICAgIGNvbnN0IGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JztcbiAgICAoZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICAgIGNvbnN0IG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICBjb25zdCBleGlzdGluZyA9IG9uW2V2ZW50XTtcbiAgICBjb25zdCBjYWxsYmFjayA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gICAgaWYgKGlzRGVmKGV4aXN0aW5nKSkge1xuICAgICAgICBpZiAoaXNBcnJheShleGlzdGluZylcbiAgICAgICAgICAgID8gZXhpc3RpbmcuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xXG4gICAgICAgICAgICA6IGV4aXN0aW5nICE9PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgb25bZXZlbnRdID0gW2NhbGxiYWNrXS5jb25jYXQoZXhpc3RpbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvbltldmVudF0gPSBjYWxsYmFjaztcbiAgICB9XG59XG5cbmxldCB3YXJuID0gbm9vcDtcbmxldCB0aXAgPSBub29wO1xubGV0IGdlbmVyYXRlQ29tcG9uZW50VHJhY2U7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbmxldCBmb3JtYXRDb21wb25lbnROYW1lO1xue1xuICAgIGNvbnN0IGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgY29uc3QgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgICBjb25zdCBjbGFzc2lmeSA9IHN0ciA9PiBzdHIucmVwbGFjZShjbGFzc2lmeVJFLCBjID0+IGMudG9VcHBlckNhc2UoKSkucmVwbGFjZSgvWy1fXS9nLCAnJyk7XG4gICAgd2FybiA9IChtc2csIHZtID0gY3VycmVudEluc3RhbmNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xuICAgICAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICAgICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAhY29uZmlnLnNpbGVudCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW1Z1ZSB3YXJuXTogJHttc2d9JHt0cmFjZX1gKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGlwID0gKG1zZywgdm0pID0+IHtcbiAgICAgICAgaWYgKGhhc0NvbnNvbGUgJiYgIWNvbmZpZy5zaWxlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW1Z1ZSB0aXBdOiAke21zZ31gICsgKHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3JtYXRDb21wb25lbnROYW1lID0gKHZtLCBpbmNsdWRlRmlsZSkgPT4ge1xuICAgICAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxSb290Pic7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGlzRnVuY3Rpb24odm0pICYmIHZtLmNpZCAhPSBudWxsXG4gICAgICAgICAgICA/IHZtLm9wdGlvbnNcbiAgICAgICAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgICAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgICAgICAgICAgOiB2bTtcbiAgICAgICAgbGV0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKG5hbWUgPyBgPCR7Y2xhc3NpZnkobmFtZSl9PmAgOiBgPEFub255bW91cz5gKSArXG4gICAgICAgICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyBgIGF0ICR7ZmlsZX1gIDogJycpKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlcGVhdCA9IChzdHIsIG4pID0+IHtcbiAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICB3aGlsZSAobikge1xuICAgICAgICAgICAgaWYgKG4gJSAyID09PSAxKVxuICAgICAgICAgICAgICAgIHJlcyArPSBzdHI7XG4gICAgICAgICAgICBpZiAobiA+IDEpXG4gICAgICAgICAgICAgICAgc3RyICs9IHN0cjtcbiAgICAgICAgICAgIG4gPj49IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAodm0pID0+IHtcbiAgICAgICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0cmVlID0gW107XG4gICAgICAgICAgICBsZXQgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICAgICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArXG4gICAgICAgICAgICAgICAgdHJlZVxuICAgICAgICAgICAgICAgICAgICAubWFwKCh2bSwgaSkgPT4gYCR7aSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpfSR7aXNBcnJheSh2bSlcbiAgICAgICAgICAgICAgICAgICAgPyBgJHtmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKX0uLi4gKCR7dm1bMV19IHJlY3Vyc2l2ZSBjYWxscylgXG4gICAgICAgICAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSl9YClcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgXFxuXFxuKGZvdW5kIGluICR7Zm9ybWF0Q29tcG9uZW50TmFtZSh2bSl9KWA7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xuY29uc3Qgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG57XG4gICAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgICAgIGlmICghdm0pIHtcbiAgICAgICAgICAgIHdhcm4oYG9wdGlvbiBcIiR7a2V5fVwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIGAgK1xuICAgICAgICAgICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZCk7XG4gICAgfTtcbn1cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSh0bywgZnJvbSwgcmVjdXJzaXZlID0gdHJ1ZSkge1xuICAgIGlmICghZnJvbSlcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIGxldCBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICAgIGNvbnN0IGtleXMgPSBoYXNTeW1ib2xcbiAgICAgICAgPyBSZWZsZWN0Lm93bktleXMoZnJvbSlcbiAgICAgICAgOiBPYmplY3Qua2V5cyhmcm9tKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgb2JzZXJ2ZWQuLi5cbiAgICAgICAgaWYgKGtleSA9PT0gJ19fb2JfXycpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdG9WYWwgPSB0b1trZXldO1xuICAgICAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgICAgICBpZiAoIXJlY3Vyc2l2ZSB8fCAhaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICAgICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG9WYWwgIT09IGZyb21WYWwgJiZcbiAgICAgICAgICAgIGlzUGxhaW5PYmplY3QodG9WYWwpICYmXG4gICAgICAgICAgICBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICAgICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0bztcbn1cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgICAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50VmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRWYWw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAgICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgICAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbigpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXJnZURhdGEoaXNGdW5jdGlvbihjaGlsZFZhbCkgPyBjaGlsZFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogY2hpbGRWYWwsIGlzRnVuY3Rpb24ocGFyZW50VmFsKSA/IHBhcmVudFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogcGFyZW50VmFsKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbigpIHtcbiAgICAgICAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZURhdGEgPSBpc0Z1bmN0aW9uKGNoaWxkVmFsKVxuICAgICAgICAgICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgICAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHREYXRhID0gaXNGdW5jdGlvbihwYXJlbnRWYWwpXG4gICAgICAgICAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgICAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0RGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgd2FybignVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICAgICAgICAgICAgICdkZWZpbml0aW9ucy4nLCB2bSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50VmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSk7XG59O1xuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlTGlmZWN5Y2xlSG9vayhwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgY29uc3QgcmVzID0gY2hpbGRWYWxcbiAgICAgICAgPyBwYXJlbnRWYWxcbiAgICAgICAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgICAgICAgIDogaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgICAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgICAgIDogcGFyZW50VmFsO1xuICAgIHJldHVybiByZXMgPyBkZWR1cGVIb29rcyhyZXMpIDogcmVzO1xufVxuZnVuY3Rpb24gZGVkdXBlSG9va3MoaG9va3MpIHtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZXMuaW5kZXhPZihob29rc1tpXSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXMucHVzaChob29rc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGhvb2sgPT4ge1xuICAgIHN0cmF0c1tob29rXSA9IG1lcmdlTGlmZWN5Y2xlSG9vaztcbn0pO1xuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0sIGtleSkge1xuICAgIGNvbnN0IHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICAgIGlmIChjaGlsZFZhbCkge1xuICAgICAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0sIGtleSkge1xuICAgIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gICAgLy9AdHMtZXhwZWN0LWVycm9yIHdvcmsgYXJvdW5kXG4gICAgaWYgKHBhcmVudFZhbCA9PT0gbmF0aXZlV2F0Y2gpXG4gICAgICAgIHBhcmVudFZhbCA9IHVuZGVmaW5lZDtcbiAgICAvL0B0cy1leHBlY3QtZXJyb3Igd29yayBhcm91bmRcbiAgICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKVxuICAgICAgICBjaGlsZFZhbCA9IHVuZGVmaW5lZDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkVmFsKVxuICAgICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gICAge1xuICAgICAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpXG4gICAgICAgIHJldHVybiBjaGlsZFZhbDtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSByZXRba2V5XTtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuICAgICAgICBpZiAocGFyZW50ICYmICFpc0FycmF5KHBhcmVudCkpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgICAgICB9XG4gICAgICAgIHJldFtrZXldID0gcGFyZW50ID8gcGFyZW50LmNvbmNhdChjaGlsZCkgOiBpc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG4gICAgc3RyYXRzLm1ldGhvZHMgPVxuICAgICAgICBzdHJhdHMuaW5qZWN0ID1cbiAgICAgICAgICAgIHN0cmF0cy5jb21wdXRlZCA9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkVmFsICYmIHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50VmFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkVmFsO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRWYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmQocmV0LCBjaGlsZFZhbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfTtcbnN0cmF0cy5wcm92aWRlID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICBpZiAoIXBhcmVudFZhbClcbiAgICAgICAgcmV0dXJuIGNoaWxkVmFsO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIG1lcmdlRGF0YShyZXQsIGlzRnVuY3Rpb24ocGFyZW50VmFsKSA/IHBhcmVudFZhbC5jYWxsKHRoaXMpIDogcGFyZW50VmFsKTtcbiAgICAgICAgaWYgKGNoaWxkVmFsKSB7XG4gICAgICAgICAgICBtZXJnZURhdGEocmV0LCBpc0Z1bmN0aW9uKGNoaWxkVmFsKSA/IGNoaWxkVmFsLmNhbGwodGhpcykgOiBjaGlsZFZhbCwgZmFsc2UgLy8gbm9uLXJlY3Vyc2l2ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59O1xuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG5jb25zdCBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkID8gcGFyZW50VmFsIDogY2hpbGRWYWw7XG59O1xuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzKG9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUpIHtcbiAgICBpZiAoIW5ldyBSZWdFeHAoYF5bYS16QS1aXVtcXFxcLVxcXFwuMC05XyR7dW5pY29kZVJlZ0V4cC5zb3VyY2V9XSokYCkudGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuKCdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgK1xuICAgICAgICAgICAgbmFtZSArXG4gICAgICAgICAgICAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICAgICAgICdzaG91bGQgY29uZm9ybSB0byB2YWxpZCBjdXN0b20gZWxlbWVudCBuYW1lIGluIGh0bWw1IHNwZWNpZmljYXRpb24uJyk7XG4gICAgfVxuICAgIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICAgICAgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAgICdpZDogJyArXG4gICAgICAgICAgICBuYW1lKTtcbiAgICB9XG59XG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMob3B0aW9ucywgdm0pIHtcbiAgICBjb25zdCBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gICAgaWYgKCFwcm9wcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGxldCBpLCB2YWwsIG5hbWU7XG4gICAgaWYgKGlzQXJyYXkocHJvcHMpKSB7XG4gICAgICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgICAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKSA/IHZhbCA6IHsgdHlwZTogdmFsIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdhcm4oYEludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcInByb3BzXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgYCArXG4gICAgICAgICAgICBgYnV0IGdvdCAke3RvUmF3VHlwZShwcm9wcyl9LmAsIHZtKTtcbiAgICB9XG4gICAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3Qob3B0aW9ucywgdm0pIHtcbiAgICBjb25zdCBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgICBpZiAoIWluamVjdClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSAob3B0aW9ucy5pbmplY3QgPSB7fSk7XG4gICAgaWYgKGlzQXJyYXkoaW5qZWN0KSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbm9ybWFsaXplZFtpbmplY3RbaV1dID0geyBmcm9tOiBpbmplY3RbaV0gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5qZWN0KSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICAgICAgICAgID8gZXh0ZW5kKHsgZnJvbToga2V5IH0sIHZhbClcbiAgICAgICAgICAgICAgICA6IHsgZnJvbTogdmFsIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdhcm4oYEludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcImluamVjdFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIGAgK1xuICAgICAgICAgICAgYGJ1dCBnb3QgJHt0b1Jhd1R5cGUoaW5qZWN0KX0uYCwgdm0pO1xuICAgIH1cbn1cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9wdGlvbnMpIHtcbiAgICBjb25zdCBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICAgIGlmIChkaXJzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRpcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZiA9IGRpcnNba2V5XTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGRlZikpIHtcbiAgICAgICAgICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUobmFtZSwgdmFsdWUsIHZtKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB3YXJuKGBJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXCIke25hbWV9XCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgYCArXG4gICAgICAgICAgICBgYnV0IGdvdCAke3RvUmF3VHlwZSh2YWx1ZSl9LmAsIHZtKTtcbiAgICB9XG59XG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLCB2bSkge1xuICAgIHtcbiAgICAgICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24oY2hpbGQpKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICAgIH1cbiAgICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xuICAgIG5vcm1hbGl6ZUluamVjdChjaGlsZCwgdm0pO1xuICAgIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShjaGlsZCk7XG4gICAgLy8gQXBwbHkgZXh0ZW5kcyBhbmQgbWl4aW5zIG9uIHRoZSBjaGlsZCBvcHRpb25zLFxuICAgIC8vIGJ1dCBvbmx5IGlmIGl0IGlzIGEgcmF3IG9wdGlvbnMgb2JqZWN0IHRoYXQgaXNuJ3RcbiAgICAvLyB0aGUgcmVzdWx0IG9mIGFub3RoZXIgbWVyZ2VPcHRpb25zIGNhbGwuXG4gICAgLy8gT25seSBtZXJnZWQgb3B0aW9ucyBoYXMgdGhlIF9iYXNlIHByb3BlcnR5LlxuICAgIGlmICghY2hpbGQuX2Jhc2UpIHtcbiAgICAgICAgaWYgKGNoaWxkLmV4dGVuZHMpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLmV4dGVuZHMsIHZtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgbGV0IGtleTtcbiAgICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgICAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgICAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJnZUZpZWxkKGtleSkge1xuICAgICAgICBjb25zdCBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICAgICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQob3B0aW9ucywgdHlwZSwgaWQsIHdhcm5NaXNzaW5nKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAgIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gICAgaWYgKGhhc093bihhc3NldHMsIGlkKSlcbiAgICAgICAgcmV0dXJuIGFzc2V0c1tpZF07XG4gICAgY29uc3QgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gICAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSlcbiAgICAgICAgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF07XG4gICAgY29uc3QgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gICAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpXG4gICAgICAgIHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgICBjb25zdCByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gICAgaWYgKHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICAgICAgd2FybignRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pIHtcbiAgICBjb25zdCBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgICBjb25zdCBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgICBsZXQgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgICAvLyBib29sZWFuIGNhc3RpbmdcbiAgICBjb25zdCBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcbiAgICAgICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkge1xuICAgICAgICAgICAgLy8gb25seSBjYXN0IGVtcHR5IHN0cmluZyAvIHNhbWUgbmFtZSB0byBib29sZWFuIGlmXG4gICAgICAgICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgICAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAgICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICAgICAgY29uc3QgcHJldlNob3VsZE9ic2VydmUgPSBzaG91bGRPYnNlcnZlO1xuICAgICAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgICAgIG9ic2VydmUodmFsdWUpO1xuICAgICAgICB0b2dnbGVPYnNlcnZpbmcocHJldlNob3VsZE9ic2VydmUpO1xuICAgIH1cbiAgICB7XG4gICAgICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KSB7XG4gICAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAgIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgICBpZiAoaXNPYmplY3QoZGVmKSkge1xuICAgICAgICB3YXJuKCdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICtcbiAgICAgICAgICAgIGtleSArXG4gICAgICAgICAgICAnXCI6ICcgK1xuICAgICAgICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLCB2bSk7XG4gICAgfVxuICAgIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gICAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gICAgaWYgKHZtICYmXG4gICAgICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgICAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZtLl9wcm9wc1trZXldO1xuICAgIH1cbiAgICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAgIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgICByZXR1cm4gaXNGdW5jdGlvbihkZWYpICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgICAgICA/IGRlZi5jYWxsKHZtKVxuICAgICAgICA6IGRlZjtcbn1cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wKHByb3AsIG5hbWUsIHZhbHVlLCB2bSwgYWJzZW50KSB7XG4gICAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgICAgIHdhcm4oJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsIHZtKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB0eXBlID0gcHJvcC50eXBlO1xuICAgIGxldCB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICAgIGlmICghaXNBcnJheSh0eXBlKSkge1xuICAgICAgICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldLCB2bSk7XG4gICAgICAgICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICAgICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoYXZlRXhwZWN0ZWRUeXBlcyA9IGV4cGVjdGVkVHlwZXMuc29tZSh0ID0+IHQpO1xuICAgIGlmICghdmFsaWQgJiYgaGF2ZUV4cGVjdGVkVHlwZXMpIHtcbiAgICAgICAgd2FybihnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpLCB2bSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLCB2bSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbHxCaWdJbnQpJC87XG5mdW5jdGlvbiBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlLCB2bSkge1xuICAgIGxldCB2YWxpZDtcbiAgICBjb25zdCBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICAgIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgICAgICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xuICAgICAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgICAgICB2YWxpZCA9IGlzQXJyYXkodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB3YXJuKCdJbnZhbGlkIHByb3AgdHlwZTogXCInICsgU3RyaW5nKHR5cGUpICsgJ1wiIGlzIG5vdCBhIGNvbnN0cnVjdG9yJywgdm0pO1xuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZCxcbiAgICAgICAgZXhwZWN0ZWRUeXBlXG4gICAgfTtcbn1cbmNvbnN0IGZ1bmN0aW9uVHlwZUNoZWNrUkUgPSAvXlxccypmdW5jdGlvbiAoXFx3KykvO1xuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZShmbikge1xuICAgIGNvbnN0IG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaChmdW5jdGlvblR5cGVDaGVja1JFKTtcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnO1xufVxuZnVuY3Rpb24gaXNTYW1lVHlwZShhLCBiKSB7XG4gICAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYik7XG59XG5mdW5jdGlvbiBnZXRUeXBlSW5kZXgodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xuICAgIGlmICghaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xuICAgICAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGV4cGVjdGVkVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlc1tpXSwgdHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcykge1xuICAgIGxldCBtZXNzYWdlID0gYEludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCIke25hbWV9XCIuYCArXG4gICAgICAgIGAgRXhwZWN0ZWQgJHtleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpfWA7XG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcbiAgICBjb25zdCByZWNlaXZlZFR5cGUgPSB0b1Jhd1R5cGUodmFsdWUpO1xuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSBleHBlY3RlZCB2YWx1ZVxuICAgIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJlxuICAgICAgICBpc0V4cGxpY2FibGUodHlwZW9mIHZhbHVlKSAmJlxuICAgICAgICAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKSkge1xuICAgICAgICBtZXNzYWdlICs9IGAgd2l0aCB2YWx1ZSAke3N0eWxlVmFsdWUodmFsdWUsIGV4cGVjdGVkVHlwZSl9YDtcbiAgICB9XG4gICAgbWVzc2FnZSArPSBgLCBnb3QgJHtyZWNlaXZlZFR5cGV9IGA7XG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IHJlY2VpdmVkIHZhbHVlXG4gICAgaWYgKGlzRXhwbGljYWJsZShyZWNlaXZlZFR5cGUpKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYHdpdGggdmFsdWUgJHtzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpfS5gO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbn1cbmZ1bmN0aW9uIHN0eWxlVmFsdWUodmFsdWUsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gJ1N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnTnVtYmVyJykge1xuICAgICAgICByZXR1cm4gYCR7TnVtYmVyKHZhbHVlKX1gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAke3ZhbHVlfWA7XG4gICAgfVxufVxuY29uc3QgRVhQTElDQUJMRV9UWVBFUyA9IFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ107XG5mdW5jdGlvbiBpc0V4cGxpY2FibGUodmFsdWUpIHtcbiAgICByZXR1cm4gRVhQTElDQUJMRV9UWVBFUy5zb21lKGVsZW0gPT4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbSk7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW4oLi4uYXJncykge1xuICAgIHJldHVybiBhcmdzLnNvbWUoZWxlbSA9PiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJyk7XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xubGV0IGluaXRQcm94eTtcbntcbiAgICBjb25zdCBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAgICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQsJyArXG4gICAgICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICAgKTtcbiAgICBjb25zdCB3YXJuTm9uUHJlc2VudCA9ICh0YXJnZXQsIGtleSkgPT4ge1xuICAgICAgICB3YXJuKGBQcm9wZXJ0eSBvciBtZXRob2QgXCIke2tleX1cIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IGAgK1xuICAgICAgICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXG4gICAgICAgICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xuICAgICAgICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xuICAgICAgICAgICAgJ1NlZTogaHR0cHM6Ly92Mi52dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsIHRhcmdldCk7XG4gICAgfTtcbiAgICBjb25zdCB3YXJuUmVzZXJ2ZWRQcmVmaXggPSAodGFyZ2V0LCBrZXkpID0+IHtcbiAgICAgICAgd2FybihgUHJvcGVydHkgXCIke2tleX1cIiBtdXN0IGJlIGFjY2Vzc2VkIHdpdGggXCIkZGF0YS4ke2tleX1cIiBiZWNhdXNlIGAgK1xuICAgICAgICAgICAgJ3Byb3BlcnRpZXMgc3RhcnRpbmcgd2l0aCBcIiRcIiBvciBcIl9cIiBhcmUgbm90IHByb3hpZWQgaW4gdGhlIFZ1ZSBpbnN0YW5jZSB0byAnICtcbiAgICAgICAgICAgICdwcmV2ZW50IGNvbmZsaWN0cyB3aXRoIFZ1ZSBpbnRlcm5hbHMuICcgK1xuICAgICAgICAgICAgJ1NlZTogaHR0cHM6Ly92Mi52dWVqcy5vcmcvdjIvYXBpLyNkYXRhJywgdGFyZ2V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGhhc1Byb3h5ID0gdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAgIGNvbnN0IGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCcpO1xuICAgICAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICAgICAgICBzZXQodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuJHtrZXl9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGhhc0hhbmRsZXIgPSB7XG4gICAgICAgIGhhcyh0YXJnZXQsIGtleSkge1xuICAgICAgICAgICAgY29uc3QgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAga2V5LmNoYXJBdCgwKSA9PT0gJ18nICYmXG4gICAgICAgICAgICAgICAgICAgICEoa2V5IGluIHRhcmdldC4kZGF0YSkpO1xuICAgICAgICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0LiRkYXRhKVxuICAgICAgICAgICAgICAgICAgICB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXRIYW5kbGVyID0ge1xuICAgICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpXG4gICAgICAgICAgICAgICAgICAgIHdhcm5SZXNlcnZlZFByZWZpeCh0YXJnZXQsIGtleSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSh2bSkge1xuICAgICAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkID8gZ2V0SGFuZGxlciA6IGhhc0hhbmRsZXI7XG4gICAgICAgICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuY29uc3Qgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogbm9vcCxcbiAgICBzZXQ6IG5vb3Bcbn07XG5mdW5jdGlvbiBwcm94eSh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV07XG4gICAgfTtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIodmFsKSB7XG4gICAgICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuZnVuY3Rpb24gaW5pdFN0YXRlKHZtKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZtLiRvcHRpb25zO1xuICAgIGlmIChvcHRzLnByb3BzKVxuICAgICAgICBpbml0UHJvcHMkMSh2bSwgb3B0cy5wcm9wcyk7XG4gICAgLy8gQ29tcG9zaXRpb24gQVBJXG4gICAgaW5pdFNldHVwKHZtKTtcbiAgICBpZiAob3B0cy5tZXRob2RzKVxuICAgICAgICBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTtcbiAgICBpZiAob3B0cy5kYXRhKSB7XG4gICAgICAgIGluaXREYXRhKHZtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG9iID0gb2JzZXJ2ZSgodm0uX2RhdGEgPSB7fSkpO1xuICAgICAgICBvYiAmJiBvYi52bUNvdW50Kys7XG4gICAgfVxuICAgIGlmIChvcHRzLmNvbXB1dGVkKVxuICAgICAgICBpbml0Q29tcHV0ZWQkMSh2bSwgb3B0cy5jb21wdXRlZCk7XG4gICAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICAgICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbml0UHJvcHMkMSh2bSwgcHJvcHNPcHRpb25zKSB7XG4gICAgY29uc3QgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICAgIGNvbnN0IHByb3BzID0gKHZtLl9wcm9wcyA9IHNoYWxsb3dSZWFjdGl2ZSh7fSkpO1xuICAgIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gICAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gICAgY29uc3Qga2V5cyA9ICh2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXSk7XG4gICAgY29uc3QgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gICAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gICAgaWYgKCFpc1Jvb3QpIHtcbiAgICAgICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHNPcHRpb25zKSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XG4gICAgICAgICAgICAgICAgd2FybihgXCIke2h5cGhlbmF0ZWRLZXl9XCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLmAsIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Jvb3QgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgb3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYHZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFwiJHtrZXl9XCJgLCB2bSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgICAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxuICAgICAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgICAgICAgIHByb3h5KHZtLCBgX3Byb3BzYCwga2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG59XG5mdW5jdGlvbiBpbml0RGF0YSh2bSkge1xuICAgIGxldCBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgICBkYXRhID0gdm0uX2RhdGEgPSBpc0Z1bmN0aW9uKGRhdGEpID8gZ2V0RGF0YShkYXRhLCB2bSkgOiBkYXRhIHx8IHt9O1xuICAgIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgICBkYXRhID0ge307XG4gICAgICAgIHdhcm4oJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgICAgICAgICAgICdodHRwczovL3YyLnZ1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLCB2bSk7XG4gICAgfVxuICAgIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgY29uc3QgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgICBjb25zdCBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKG1ldGhvZHMgJiYgaGFzT3duKG1ldGhvZHMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBNZXRob2QgXCIke2tleX1cIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LmAsIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgICAgICB3YXJuKGBUaGUgZGF0YSBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYFVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5gLCB2bSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICAgICAgcHJveHkodm0sIGBfZGF0YWAsIGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gb2JzZXJ2ZSBkYXRhXG4gICAgY29uc3Qgb2IgPSBvYnNlcnZlKGRhdGEpO1xuICAgIG9iICYmIG9iLnZtQ291bnQrKztcbn1cbmZ1bmN0aW9uIGdldERhdGEoZGF0YSwgdm0pIHtcbiAgICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgZGF0YSBnZXR0ZXJzXG4gICAgcHVzaFRhcmdldCgpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIGBkYXRhKClgKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgfVxufVxuY29uc3QgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEodm0sIGNvbXB1dGVkKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgY29uc3Qgd2F0Y2hlcnMgPSAodm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBqdXN0IGdldHRlcnMgZHVyaW5nIFNTUlxuICAgIGNvbnN0IGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wdXRlZCkge1xuICAgICAgICBjb25zdCB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICAgICAgY29uc3QgZ2V0dGVyID0gaXNGdW5jdGlvbih1c2VyRGVmKSA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICAgICAgaWYgKGdldHRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICB3YXJuKGBHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIi5gLCB2bSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1NTUikge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgICAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcih2bSwgZ2V0dGVyIHx8IG5vb3AsIG5vb3AsIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAgICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAgICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgICAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICAgICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBUaGUgY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5gLCB2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBUaGUgY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLmAsIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZtLiRvcHRpb25zLm1ldGhvZHMgJiYga2V5IGluIHZtLiRvcHRpb25zLm1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBUaGUgY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBtZXRob2QuYCwgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQodGFyZ2V0LCBrZXksIHVzZXJEZWYpIHtcbiAgICBjb25zdCBzaG91bGRDYWNoZSA9ICFpc1NlcnZlclJlbmRlcmluZygpO1xuICAgIGlmIChpc0Z1bmN0aW9uKHVzZXJEZWYpKSB7XG4gICAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZik7XG4gICAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICAgICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYuZ2V0KVxuICAgICAgICAgICAgOiBub29wO1xuICAgICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXQgfHwgbm9vcDtcbiAgICB9XG4gICAgaWYgKHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdhcm4oYENvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLmAsIHRoaXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIoKSB7XG4gICAgICAgIGNvbnN0IHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICAgICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgICAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoRGVwLnRhcmdldC5vblRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIERlcC50YXJnZXQub25UcmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3Q6IERlcC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImdldFwiIC8qIFRyYWNrT3BUeXBlcy5HRVQgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVHZXR0ZXJJbnZva2VyKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyKCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaW5pdE1ldGhvZHModm0sIG1ldGhvZHMpIHtcbiAgICBjb25zdCBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1ldGhvZHMpIHtcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBNZXRob2QgXCIke2tleX1cIiBoYXMgdHlwZSBcIiR7dHlwZW9mIG1ldGhvZHNba2V5XX1cIiBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIGAgK1xuICAgICAgICAgICAgICAgICAgICBgRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9gLCB2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgd2FybihgTWV0aG9kIFwiJHtrZXl9XCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5gLCB2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5IGluIHZtICYmIGlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICAgICAgICAgIHdhcm4oYE1ldGhvZCBcIiR7a2V5fVwiIGNvbmZsaWN0cyB3aXRoIGFuIGV4aXN0aW5nIFZ1ZSBpbnN0YW5jZSBtZXRob2QuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2bVtrZXldID0gdHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJyA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluaXRXYXRjaCh2bSwgd2F0Y2gpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB3YXRjaCkge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICAgICAgaWYgKGlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgICAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgICB9XG4gICAgcmV0dXJuIHZtLiR3YXRjaChleHBPckZuLCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHN0YXRlTWl4aW4oVnVlKSB7XG4gICAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gICAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gICAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICAgIGNvbnN0IGRhdGFEZWYgPSB7fTtcbiAgICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfTtcbiAgICBjb25zdCBwcm9wc0RlZiA9IHt9O1xuICAgIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BzO1xuICAgIH07XG4gICAge1xuICAgICAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdhcm4oJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcbiAgICAgICAgICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2FybihgJHByb3BzIGlzIHJlYWRvbmx5LmAsIHRoaXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG4gICAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICAgIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcbiAgICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChleHBPckZuLCBjYiwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IGBjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXCIke3dhdGNoZXIuZXhwcmVzc2lvbn1cImA7XG4gICAgICAgICAgICBwdXNoVGFyZ2V0KCk7XG4gICAgICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYiwgdm0sIFt3YXRjaGVyLnZhbHVlXSwgdm0sIGluZm8pO1xuICAgICAgICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbigpIHtcbiAgICAgICAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG5sZXQgdWlkID0gMDtcbmZ1bmN0aW9uIGluaXRNaXhpbiQxKFZ1ZSkge1xuICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgICAgIC8vIGEgdWlkXG4gICAgICAgIHZtLl91aWQgPSB1aWQrKztcbiAgICAgICAgbGV0IHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgICAgIHN0YXJ0VGFnID0gYHZ1ZS1wZXJmLXN0YXJ0OiR7dm0uX3VpZH1gO1xuICAgICAgICAgICAgZW5kVGFnID0gYHZ1ZS1wZXJmLWVuZDoke3ZtLl91aWR9YDtcbiAgICAgICAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGEgZmxhZyB0byBtYXJrIHRoaXMgYXMgYSBWdWUgaW5zdGFuY2Ugd2l0aG91dCBoYXZpbmcgdG8gZG8gaW5zdGFuY2VvZlxuICAgICAgICAvLyBjaGVja1xuICAgICAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgICAgICAvLyBhdm9pZCBpbnN0YW5jZXMgZnJvbSBiZWluZyBvYnNlcnZlZFxuICAgICAgICB2bS5fX3Zfc2tpcCA9IHRydWU7XG4gICAgICAgIC8vIGVmZmVjdCBzY29wZVxuICAgICAgICB2bS5fc2NvcGUgPSBuZXcgRWZmZWN0U2NvcGUodHJ1ZSAvKiBkZXRhY2hlZCAqLyk7XG4gICAgICAgIHZtLl9zY29wZS5fdm0gPSB0cnVlO1xuICAgICAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICAgICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMocmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksIG9wdGlvbnMgfHwge30sIHZtKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICB7XG4gICAgICAgICAgICBpbml0UHJveHkodm0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICAgICAgdm0uX3NlbGYgPSB2bTtcbiAgICAgICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgICAgIGluaXRFdmVudHModm0pO1xuICAgICAgICBpbml0UmVuZGVyKHZtKTtcbiAgICAgICAgY2FsbEhvb2skMSh2bSwgJ2JlZm9yZUNyZWF0ZScsIHVuZGVmaW5lZCwgZmFsc2UgLyogc2V0Q29udGV4dCAqLyk7XG4gICAgICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICAgICAgY2FsbEhvb2skMSh2bSwgJ2NyZWF0ZWQnKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICAgICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICAgICAgICBtZWFzdXJlKGB2dWUgJHt2bS5fbmFtZX0gaW5pdGAsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRzID0gKHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKSk7XG4gICAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgICBjb25zdCBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICAgIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gICAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgICBjb25zdCB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICAgIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xuICAgIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG4gICAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gICAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICAgICAgY29uc3Qgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICAgICAgY29uc3QgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAgICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICAgICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAgICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpIHtcbiAgICBsZXQgbW9kaWZpZWQ7XG4gICAgY29uc3QgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICAgIGNvbnN0IHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBsYXRlc3QpIHtcbiAgICAgICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgICAgICAgaWYgKCFtb2RpZmllZClcbiAgICAgICAgICAgICAgICBtb2RpZmllZCA9IHt9O1xuICAgICAgICAgICAgbW9kaWZpZWRba2V5XSA9IGxhdGVzdFtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb2RpZmllZDtcbn1cblxuZnVuY3Rpb24gVnVlKG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVnVlKSkge1xuICAgICAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gICAgfVxuICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG4vL0B0cy1leHBlY3QtZXJyb3IgVnVlIGhhcyBmdW5jdGlvbiB0eXBlXG5pbml0TWl4aW4kMShWdWUpO1xuLy9AdHMtZXhwZWN0LWVycm9yIFZ1ZSBoYXMgZnVuY3Rpb24gdHlwZVxuc3RhdGVNaXhpbihWdWUpO1xuLy9AdHMtZXhwZWN0LWVycm9yIFZ1ZSBoYXMgZnVuY3Rpb24gdHlwZVxuZXZlbnRzTWl4aW4oVnVlKTtcbi8vQHRzLWV4cGVjdC1lcnJvciBWdWUgaGFzIGZ1bmN0aW9uIHR5cGVcbmxpZmVjeWNsZU1peGluKFZ1ZSk7XG4vL0B0cy1leHBlY3QtZXJyb3IgVnVlIGhhcyBmdW5jdGlvbiB0eXBlXG5yZW5kZXJNaXhpbihWdWUpO1xuXG5mdW5jdGlvbiBpbml0VXNlKFZ1ZSkge1xuICAgIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbGxlZFBsdWdpbnMgPSB0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pO1xuICAgICAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ocGx1Z2luLmluc3RhbGwpKSB7XG4gICAgICAgICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocGx1Z2luKSkge1xuICAgICAgICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpbml0TWl4aW4oVnVlKSB7XG4gICAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEV4dGVuZChWdWUpIHtcbiAgICAvKipcbiAgICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAgICovXG4gICAgVnVlLmNpZCA9IDA7XG4gICAgbGV0IGNpZCA9IDE7XG4gICAgLyoqXG4gICAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICAgKi9cbiAgICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgICAgIGNvbnN0IFN1cGVyID0gdGhpcztcbiAgICAgICAgY29uc3QgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICAgICAgY29uc3QgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgICAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShleHRlbmRPcHRpb25zKSB8fCBnZXRDb21wb25lbnROYW1lKFN1cGVyLm9wdGlvbnMpO1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudChvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgICAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgICAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFN1cGVyLm9wdGlvbnMsIGV4dGVuZE9wdGlvbnMpO1xuICAgICAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcbiAgICAgICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAgICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAgICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgICAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgICAgIGluaXRQcm9wcyhTdWIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgICAgICAgaW5pdENvbXB1dGVkKFN1Yik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgICAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuICAgICAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICAgICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgICAgICB9XG4gICAgICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICAgICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICAgICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcbiAgICAgICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICAgICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgICAgIHJldHVybiBTdWI7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluaXRQcm9wcyhDb21wKSB7XG4gICAgY29uc3QgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIGBfcHJvcHNgLCBrZXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluaXRDb21wdXRlZChDb21wKSB7XG4gICAgY29uc3QgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICAgICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgICAqL1xuICAgIEFTU0VUX1RZUEVTLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgbm90IGV4YWN0IHNhbWUgdHlwZVxuICAgICAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoaWQsIGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIGlzRnVuY3Rpb24oZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBfZ2V0Q29tcG9uZW50TmFtZShvcHRzKSB7XG4gICAgcmV0dXJuIG9wdHMgJiYgKGdldENvbXBvbmVudE5hbWUob3B0cy5DdG9yLm9wdGlvbnMpIHx8IG9wdHMudGFnKTtcbn1cbmZ1bmN0aW9uIG1hdGNoZXMocGF0dGVybiwgbmFtZSkge1xuICAgIGlmIChpc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBydW5lQ2FjaGUoa2VlcEFsaXZlSW5zdGFuY2UsIGZpbHRlcikge1xuICAgIGNvbnN0IHsgY2FjaGUsIGtleXMsIF92bm9kZSB9ID0ga2VlcEFsaXZlSW5zdGFuY2U7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2FjaGUpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBjYWNoZVtrZXldO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBlbnRyeS5uYW1lO1xuICAgICAgICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXksIGtleXMsIGN1cnJlbnQpIHtcbiAgICBjb25zdCBlbnRyeSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGVudHJ5ICYmICghY3VycmVudCB8fCBlbnRyeS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNhbiBiZSB1bmRlZmluZWRcbiAgICAgICAgZW50cnkuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICB9XG4gICAgY2FjaGVba2V5XSA9IG51bGw7XG4gICAgcmVtb3ZlJDIoa2V5cywga2V5KTtcbn1cbmNvbnN0IHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuLy8gVE9ETyBkZWZpbmVDb21wb25lbnRcbnZhciBLZWVwQWxpdmUgPSB7XG4gICAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICAgIGFic3RyYWN0OiB0cnVlLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICAgICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgICAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgY2FjaGVWTm9kZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2FjaGUsIGtleXMsIHZub2RlVG9DYWNoZSwga2V5VG9DYWNoZSB9ID0gdGhpcztcbiAgICAgICAgICAgIGlmICh2bm9kZVRvQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRhZywgY29tcG9uZW50SW5zdGFuY2UsIGNvbXBvbmVudE9wdGlvbnMgfSA9IHZub2RlVG9DYWNoZTtcbiAgICAgICAgICAgICAgICBjYWNoZVtrZXlUb0NhY2hlXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogX2dldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50SW5zdGFuY2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXlUb0NhY2hlKTtcbiAgICAgICAgICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXggJiYga2V5cy5sZW5ndGggPiBwYXJzZUludCh0aGlzLm1heCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudm5vZGVUb0NhY2hlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlZCgpIHtcbiAgICAgICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMua2V5cyA9IFtdO1xuICAgIH0sXG4gICAgZGVzdHJveWVkKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICAgICAgICBwcnVuZUNhY2hlRW50cnkodGhpcy5jYWNoZSwga2V5LCB0aGlzLmtleXMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkKCkge1xuICAgICAgICB0aGlzLmNhY2hlVk5vZGUoKTtcbiAgICAgICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCB2YWwgPT4ge1xuICAgICAgICAgICAgcHJ1bmVDYWNoZSh0aGlzLCBuYW1lID0+IG1hdGNoZXModmFsLCBuYW1lKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiR3YXRjaCgnZXhjbHVkZScsIHZhbCA9PiB7XG4gICAgICAgICAgICBwcnVuZUNhY2hlKHRoaXMsIG5hbWUgPT4gIW1hdGNoZXModmFsLCBuYW1lKSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgdXBkYXRlZCgpIHtcbiAgICAgICAgdGhpcy5jYWNoZVZOb2RlKCk7XG4gICAgfSxcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHNsb3QgPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgICAgICBjb25zdCB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoc2xvdCk7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IF9nZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgeyBpbmNsdWRlLCBleGNsdWRlIH0gPSB0aGlzO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gbm90IGluY2x1ZGVkXG4gICAgICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAgICAgICAgIC8vIGV4Y2x1ZGVkXG4gICAgICAgICAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2bm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgY2FjaGUsIGtleXMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb21wb25lbnRPcHRpb25zLnRhZyA/IGA6OiR7Y29tcG9uZW50T3B0aW9ucy50YWd9YCA6ICcnKVxuICAgICAgICAgICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxuICAgICAgICAgICAgICAgIHJlbW92ZSQyKGtleXMsIGtleSk7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWxheSBzZXR0aW5nIHRoZSBjYWNoZSB1bnRpbCB1cGRhdGVcbiAgICAgICAgICAgICAgICB0aGlzLnZub2RlVG9DYWNoZSA9IHZub2RlO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5VG9DYWNoZSA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2FuIHZub2RlLmRhdGEgY2FuIGJlIHVuZGVmaW5lZFxuICAgICAgICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKTtcbiAgICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gICAgS2VlcEFsaXZlXG59O1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJKFZ1ZSkge1xuICAgIC8vIGNvbmZpZ1xuICAgIGNvbnN0IGNvbmZpZ0RlZiA9IHt9O1xuICAgIGNvbmZpZ0RlZi5nZXQgPSAoKSA9PiBjb25maWc7XG4gICAge1xuICAgICAgICBjb25maWdEZWYuc2V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgd2FybignRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG4gICAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gICAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gICAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgICBWdWUudXRpbCA9IHtcbiAgICAgICAgd2FybixcbiAgICAgICAgZXh0ZW5kLFxuICAgICAgICBtZXJnZU9wdGlvbnMsXG4gICAgICAgIGRlZmluZVJlYWN0aXZlXG4gICAgfTtcbiAgICBWdWUuc2V0ID0gc2V0O1xuICAgIFZ1ZS5kZWxldGUgPSBkZWw7XG4gICAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG4gICAgLy8gMi42IGV4cGxpY2l0IG9ic2VydmFibGUgQVBJXG4gICAgVnVlLm9ic2VydmFibGUgPSAob2JqKSA9PiB7XG4gICAgICAgIG9ic2VydmUob2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfSk7XG4gICAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAgIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICAgIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuICAgIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG4gICAgaW5pdFVzZShWdWUpO1xuICAgIGluaXRNaXhpbihWdWUpO1xuICAgIGluaXRFeHRlbmQoVnVlKTtcbiAgICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gICAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICAgIGdldCgpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQ7XG4gICAgfVxufSk7XG4vLyBleHBvc2UgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgZm9yIHNzciBydW50aW1lIGhlbHBlciBpbnN0YWxsYXRpb25cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcbiAgICB2YWx1ZTogRnVuY3Rpb25hbFJlbmRlckNvbnRleHRcbn0pO1xuVnVlLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxuY29uc3QgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xuY29uc3QgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0LHByb2dyZXNzJyk7XG5jb25zdCBtdXN0VXNlUHJvcCA9ICh0YWcsIHR5cGUsIGF0dHIpID0+IHtcbiAgICByZXR1cm4gKChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykgJiYgdHlwZSAhPT0gJ2J1dHRvbicpIHx8XG4gICAgICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgICAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpKTtcbn07XG5jb25zdCBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5jb25zdCBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUgPSBtYWtlTWFwKCdldmVudHMsY2FyZXQsdHlwaW5nLHBsYWludGV4dC1vbmx5Jyk7XG5jb25zdCBjb252ZXJ0RW51bWVyYXRlZFZhbHVlID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICByZXR1cm4gaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZSdcbiAgICAgICAgPyAnZmFsc2UnXG4gICAgICAgIDogLy8gYWxsb3cgYXJiaXRyYXJ5IHN0cmluZyB2YWx1ZSBmb3IgY29udGVudGVkaXRhYmxlXG4gICAgICAgICAgICBrZXkgPT09ICdjb250ZW50ZWRpdGFibGUnICYmIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICAgICAgOiAndHJ1ZSc7XG59O1xuY29uc3QgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLCcgK1xuICAgICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJyk7XG5jb25zdCB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuY29uc3QgaXNYbGluayA9IChuYW1lKSA9PiB7XG4gICAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJztcbn07XG5jb25zdCBnZXRYbGlua1Byb3AgPSAobmFtZSkgPT4ge1xuICAgIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJztcbn07XG5jb25zdCBpc0ZhbHN5QXR0clZhbHVlID0gKHZhbCkgPT4ge1xuICAgIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlO1xufTtcblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSkge1xuICAgIGxldCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBsZXQgcGFyZW50Tm9kZSA9IHZub2RlO1xuICAgIGxldCBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICAgICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcGFyZW50Tm9kZS5wYXJlbnQgbm90IFZOb2RlV2l0aERhdGFcbiAgICB3aGlsZSAoaXNEZWYoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpKSB7XG4gICAgICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpO1xufVxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEoY2hpbGQsIHBhcmVudCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcykgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc10gOiBwYXJlbnQuY2xhc3NcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVuZGVyQ2xhc3Moc3RhdGljQ2xhc3MsIGR5bmFtaWNDbGFzcykge1xuICAgIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgICAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gJyc7XG59XG5mdW5jdGlvbiBjb25jYXQoYSwgYikge1xuICAgIHJldHVybiBhID8gKGIgPyBhICsgJyAnICsgYiA6IGEpIDogYiB8fCAnJztcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gJyc7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSh2YWx1ZSkge1xuICAgIGxldCByZXMgPSAnJztcbiAgICBsZXQgc3RyaW5naWZpZWQ7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGlzRGVmKChzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgICAgICAgaWYgKHJlcylcbiAgICAgICAgICAgICAgICByZXMgKz0gJyAnO1xuICAgICAgICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QodmFsdWUpIHtcbiAgICBsZXQgcmVzID0gJyc7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlW2tleV0pIHtcbiAgICAgICAgICAgIGlmIChyZXMpXG4gICAgICAgICAgICAgICAgcmVzICs9ICcgJztcbiAgICAgICAgICAgIHJlcyArPSBrZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuY29uc3QgbmFtZXNwYWNlTWFwID0ge1xuICAgIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbn07XG5jb25zdCBpc0hUTUxUYWcgPSBtYWtlTWFwKCdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAgICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAgICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAgICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAgICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAgICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnKTtcbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbmNvbnN0IGlzU1ZHID0gbWFrZU1hcCgnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAgICdmb3JlaWdub2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsIHRydWUpO1xuY29uc3QgaXNSZXNlcnZlZFRhZyA9ICh0YWcpID0+IHtcbiAgICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKTtcbn07XG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UodGFnKSB7XG4gICAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICAgICAgcmV0dXJuICdzdmcnO1xuICAgIH1cbiAgICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gICAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgICAgIHJldHVybiAnbWF0aCc7XG4gICAgfVxufVxuY29uc3QgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50KHRhZykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ107XG4gICAgfVxuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgICAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9XG4gICAgICAgICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgICAgICAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKTtcbiAgICB9XG59XG5jb25zdCBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeShlbCkge1xuICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHdhcm4oJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbCk7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lLCB2bm9kZSkge1xuICAgIGNvbnN0IGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgICAgIHJldHVybiBlbG07XG4gICAgfVxuICAgIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gICAgaWYgKHZub2RlLmRhdGEgJiZcbiAgICAgICAgdm5vZGUuZGF0YS5hdHRycyAmJlxuICAgICAgICB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsbTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlKHRleHQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG59XG5mdW5jdGlvbiBjcmVhdGVDb21tZW50KHRleHQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KTtcbn1cbmZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5mdW5jdGlvbiByZW1vdmVDaGlsZChub2RlLCBjaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQobm9kZSwgY2hpbGQpIHtcbiAgICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIHBhcmVudE5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnBhcmVudE5vZGU7XG59XG5mdW5jdGlvbiBuZXh0U2libGluZyhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG59XG5mdW5jdGlvbiB0YWdOYW1lKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50YWdOYW1lO1xufVxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQobm9kZSwgdGV4dCkge1xuICAgIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuZnVuY3Rpb24gc2V0U3R5bGVTY29wZShub2RlLCBzY29wZUlkKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoc2NvcGVJZCwgJycpO1xufVxuXG52YXIgbm9kZU9wcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50LFxuICBjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcbiAgY3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuICBjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcbiAgcmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuICBhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG4gIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG4gIG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcbiAgdGFnTmFtZTogdGFnTmFtZSxcbiAgc2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuICBzZXRTdHlsZVNjb3BlOiBzZXRTdHlsZVNjb3BlXG59KTtcblxudmFyIHJlZiA9IHtcbiAgICBjcmVhdGUoXywgdm5vZGUpIHtcbiAgICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH0sXG4gICAgdXBkYXRlKG9sZFZub2RlLCB2bm9kZSkge1xuICAgICAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICAgICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3kodm5vZGUpIHtcbiAgICAgICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICAgIH1cbn07XG5mdW5jdGlvbiByZWdpc3RlclJlZih2bm9kZSwgaXNSZW1vdmFsKSB7XG4gICAgY29uc3QgcmVmID0gdm5vZGUuZGF0YS5yZWY7XG4gICAgaWYgKCFpc0RlZihyZWYpKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3Qgdm0gPSB2bm9kZS5jb250ZXh0O1xuICAgIGNvbnN0IHJlZlZhbHVlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICAgIGNvbnN0IHZhbHVlID0gaXNSZW1vdmFsID8gbnVsbCA6IHJlZlZhbHVlO1xuICAgIGNvbnN0ICRyZWZzVmFsdWUgPSBpc1JlbW92YWwgPyB1bmRlZmluZWQgOiByZWZWYWx1ZTtcbiAgICBpZiAoaXNGdW5jdGlvbihyZWYpKSB7XG4gICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKHJlZiwgdm0sIFt2YWx1ZV0sIHZtLCBgdGVtcGxhdGUgcmVmIGZ1bmN0aW9uYCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNGb3IgPSB2bm9kZS5kYXRhLnJlZkluRm9yO1xuICAgIGNvbnN0IF9pc1N0cmluZyA9IHR5cGVvZiByZWYgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiByZWYgPT09ICdudW1iZXInO1xuICAgIGNvbnN0IF9pc1JlZiA9IGlzUmVmKHJlZik7XG4gICAgY29uc3QgcmVmcyA9IHZtLiRyZWZzO1xuICAgIGlmIChfaXNTdHJpbmcgfHwgX2lzUmVmKSB7XG4gICAgICAgIGlmIChpc0Zvcikge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBfaXNTdHJpbmcgPyByZWZzW3JlZl0gOiByZWYudmFsdWU7XG4gICAgICAgICAgICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgICAgICAgICAgICAgaXNBcnJheShleGlzdGluZykgJiYgcmVtb3ZlJDIoZXhpc3RpbmcsIHJlZlZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmc1tyZWZdID0gW3JlZlZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFNldHVwUmVmKHZtLCByZWYsIHJlZnNbcmVmXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWYudmFsdWUgPSBbcmVmVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFleGlzdGluZy5pbmNsdWRlcyhyZWZWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcucHVzaChyZWZWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9pc1N0cmluZykge1xuICAgICAgICAgICAgaWYgKGlzUmVtb3ZhbCAmJiByZWZzW3JlZl0gIT09IHJlZlZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVmc1tyZWZdID0gJHJlZnNWYWx1ZTtcbiAgICAgICAgICAgIHNldFNldHVwUmVmKHZtLCByZWYsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfaXNSZWYpIHtcbiAgICAgICAgICAgIGlmIChpc1JlbW92YWwgJiYgcmVmLnZhbHVlICE9PSByZWZWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZi52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2FybihgSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTogJHt0eXBlb2YgcmVmfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0U2V0dXBSZWYoeyBfc2V0dXBTdGF0ZSB9LCBrZXksIHZhbCkge1xuICAgIGlmIChfc2V0dXBTdGF0ZSAmJiBoYXNPd24oX3NldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgICAgaWYgKGlzUmVmKF9zZXR1cFN0YXRlW2tleV0pKSB7XG4gICAgICAgICAgICBfc2V0dXBTdGF0ZVtrZXldLnZhbHVlID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3NldHVwU3RhdGVba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cbmNvbnN0IGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcbmNvbnN0IGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5mdW5jdGlvbiBzYW1lVm5vZGUoYSwgYikge1xuICAgIHJldHVybiAoYS5rZXkgPT09IGIua2V5ICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICAoKGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpKSB8fFxuICAgICAgICAgICAgKGlzVHJ1ZShhLmlzQXN5bmNQbGFjZWhvbGRlcikgJiYgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcikpKSk7XG59XG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlKGEsIGIpIHtcbiAgICBpZiAoYS50YWcgIT09ICdpbnB1dCcpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHR5cGVBID0gaXNEZWYoKGkgPSBhLmRhdGEpKSAmJiBpc0RlZigoaSA9IGkuYXR0cnMpKSAmJiBpLnR5cGU7XG4gICAgY29uc3QgdHlwZUIgPSBpc0RlZigoaSA9IGIuZGF0YSkpICYmIGlzRGVmKChpID0gaS5hdHRycykpICYmIGkudHlwZTtcbiAgICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IChpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQikpO1xufVxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHgoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgICBsZXQgaSwga2V5O1xuICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAgICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICAgICAgaWYgKGlzRGVmKGtleSkpXG4gICAgICAgICAgICBtYXBba2V5XSA9IGk7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uKGJhY2tlbmQpIHtcbiAgICBsZXQgaSwgajtcbiAgICBjb25zdCBjYnMgPSB7fTtcbiAgICBjb25zdCB7IG1vZHVsZXMsIG5vZGVPcHMgfSA9IGJhY2tlbmQ7XG4gICAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0KGVsbSkge1xuICAgICAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSbUNiKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgICAgaWYgKC0tcmVtb3ZlLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbW92ZS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgICAgIHJldHVybiByZW1vdmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGUoZWwpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAgICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICAgICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQodm5vZGUsIGluVlByZSkge1xuICAgICAgICByZXR1cm4gKCFpblZQcmUgJiZcbiAgICAgICAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgICAgICAgIShjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShpZ25vcmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnO1xuICAgICAgICAgICAgICAgIH0pKSAmJlxuICAgICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodm5vZGUudGFnKSk7XG4gICAgfVxuICAgIGxldCBjcmVhdGluZ0VsbUluVlByZSA9IDA7XG4gICAgZnVuY3Rpb24gY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQsIG93bmVyQXJyYXksIGluZGV4KSB7XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHZub2RlIHdhcyB1c2VkIGluIGEgcHJldmlvdXMgcmVuZGVyIVxuICAgICAgICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXG4gICAgICAgICAgICAvLyBwb3RlbnRpYWwgcGF0Y2ggZXJyb3JzIGRvd24gdGhlIHJvYWQgd2hlbiBpdCdzIHVzZWQgYXMgYW4gaW5zZXJ0aW9uXG4gICAgICAgICAgICAvLyByZWZlcmVuY2Ugbm9kZS4gSW5zdGVhZCwgd2UgY2xvbmUgdGhlIG5vZGUgb24tZGVtYW5kIGJlZm9yZSBjcmVhdGluZ1xuICAgICAgICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXG4gICAgICAgICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICAgICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgdGFnID0gdm5vZGUudGFnO1xuICAgICAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50KHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybignVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsIHZub2RlLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgICAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICAgICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgICAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgICAgIGxldCBpID0gdm5vZGUuZGF0YTtcbiAgICAgICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICAgICAgICBjb25zdCBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgICAgICAgaWYgKGlzRGVmKChpID0gaS5ob29rKSkgJiYgaXNEZWYoKGkgPSBpLmluaXQpKSkge1xuICAgICAgICAgICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAgICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICAgICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgICAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICAgICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICAgICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgICAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgICAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgICAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgICAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgICAgICBsZXQgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBpbm5lck5vZGUuZGF0YSkpICYmIGlzRGVmKChpID0gaS50cmFuc2l0aW9uKSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5zZXJ0KHBhcmVudCwgZWxtLCByZWYpIHtcbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZihyZWYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVPcHMucGFyZW50Tm9kZShyZWYpID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKFN0cmluZyh2bm9kZS50ZXh0KSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlKHZub2RlKSB7XG4gICAgICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjYnMuY3JlYXRlW2ldKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSlcbiAgICAgICAgICAgICAgICBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICAgICAgICAgIGlmIChpc0RlZihpLmluc2VydCkpXG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gICAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gICAgZnVuY3Rpb24gc2V0U2NvcGUodm5vZGUpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGlmIChpc0RlZigoaSA9IHZub2RlLmZuU2NvcGVJZCkpKSB7XG4gICAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhbmNlc3RvciA9IHZub2RlO1xuICAgICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKChpID0gYW5jZXN0b3IuY29udGV4dCkpICYmIGlzRGVmKChpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgICAgIGlmIChpc0RlZigoaSA9IGFjdGl2ZUluc3RhbmNlKSkgJiZcbiAgICAgICAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcbiAgICAgICAgICAgIGkgIT09IHZub2RlLmZuQ29udGV4dCAmJlxuICAgICAgICAgICAgaXNEZWYoKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkpIHtcbiAgICAgICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIGZhbHNlLCB2bm9kZXMsIHN0YXJ0SWR4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayh2bm9kZSkge1xuICAgICAgICBsZXQgaSwgajtcbiAgICAgICAgY29uc3QgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgICAgaWYgKGlzRGVmKChpID0gZGF0YS5ob29rKSkgJiYgaXNEZWYoKGkgPSBpLmRlc3Ryb3kpKSlcbiAgICAgICAgICAgICAgICBpKHZub2RlKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXSh2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKChpID0gdm5vZGUuY2hpbGRyZW4pKSkge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZVZub2Rlcyh2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICAgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgICAgICAgY29uc3QgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUZXh0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKHZub2RlLCBybSkge1xuICAgICAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgICAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgICAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGludm9rZSBob29rcyBvbiBjaGlsZCBjb21wb25lbnQgcm9vdCBub2RlXG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpICYmXG4gICAgICAgICAgICAgICAgaXNEZWYoKGkgPSBpLl92bm9kZSkpICYmXG4gICAgICAgICAgICAgICAgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSB2bm9kZS5kYXRhLmhvb2spKSAmJiBpc0RlZigoaSA9IGkucmVtb3ZlKSkpIHtcbiAgICAgICAgICAgICAgICBpKHZub2RlLCBybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBybSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICAgICAgbGV0IG9sZFN0YXJ0SWR4ID0gMDtcbiAgICAgICAgbGV0IG5ld1N0YXJ0SWR4ID0gMDtcbiAgICAgICAgbGV0IG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgICAgIGxldCBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgICAgIGxldCBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgICAgIGxldCBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgICAgICBsZXQgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgICAgICBsZXQgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgICAgICBsZXQgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCB2bm9kZVRvTW92ZSwgcmVmRWxtO1xuICAgICAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAgICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgICAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgICAgICBjb25zdCBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICAgICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICAgICAgICAgIGNhbk1vdmUgJiZcbiAgICAgICAgICAgICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICAgICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICAgICAgICBjYW5Nb3ZlICYmXG4gICAgICAgICAgICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKVxuICAgICAgICAgICAgICAgICAgICBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgICAgICAgICAgICA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XVxuICAgICAgICAgICAgICAgICAgICA6IGZpbmRJZHhJbk9sZChuZXdTdGFydFZub2RlLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVUb01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzYW1lVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5Nb3ZlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgICAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgICAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgICAgICAgIHJlbW92ZVZub2RlcyhvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IHNlZW5LZXlzID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB2bm9kZS5rZXk7XG4gICAgICAgICAgICBpZiAoaXNEZWYoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWVuS2V5c1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYER1cGxpY2F0ZSBrZXlzIGRldGVjdGVkOiAnJHtrZXl9Jy4gVGhpcyBtYXkgY2F1c2UgYW4gdXBkYXRlIGVycm9yLmAsIHZub2RlLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VlbktleXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYyA9IG9sZENoW2ldO1xuICAgICAgICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBvd25lckFycmF5LCBpbmRleCwgcmVtb3ZlT25seSkge1xuICAgICAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgICAgICAgIC8vIGNsb25lIHJldXNlZCB2bm9kZVxuICAgICAgICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsbSA9ICh2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG0pO1xuICAgICAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgICAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAgICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICAgICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgICAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgICAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAgICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSkpIHtcbiAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGkgPSBkYXRhLmhvb2spKSAmJiBpc0RlZigoaSA9IGkucHJlcGF0Y2gpKSkge1xuICAgICAgICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTtcbiAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IGRhdGEuaG9vaykpICYmIGlzRGVmKChpID0gaS51cGRhdGUpKSlcbiAgICAgICAgICAgICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZENoICE9PSBjaClcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgICAgICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZVZub2RlcyhvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICAgICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgICAgaWYgKGlzRGVmKChpID0gZGF0YS5ob29rKSkgJiYgaXNEZWYoKGkgPSBpLnBvc3RwYXRjaCkpKVxuICAgICAgICAgICAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgICAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAgICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICAgICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGh5ZHJhdGlvbkJhaWxlZCA9IGZhbHNlO1xuICAgIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gICAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICAvLyBOb3RlOiBzdHlsZSBpcyBleGNsdWRlZCBiZWNhdXNlIGl0IHJlbGllcyBvbiBpbml0aWFsIGNsb25lIGZvciBmdXR1cmVcbiAgICAvLyBkZWVwIHVwZGF0ZXMgKCM3MDYzKS5cbiAgICBjb25zdCBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG4gICAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cbiAgICBmdW5jdGlvbiBoeWRyYXRlKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBjb25zdCB7IHRhZywgZGF0YSwgY2hpbGRyZW4gfSA9IHZub2RlO1xuICAgICAgICBpblZQcmUgPSBpblZQcmUgfHwgKGRhdGEgJiYgZGF0YS5wcmUpO1xuICAgICAgICB2bm9kZS5lbG0gPSBlbG07XG4gICAgICAgIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSAmJiBpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkpKSB7XG4gICAgICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXNzZXJ0IG5vZGUgbWF0Y2hcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IGRhdGEuaG9vaykpICYmIGlzRGVmKChpID0gaS5pbml0KSkpXG4gICAgICAgICAgICAgICAgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pO1xuICAgICAgICAgICAgaWYgKGlzRGVmKChpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSkge1xuICAgICAgICAgICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICAgICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IGRhdGEpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEZWYoKGkgPSBpLmRvbVByb3BzKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRGVmKChpID0gaS5pbm5lckhUTUwpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2xpZW50IGlubmVySFRNTDogJywgZWxtLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgYW5kIGNvbXBhcmUgY2hpbGRyZW4gbGlzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxJbnZva2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgICAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgICAgICAgIHJldHVybiAodm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICghaXNVbmtub3duRWxlbWVudCh2bm9kZSwgaW5WUHJlKSAmJlxuICAgICAgICAgICAgICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gcGF0Y2gob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHkpIHtcbiAgICAgICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKVxuICAgICAgICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICAgICAgY29uc3QgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgICAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICAgICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG51bGwsIG51bGwsIHJlbW92ZU9ubHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAgICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICAgICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuKCdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgICAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50RWxtID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIFxuICAgICAgICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSkpO1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0Y2hhYmxlID0gaXNQYXRjaGFibGUodm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXShhbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0Y2hhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICM2NTEzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlLmcuIGZvciBkaXJlY3RpdmVzIHRoYXQgdXNlcyB0aGUgXCJpbnNlcnRlZFwiIGhvb2suXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lm1lcmdlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2ldKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdpc3RlclJlZihhbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgICAgIHJldHVybiB2bm9kZS5lbG07XG4gICAgfTtcbn1cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICAgIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzKHZub2RlKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZW1wdHlOb2RlIGlzIG5vdCBWTm9kZVdpdGhEYXRhXG4gICAgICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgY29uc3QgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICAgIGNvbnN0IGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gICAgY29uc3Qgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgICBjb25zdCBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuICAgIGNvbnN0IGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gICAgY29uc3QgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcbiAgICBsZXQga2V5LCBvbGREaXIsIGRpcjtcbiAgICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICAgICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgICAgICBpZiAoIW9sZERpcikge1xuICAgICAgICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgICAgICAgY2FsbEhvb2soZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICAgICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgICAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgICAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgICAgICAgIGRpci5vbGRBcmcgPSBvbGREaXIuYXJnO1xuICAgICAgICAgICAgY2FsbEhvb2soZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgICAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGNhbGxJbnNlcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2FsbEhvb2soZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNhbGxIb29rKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgICAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICAgICAgICAgIGNhbGxIb29rKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMoZGlycywgdm0pIHtcbiAgICBjb25zdCByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmICghZGlycykge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgbGV0IGksIGRpcjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkaXIgPSBkaXJzW2ldO1xuICAgICAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgICAgICB9XG4gICAgICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuICAgICAgICBpZiAodm0uX3NldHVwU3RhdGUgJiYgdm0uX3NldHVwU3RhdGUuX19zZmMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHVwRGVmID0gZGlyLmRlZiB8fCByZXNvbHZlQXNzZXQodm0sICdfc2V0dXBTdGF0ZScsICd2LScgKyBkaXIubmFtZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNldHVwRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZGlyLmRlZiA9IHtcbiAgICAgICAgICAgICAgICAgICAgYmluZDogc2V0dXBEZWYsXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogc2V0dXBEZWYsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpci5kZWYgPSBzZXR1cERlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkaXIuZGVmID0gZGlyLmRlZiB8fCByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICAgIH1cbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZShkaXIpIHtcbiAgICByZXR1cm4gKGRpci5yYXdOYW1lIHx8IGAke2Rpci5uYW1lfS4ke09iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKX1gKTtcbn1cbmZ1bmN0aW9uIGNhbGxIb29rKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgICBjb25zdCBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgICBpZiAoZm4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIGBkaXJlY3RpdmUgJHtkaXIubmFtZX0gJHtob29rfSBob29rYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtyZWYsIGRpcmVjdGl2ZXNdO1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBjb25zdCBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoaXNEZWYob3B0cykgJiYgb3B0cy5DdG9yLm9wdGlvbnMuaW5oZXJpdEF0dHJzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQga2V5LCBjdXIsIG9sZDtcbiAgICBjb25zdCBlbG0gPSB2bm9kZS5lbG07XG4gICAgY29uc3Qgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAgIGxldCBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gICAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gICAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykgfHwgaXNUcnVlKGF0dHJzLl92X2F0dHJfcHJveHkpKSB7XG4gICAgICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgICAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgICAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgICAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1ciwgdm5vZGUuZGF0YS5wcmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gICAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICgoaXNJRSB8fCBpc0VkZ2UpICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgICAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgICAgICBpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xuICAgICAgICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0QXR0cihlbCwga2V5LCB2YWx1ZSwgaXNJblByZSkge1xuICAgIGlmIChpc0luUHJlIHx8IGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAgICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAgICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICAgICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcbiAgICAgICAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICAgICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJyA/ICd0cnVlJyA6IGtleTtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgY29udmVydEVudW1lcmF0ZWRWYWx1ZShrZXksIHZhbHVlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyAjNzEzODogSUUxMCAmIDExIGZpcmVzIGlucHV0IGV2ZW50IHdoZW4gc2V0dGluZyBwbGFjZWhvbGRlciBvblxuICAgICAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXG4gICAgICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgICAgICFpc0lFOSAmJlxuICAgICAgICAgICAgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJlxuICAgICAgICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmXG4gICAgICAgICAgICB2YWx1ZSAhPT0gJycgJiZcbiAgICAgICAgICAgICFlbC5fX2llcGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrZXIgPSBlID0+IHtcbiAgICAgICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xuICAgICAgICB9XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG59XG52YXIgYXR0cnMgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBjb25zdCBlbCA9IHZub2RlLmVsbTtcbiAgICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBjb25zdCBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgICAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmXG4gICAgICAgIChpc1VuZGVmKG9sZERhdGEpIHx8XG4gICAgICAgICAgICAoaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJiBpc1VuZGVmKG9sZERhdGEuY2xhc3MpKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG4gICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICAgIGNvbnN0IHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgICAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgICB9XG4gICAgLy8gc2V0IHRoZSBjbGFzc1xuICAgIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gICAgfVxufVxudmFyIGtsYXNzID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gICAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbmNvbnN0IFJBTkdFX1RPS0VOID0gJ19fcic7XG5jb25zdCBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzKG9uKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAgICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgICAgICBjb25zdCBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gICAgfVxuICAgIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XG4gICAgLy8gYWZ0ZXIgMi41LiBLZWVwaW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGggZ2VuZXJhdGVkIGNvZGUgZnJvbSA8IDIuNFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgICAgIG9uLmNoYW5nZSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uLmNoYW5nZSB8fCBbXSk7XG4gICAgICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gICAgfVxufVxubGV0IHRhcmdldDtcbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gICAgY29uc3QgX3RhcmdldCA9IHRhcmdldDsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIoKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVtb3ZlKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLy8gIzk0NDY6IEZpcmVmb3ggPD0gNTMgKGluIHBhcnRpY3VsYXIsIEVTUiA1MikgaGFzIGluY29ycmVjdCBFdmVudC50aW1lU3RhbXBcbi8vIGltcGxlbWVudGF0aW9uIGFuZCBkb2VzIG5vdCBmaXJlIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbiwgc29cbi8vIHNhZmUgdG8gZXhjbHVkZS5cbmNvbnN0IHVzZU1pY3JvdGFza0ZpeCA9IGlzVXNpbmdNaWNyb1Rhc2sgJiYgIShpc0ZGICYmIE51bWJlcihpc0ZGWzFdKSA8PSA1Myk7XG5mdW5jdGlvbiBhZGQobmFtZSwgaGFuZGxlciwgY2FwdHVyZSwgcGFzc2l2ZSkge1xuICAgIC8vIGFzeW5jIGVkZ2UgY2FzZSAjNjU2NjogaW5uZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcnMgcGF0Y2gsIGV2ZW50IGhhbmRsZXJcbiAgICAvLyBhdHRhY2hlZCB0byBvdXRlciBlbGVtZW50IGR1cmluZyBwYXRjaCwgYW5kIHRyaWdnZXJlZCBhZ2Fpbi4gVGhpc1xuICAgIC8vIGhhcHBlbnMgYmVjYXVzZSBicm93c2VycyBmaXJlIG1pY3JvdGFzayB0aWNrcyBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgIC8vIHRoZSBzb2x1dGlvbiBpcyBzaW1wbGU6IHdlIHNhdmUgdGhlIHRpbWVzdGFtcCB3aGVuIGEgaGFuZGxlciBpcyBhdHRhY2hlZCxcbiAgICAvLyBhbmQgdGhlIGhhbmRsZXIgd291bGQgb25seSBmaXJlIGlmIHRoZSBldmVudCBwYXNzZWQgdG8gaXQgd2FzIGZpcmVkXG4gICAgLy8gQUZURVIgaXQgd2FzIGF0dGFjaGVkLlxuICAgIGlmICh1c2VNaWNyb3Rhc2tGaXgpIHtcbiAgICAgICAgY29uc3QgYXR0YWNoZWRUaW1lc3RhbXAgPSBjdXJyZW50Rmx1c2hUaW1lc3RhbXA7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsID0gaGFuZGxlcjtcbiAgICAgICAgLy9AdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGhhbmRsZXIgPSBvcmlnaW5hbC5fd3JhcHBlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBubyBidWJibGluZywgc2hvdWxkIGFsd2F5cyBmaXJlLlxuICAgICAgICAgICAgLy8gdGhpcyBpcyBqdXN0IGEgc2FmZXR5IG5ldCBpbiBjYXNlIGV2ZW50LnRpbWVTdGFtcCBpcyB1bnJlbGlhYmxlIGluXG4gICAgICAgICAgICAvLyBjZXJ0YWluIHdlaXJkIGVudmlyb25tZW50cy4uLlxuICAgICAgICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCB8fFxuICAgICAgICAgICAgICAgIC8vIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGhhbmRsZXIgYXR0YWNobWVudFxuICAgICAgICAgICAgICAgIGUudGltZVN0YW1wID49IGF0dGFjaGVkVGltZXN0YW1wIHx8XG4gICAgICAgICAgICAgICAgLy8gYmFpbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgaGF2ZSBidWdneSBldmVudC50aW1lU3RhbXAgaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAgICAgICAgLy8gIzk0NjIgaU9TIDkgYnVnOiBldmVudC50aW1lU3RhbXAgaXMgMCBhZnRlciBoaXN0b3J5LnB1c2hTdGF0ZVxuICAgICAgICAgICAgICAgIC8vICM5NjgxIFF0V2ViRW5naW5lIGV2ZW50LnRpbWVTdGFtcCBpcyBuZWdhdGl2ZSB2YWx1ZVxuICAgICAgICAgICAgICAgIGUudGltZVN0YW1wIDw9IDAgfHxcbiAgICAgICAgICAgICAgICAvLyAjOTQ0OCBiYWlsIGlmIGV2ZW50IGlzIGZpcmVkIGluIGFub3RoZXIgZG9jdW1lbnQgaW4gYSBtdWx0aS1wYWdlXG4gICAgICAgICAgICAgICAgLy8gZWxlY3Ryb24vbncuanMgYXBwLCBzaW5jZSBldmVudC50aW1lU3RhbXAgd2lsbCBiZSB1c2luZyBhIGRpZmZlcmVudFxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0aW5nIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIGUudGFyZ2V0Lm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHN1cHBvcnRzUGFzc2l2ZSA/IHsgY2FwdHVyZSwgcGFzc2l2ZSB9IDogY2FwdHVyZSk7XG59XG5mdW5jdGlvbiByZW1vdmUobmFtZSwgaGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCkge1xuICAgIChfdGFyZ2V0IHx8IHRhcmdldCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBcbiAgICAvL0B0cy1leHBlY3QtZXJyb3JcbiAgICBoYW5kbGVyLl93cmFwcGVyIHx8IGhhbmRsZXIsIGNhcHR1cmUpO1xufVxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gICAgY29uc3Qgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICAgIC8vIHZub2RlIGlzIGVtcHR5IHdoZW4gcmVtb3ZpbmcgYWxsIGxpc3RlbmVycyxcbiAgICAvLyBhbmQgdXNlIG9sZCB2bm9kZSBkb20gZWxlbWVudFxuICAgIHRhcmdldCA9IHZub2RlLmVsbSB8fCBvbGRWbm9kZS5lbG07XG4gICAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQsIHJlbW92ZSwgY3JlYXRlT25jZUhhbmRsZXIsIHZub2RlLmNvbnRleHQpO1xuICAgIHRhcmdldCA9IHVuZGVmaW5lZDtcbn1cbnZhciBldmVudHMgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gICAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBlbXB0eU5vZGUgaGFzIGFjdHVhbGx5IGRhdGFcbiAgICBkZXN0cm95OiAodm5vZGUpID0+IHVwZGF0ZURPTUxpc3RlbmVycyh2bm9kZSwgZW1wdHlOb2RlKVxufTtcblxubGV0IHN2Z0NvbnRhaW5lcjtcbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQga2V5LCBjdXI7XG4gICAgY29uc3QgZWxtID0gdm5vZGUuZWxtO1xuICAgIGNvbnN0IG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgICBsZXQgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAgIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICAgIGlmIChpc0RlZihwcm9wcy5fX29iX18pIHx8IGlzVHJ1ZShwcm9wcy5fdl9hdHRyX3Byb3h5KSkge1xuICAgICAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xuICAgICAgICAgICAgZWxtW2tleV0gPSAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgICAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgICAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAgICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAgICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICAgICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICAgICAgICBpZiAodm5vZGUuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvLyAjNjYwMSB3b3JrIGFyb3VuZCBDaHJvbWUgdmVyc2lvbiA8PSA1NSBidWcgd2hlcmUgc2luZ2xlIHRleHROb2RlXG4gICAgICAgICAgICAvLyByZXBsYWNlZCBieSBpbm5lckhUTUwvdGV4dENvbnRlbnQgcmV0YWlucyBpdHMgcGFyZW50Tm9kZSBwcm9wZXJ0eVxuICAgICAgICAgICAgaWYgKGVsbS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSA9PT0gJ3ZhbHVlJyAmJiBlbG0udGFnTmFtZSAhPT0gJ1BST0dSRVNTJykge1xuICAgICAgICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgICAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgICAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAgICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgICAgICAgIGNvbnN0IHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XG4gICAgICAgICAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgJiZcbiAgICAgICAgICAgIGlzU1ZHKGVsbS50YWdOYW1lKSAmJlxuICAgICAgICAgICAgaXNVbmRlZihlbG0uaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgLy8gSUUgZG9lc24ndCBzdXBwb3J0IGlubmVySFRNTCBmb3IgU1ZHIGVsZW1lbnRzXG4gICAgICAgICAgICBzdmdDb250YWluZXIgPSBzdmdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBzdmdDb250YWluZXIuaW5uZXJIVE1MID0gYDxzdmc+JHtjdXJ9PC9zdmc+YDtcbiAgICAgICAgICAgIGNvbnN0IHN2ZyA9IHN2Z0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGVsbS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChzdmcuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIGVsbS5hcHBlbmRDaGlsZChzdmcuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgIC8vIHNraXAgdGhlIHVwZGF0ZSBpZiBvbGQgYW5kIG5ldyBWRE9NIHN0YXRlIGlzIHRoZSBzYW1lLlxuICAgICAgICAvLyBgdmFsdWVgIGlzIGhhbmRsZWQgc2VwYXJhdGVseSBiZWNhdXNlIHRoZSBET00gdmFsdWUgbWF5IGJlIHRlbXBvcmFyaWx5XG4gICAgICAgIC8vIG91dCBvZiBzeW5jIHdpdGggVkRPTSBzdGF0ZSBkdWUgdG8gZm9jdXMsIGNvbXBvc2l0aW9uIGFuZCBtb2RpZmllcnMuXG4gICAgICAgIC8vIFRoaXMgICM0NTIxIGJ5IHNraXBwaW5nIHRoZSB1bm5lY2Vzc2FyeSBgY2hlY2tlZGAgdXBkYXRlLlxuICAgICAgICBjdXIgIT09IG9sZFByb3BzW2tleV0pIHtcbiAgICAgICAgICAgIC8vIHNvbWUgcHJvcGVydHkgdXBkYXRlcyBjYW4gdGhyb3dcbiAgICAgICAgICAgIC8vIGUuZy4gYHZhbHVlYCBvbiA8cHJvZ3Jlc3M+IHcvIG5vbi1maW5pdGUgdmFsdWVcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZShlbG0sIGNoZWNrVmFsKSB7XG4gICAgcmV0dXJuIChcbiAgICAvL0B0cy1leHBlY3QtZXJyb3JcbiAgICAhZWxtLmNvbXBvc2luZyAmJlxuICAgICAgICAoZWxtLnRhZ05hbWUgPT09ICdPUFRJT04nIHx8XG4gICAgICAgICAgICBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgICAgICAgICAgaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBjaGVja1ZhbCkpKTtcbn1cbmZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5KGVsbSwgY2hlY2tWYWwpIHtcbiAgICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gICAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gICAgbGV0IG5vdEluRm9jdXMgPSB0cnVlO1xuICAgIC8vICM2MTU3XG4gICAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gICAgdHJ5IHtcbiAgICAgICAgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxuICAgIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWw7XG59XG5mdW5jdGlvbiBpc0RpcnR5V2l0aE1vZGlmaWVycyhlbG0sIG5ld1ZhbCkge1xuICAgIGNvbnN0IHZhbHVlID0gZWxtLnZhbHVlO1xuICAgIGNvbnN0IG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gICAgaWYgKGlzRGVmKG1vZGlmaWVycykpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsO1xufVxudmFyIGRvbVByb3BzID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gICAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuY29uc3QgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBjb25zdCBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgICBjb25zdCBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gICAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBjb25zdCB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgICAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG59KTtcbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEoZGF0YSkge1xuICAgIGNvbnN0IHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAgIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAgIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gICAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGUgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpIDogc3R5bGU7XG59XG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcoYmluZGluZ1N0eWxlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgICAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpO1xuICAgIH1cbiAgICByZXR1cm4gYmluZGluZ1N0eWxlO1xufVxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGxldCBzdHlsZURhdGE7XG4gICAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICAgICAgbGV0IGNoaWxkTm9kZSA9IHZub2RlO1xuICAgICAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSAmJlxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5kYXRhICYmXG4gICAgICAgICAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gICAgbGV0IHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHBhcmVudE5vZGUucGFyZW50IG5vdCBWTm9kZVdpdGhEYXRhXG4gICAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5jb25zdCBjc3NWYXJSRSA9IC9eLS0vO1xuY29uc3QgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbmNvbnN0IHNldFByb3AgPSAoZWwsIG5hbWUsIHZhbCkgPT4ge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShoeXBoZW5hdGUobmFtZSksIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xubGV0IGVtcHR5U3R5bGU7XG5jb25zdCBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gICAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIHByb3AgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgICByZXR1cm4gcHJvcDtcbiAgICB9XG4gICAgY29uc3QgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVuZG9yTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcbiAgICAgICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGNvbnN0IGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGNvbnN0IG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICAgIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmXG4gICAgICAgIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJlxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3R5bGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGN1ciwgbmFtZTtcbiAgICBjb25zdCBlbCA9IHZub2RlLmVsbTtcbiAgICBjb25zdCBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gICAgY29uc3Qgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcbiAgICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICAgIGNvbnN0IG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuICAgIGNvbnN0IHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuICAgIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXG4gICAgLy8gdG8gbXV0YXRlIGl0LlxuICAgIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKSA/IGV4dGVuZCh7fSwgc3R5bGUpIDogc3R5bGU7XG4gICAgY29uc3QgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG4gICAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgICAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICAgICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgICAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnZhciBzdHlsZSA9IHtcbiAgICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICAgIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbmNvbnN0IHdoaXRlc3BhY2VSRSA9IC9cXHMrLztcbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIGNscykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICAgICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChjID0+IGVsLmNsYXNzTGlzdC5hZGQoYykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBjdXIgPSBgICR7ZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnfSBgO1xuICAgICAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgY2xzKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICAgICAgICBjbHMuc3BsaXQod2hpdGVzcGFjZVJFKS5mb3JFYWNoKGMgPT4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBjdXIgPSBgICR7ZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnfSBgO1xuICAgICAgICBjb25zdCB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgICAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBjdXIudHJpbSgpO1xuICAgICAgICBpZiAoY3VyKSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24oZGVmKSB7XG4gICAgaWYgKCFkZWYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh0eXBlb2YgZGVmID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcbiAgICAgICAgaWYgKGRlZi5jc3MgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYubmFtZSB8fCAndicpKTtcbiAgICAgICAgfVxuICAgICAgICBleHRlbmQocmVzLCBkZWYpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmKTtcbiAgICB9XG59XG5jb25zdCBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChuYW1lID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbnRlckNsYXNzOiBgJHtuYW1lfS1lbnRlcmAsXG4gICAgICAgIGVudGVyVG9DbGFzczogYCR7bmFtZX0tZW50ZXItdG9gLFxuICAgICAgICBlbnRlckFjdGl2ZUNsYXNzOiBgJHtuYW1lfS1lbnRlci1hY3RpdmVgLFxuICAgICAgICBsZWF2ZUNsYXNzOiBgJHtuYW1lfS1sZWF2ZWAsXG4gICAgICAgIGxlYXZlVG9DbGFzczogYCR7bmFtZX0tbGVhdmUtdG9gLFxuICAgICAgICBsZWF2ZUFjdGl2ZUNsYXNzOiBgJHtuYW1lfS1sZWF2ZS1hY3RpdmVgXG4gICAgfTtcbn0pO1xuY29uc3QgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG5jb25zdCBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xuY29uc3QgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG5sZXQgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG5sZXQgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xubGV0IGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbmxldCBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICAgICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICAgIH1cbiAgICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgICAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICAgIH1cbn1cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxuY29uc3QgcmFmID0gaW5Ccm93c2VyXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgICAgICAgOiBzZXRUaW1lb3V0XG4gICAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmbiA9PiBmbigpO1xuZnVuY3Rpb24gbmV4dEZyYW1lKGZuKSB7XG4gICAgcmFmKCgpID0+IHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICByYWYoZm4pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcbiAgICBjb25zdCB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xuICAgIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgICAgIHRyYW5zaXRpb25DbGFzc2VzLnB1c2goY2xzKTtcbiAgICAgICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcbiAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIHJlbW92ZSQyKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgICB9XG4gICAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIGV4cGVjdGVkVHlwZSwgY2IpIHtcbiAgICBjb25zdCB7IHR5cGUsIHRpbWVvdXQsIHByb3BDb3VudCB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gICAgaWYgKCF0eXBlKVxuICAgICAgICByZXR1cm4gY2IoKTtcbiAgICBjb25zdCBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgICBsZXQgZW5kZWQgPSAwO1xuICAgIGNvbnN0IGVuZCA9ICgpID0+IHtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgICAgICBjYigpO1xuICAgIH07XG4gICAgY29uc3Qgb25FbmQgPSBlID0+IHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgICAgICAgICAgZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgICAgICAgIGVuZCgpO1xuICAgICAgICB9XG4gICAgfSwgdGltZW91dCArIDEpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cbmNvbnN0IHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgLy8gSlNET00gbWF5IHJldHVybiB1bmRlZmluZWQgZm9yIHRyYW5zaXRpb24gcHJvcGVydGllc1xuICAgIGNvbnN0IHRyYW5zaXRpb25EZWxheXMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIGNvbnN0IHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgICBjb25zdCBhbmltYXRpb25EZWxheXMgPSAoc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gICAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb25zID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIGNvbnN0IGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcbiAgICBsZXQgdHlwZTtcbiAgICBsZXQgdGltZW91dCA9IDA7XG4gICAgbGV0IHByb3BDb3VudCA9IDA7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgICAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgICAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgICAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICAgICAgdHlwZSA9XG4gICAgICAgICAgICB0aW1lb3V0ID4gMFxuICAgICAgICAgICAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgICAgICAgICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICAgICAgICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICAgICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICAgICAgOiAwO1xuICAgIH1cbiAgICBjb25zdCBoYXNUcmFuc2Zvcm0gPSB0eXBlID09PSBUUkFOU0lUSU9OICYmIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHRpbWVvdXQsXG4gICAgICAgIHByb3BDb3VudCxcbiAgICAgICAgaGFzVHJhbnNmb3JtXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFRpbWVvdXQoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgICAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKChkLCBpKSA9PiB7XG4gICAgICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pO1xuICAgIH0pKTtcbn1cbi8vIE9sZCB2ZXJzaW9ucyBvZiBDaHJvbWl1bSAoYmVsb3cgNjEuMC4zMTYzLjEwMCkgZm9ybWF0cyBmbG9hdGluZyBwb2ludGVyIG51bWJlcnNcbi8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cbi8vIElmIGNvbW1hIGlzIG5vdCByZXBsYWNlZCB3aXRoIGEgZG90LCB0aGUgaW5wdXQgd2lsbCBiZSByb3VuZGVkIGRvd24gKGkuZS4gYWN0aW5nXG4vLyBhcyBhIGZsb29yIGZ1bmN0aW9uKSBjYXVzaW5nIHVuZXhwZWN0ZWQgYmVoYXZpb3JzXG5mdW5jdGlvbiB0b01zKHMpIHtcbiAgICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoJywnLCAnLicpKSAqIDEwMDA7XG59XG5cbmZ1bmN0aW9uIGVudGVyKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gICAgY29uc3QgZWwgPSB2bm9kZS5lbG07XG4gICAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGVsLl9sZWF2ZUNiKCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICAgIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY3NzLCB0eXBlLCBlbnRlckNsYXNzLCBlbnRlclRvQ2xhc3MsIGVudGVyQWN0aXZlQ2xhc3MsIGFwcGVhckNsYXNzLCBhcHBlYXJUb0NsYXNzLCBhcHBlYXJBY3RpdmVDbGFzcywgYmVmb3JlRW50ZXIsIGVudGVyLCBhZnRlckVudGVyLCBlbnRlckNhbmNlbGxlZCwgYmVmb3JlQXBwZWFyLCBhcHBlYXIsIGFmdGVyQXBwZWFyLCBhcHBlYXJDYW5jZWxsZWQsIGR1cmF0aW9uIH0gPSBkYXRhO1xuICAgIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAgIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICAgIGxldCBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgbGV0IHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICAgIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICAgICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gICAgICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIH1cbiAgICBjb25zdCBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcbiAgICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzID8gYXBwZWFyQ2xhc3MgOiBlbnRlckNsYXNzO1xuICAgIGNvbnN0IGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3MgPyBhcHBlYXJBY3RpdmVDbGFzcyA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gICAgY29uc3QgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3MgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzO1xuICAgIGNvbnN0IGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyID8gYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyIDogYmVmb3JlRW50ZXI7XG4gICAgY29uc3QgZW50ZXJIb29rID0gaXNBcHBlYXIgPyAoaXNGdW5jdGlvbihhcHBlYXIpID8gYXBwZWFyIDogZW50ZXIpIDogZW50ZXI7XG4gICAgY29uc3QgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhciA/IGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIgOiBhZnRlckVudGVyO1xuICAgIGNvbnN0IGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgICAgID8gYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkXG4gICAgICAgIDogZW50ZXJDYW5jZWxsZWQ7XG4gICAgY29uc3QgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoaXNPYmplY3QoZHVyYXRpb24pID8gZHVyYXRpb24uZW50ZXIgOiBkdXJhdGlvbik7XG4gICAgaWYgKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgICBjb25zdCB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuICAgIGNvbnN0IGNiID0gKGVsLl9lbnRlckNiID0gb25jZSgoKSA9PiB7XG4gICAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gICAgfSkpO1xuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICAgICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgICAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gICAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgIGNiKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbGVhdmUodm5vZGUsIHJtKSB7XG4gICAgY29uc3QgZWwgPSB2bm9kZS5lbG07XG4gICAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGVsLl9lbnRlckNiKCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICAgIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgIHJldHVybiBybSgpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjc3MsIHR5cGUsIGxlYXZlQ2xhc3MsIGxlYXZlVG9DbGFzcywgbGVhdmVBY3RpdmVDbGFzcywgYmVmb3JlTGVhdmUsIGxlYXZlLCBhZnRlckxlYXZlLCBsZWF2ZUNhbmNlbGxlZCwgZGVsYXlMZWF2ZSwgZHVyYXRpb24gfSA9IGRhdGE7XG4gICAgY29uc3QgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICAgIGNvbnN0IHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcbiAgICBjb25zdCBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihpc09iamVjdChkdXJhdGlvbikgPyBkdXJhdGlvbi5sZWF2ZSA6IGR1cmF0aW9uKTtcbiAgICBpZiAoaXNEZWYoZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICAgIH1cbiAgICBjb25zdCBjYiA9IChlbC5fbGVhdmVDYiA9IG9uY2UoKCkgPT4ge1xuICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICAgICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcm0oKTtcbiAgICAgICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICAgIH0pKTtcbiAgICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgICAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlKCkge1xuICAgICAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICAgICAgaWYgKCF2bm9kZS5kYXRhLnNob3cgJiYgZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpW3Zub2RlLmtleV0gPVxuICAgICAgICAgICAgICAgIHZub2RlO1xuICAgICAgICB9XG4gICAgICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICAgICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2FybihgPHRyYW5zaXRpb24+IGV4cGxpY2l0ICR7bmFtZX0gZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gYCArXG4gICAgICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsKX0uYCwgdm5vZGUuY29udGV4dCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICAgICAgd2FybihgPHRyYW5zaXRpb24+IGV4cGxpY2l0ICR7bmFtZX0gZHVyYXRpb24gaXMgTmFOIC0gYCArXG4gICAgICAgICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsIHZub2RlLmNvbnRleHQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbih2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbCk7XG59XG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChmbikge1xuICAgIGlmIChpc1VuZGVmKGZuKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCBpbnZva2VyRm5zID0gZm4uZm5zO1xuICAgIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuICAgICAgICAvLyBpbnZva2VyXG4gICAgICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKEFycmF5LmlzQXJyYXkoaW52b2tlckZucykgPyBpbnZva2VyRm5zWzBdIDogaW52b2tlckZucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZW50ZXIoXywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlKTtcbiAgICB9XG59XG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlclxuICAgID8ge1xuICAgICAgICBjcmVhdGU6IF9lbnRlcixcbiAgICAgICAgYWN0aXZhdGU6IF9lbnRlcixcbiAgICAgICAgcmVtb3ZlKHZub2RlLCBybSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFthdHRycywga2xhc3MsIGV2ZW50cywgZG9tUHJvcHMsIHN0eWxlLCB0cmFuc2l0aW9uXTtcblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxuY29uc3QgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuY29uc3QgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wcywgbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gICAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNvbnN0IGRpcmVjdGl2ZSA9IHtcbiAgICBpbnNlcnRlZChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XG4gICAgICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgICAgICAvLyAjNjkwM1xuICAgICAgICAgICAgaWYgKG9sZFZub2RlLmVsbSAmJiAhb2xkVm5vZGUuZWxtLl92T3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmUuY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcbiAgICAgICAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICAgICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAgICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxuICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgICAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICAgICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAgICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgICAgICAgIGNvbnN0IHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgY3VyT3B0aW9ucyA9IChlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSkpO1xuICAgICAgICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZSgobywgaSkgPT4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pKSkge1xuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgICAgICAgICAgLy8gbm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGZvciBhdCBsZWFzdCBvbmUgdmFsdWVcbiAgICAgICAgICAgICAgICBjb25zdCBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZSh2ID0+IGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucykpXG4gICAgICAgICAgICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBjdXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuZnVuY3Rpb24gc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKSB7XG4gICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pIHtcbiAgICBjb25zdCB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gICAgY29uc3QgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICAgIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB3YXJuKGA8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XCIke2JpbmRpbmcuZXhwcmVzc2lvbn1cIj4gYCArXG4gICAgICAgICAgICAgICAgYGV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290ICR7T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICAgICAgICAgICAgICAgICAgICAuY2FsbCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDgsIC0xKX1gLCB2bSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHNlbGVjdGVkLCBvcHRpb247XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgICAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24odmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5ldmVyeShvID0+ICFsb29zZUVxdWFsKG8sIHZhbHVlKSk7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZShvcHRpb24pIHtcbiAgICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uID8gb3B0aW9uLl92YWx1ZSA6IG9wdGlvbi52YWx1ZTtcbn1cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydChlKSB7XG4gICAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQoZSkge1xuICAgIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gICAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpXG4gICAgICAgIHJldHVybjtcbiAgICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cbmZ1bmN0aW9uIHRyaWdnZXIoZWwsIHR5cGUpIHtcbiAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlKHZub2RlKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICAgICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICAgICAgOiB2bm9kZTtcbn1cbnZhciBzaG93ID0ge1xuICAgIGJpbmQoZWwsIHsgdmFsdWUgfSwgdm5vZGUpIHtcbiAgICAgICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgICAgICBjb25zdCBvcmlnaW5hbERpc3BsYXkgPSAoZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheSk7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgICAgICAgZW50ZXIodm5vZGUsICgpID0+IHtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHVwZGF0ZShlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgdm5vZGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGVudGVyKHZub2RlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZWF2ZSh2bm9kZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB1bmJpbmQoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gICAgICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgICBtb2RlbDogZGlyZWN0aXZlLFxuICAgIHNob3dcbn07XG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXG5jb25zdCB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gICAgbmFtZTogU3RyaW5nLFxuICAgIGFwcGVhcjogQm9vbGVhbixcbiAgICBjc3M6IEJvb2xlYW4sXG4gICAgbW9kZTogU3RyaW5nLFxuICAgIHR5cGU6IFN0cmluZyxcbiAgICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gICAgbGVhdmVDbGFzczogU3RyaW5nLFxuICAgIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICAgIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkKHZub2RlKSB7XG4gICAgY29uc3QgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgfVxufVxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhKGNvbXApIHtcbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgY29uc3Qgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gICAgLy8gcHJvcHNcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgICAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gICAgfVxuICAgIC8vIGV2ZW50cy5cbiAgICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgIGRhdGFbY2FtZWxpemUoa2V5KV0gPSBsaXN0ZW5lcnNba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZCkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgICAgIHJldHVybiBoKCdrZWVwLWFsaXZlJywge1xuICAgICAgICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24odm5vZGUpIHtcbiAgICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgICAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkge1xuICAgIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZztcbn1cbmNvbnN0IGlzTm90VGV4dE5vZGUgPSAoYykgPT4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpO1xuY29uc3QgaXNWU2hvd0RpcmVjdGl2ZSA9IGQgPT4gZC5uYW1lID09PSAnc2hvdyc7XG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgICBuYW1lOiAndHJhbnNpdGlvbicsXG4gICAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgICBhYnN0cmFjdDogdHJ1ZSxcbiAgICByZW5kZXIoaCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoaXNOb3RUZXh0Tm9kZSk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHdhcm4oJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLCB0aGlzLiRwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGUgPSB0aGlzLm1vZGU7XG4gICAgICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgICAgIGlmIChtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nKSB7XG4gICAgICAgICAgICB3YXJuKCdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSwgdGhpcy4kcGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgICAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiByYXdDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAgICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgICAgICBjb25zdCBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmF3Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAgICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgICAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgICAgIGNvbnN0IGlkID0gYF9fdHJhbnNpdGlvbi0ke3RoaXMuX3VpZH0tYDtcbiAgICAgICAgY2hpbGQua2V5ID1cbiAgICAgICAgICAgIGNoaWxkLmtleSA9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgPyBpZCArICdjb21tZW50J1xuICAgICAgICAgICAgICAgICAgICA6IGlkICsgY2hpbGQudGFnXG4gICAgICAgICAgICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgICAgICAgICAgICAgID8gU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2hpbGQua2V5XG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlkICsgY2hpbGQua2V5XG4gICAgICAgICAgICAgICAgICAgIDogY2hpbGQua2V5O1xuICAgICAgICBjb25zdCBkYXRhID0gKChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID1cbiAgICAgICAgICAgIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKSk7XG4gICAgICAgIGNvbnN0IG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgICAgIGNvbnN0IG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcbiAgICAgICAgLy8gbWFyayB2LXNob3dcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoaXNWU2hvd0RpcmVjdGl2ZSkpIHtcbiAgICAgICAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZENoaWxkICYmXG4gICAgICAgICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAgICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZCkgJiZcbiAgICAgICAgICAgIC8vICM2Njg3IGNvbXBvbmVudCByb290IGlzIGEgY29tbWVudCBub2RlXG4gICAgICAgICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAgICAgICAgICAgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgICAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgICAgICAgY29uc3Qgb2xkRGF0YSA9IChvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpKTtcbiAgICAgICAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgICAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICAgICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZGVsYXllZExlYXZlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXllZExlYXZlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgICAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGxlYXZlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXllZExlYXZlID0gbGVhdmU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhd0NoaWxkO1xuICAgIH1cbn07XG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbmNvbnN0IHByb3BzID0gZXh0ZW5kKHtcbiAgICB0YWc6IFN0cmluZyxcbiAgICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcbmRlbGV0ZSBwcm9wcy5tb2RlO1xudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgICBwcm9wcyxcbiAgICBiZWZvcmVNb3VudCgpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICAgICAgICB0aGlzLl91cGRhdGUgPSAodm5vZGUsIGh5ZHJhdGluZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2UodGhpcyk7XG4gICAgICAgICAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgICAgICAgICB0aGlzLl9fcGF0Y2hfXyh0aGlzLl92bm9kZSwgdGhpcy5rZXB0LCBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICAgICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcbiAgICAgICAgICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgICAgICAgICAgdXBkYXRlLmNhbGwodGhpcywgdm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICAgIH07XG4gICAgfSxcbiAgICByZW5kZXIoaCkge1xuICAgICAgICBjb25zdCB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgICAgIGNvbnN0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGNvbnN0IHByZXZDaGlsZHJlbiA9ICh0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4pO1xuICAgICAgICBjb25zdCByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gKHRoaXMuY2hpbGRyZW4gPSBbXSk7XG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgICAgICAgICAgICBtYXBbYy5rZXldID0gYztcbiAgICAgICAgICAgICAgICAgICAgKGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gb3B0c1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBnZXRDb21wb25lbnROYW1lKG9wdHMuQ3Rvci5vcHRpb25zKSB8fCBvcHRzLnRhZyB8fCAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBjLnRhZztcbiAgICAgICAgICAgICAgICAgICAgd2FybihgPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDwke25hbWV9PmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjb25zdCBrZXB0ID0gW107XG4gICAgICAgICAgICBjb25zdCByZW1vdmVkID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBwcmV2Q2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgYy5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgbm90IHR5cGVkIGluIE5vZGVcbiAgICAgICAgICAgICAgICBjLmRhdGEucG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcFtjLmtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAga2VwdC5wdXNoKGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbik7XG4gICAgfSxcbiAgICB1cGRhdGVkKCkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgICAgICBjb25zdCBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnO1xuICAgICAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgICAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuICAgICAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAgICAgLy8gYXNzaWduIHRvIHRoaXMgdG8gYXZvaWQgYmVpbmcgcmVtb3ZlZCBpbiB0cmVlLXNoYWtpbmdcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWwgPSBjLmVsbTtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gZWwuc3R5bGU7XG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCAoZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgaGFzTW92ZShlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAgICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAgICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgICAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICAgICAgICBjb25zdCBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICAgICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKChjbHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgICAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICAgICAgICBjb25zdCBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgfVxufTtcbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzKGMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgICAgICBjLmVsbS5fbW92ZUNiKCk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgICAgICBjLmVsbS5fZW50ZXJDYigpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uKGMpIHtcbiAgICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uKGMpIHtcbiAgICBjb25zdCBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICAgIGNvbnN0IG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gICAgY29uc3QgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICAgIGNvbnN0IGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gICAgaWYgKGR4IHx8IGR5KSB7XG4gICAgICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHMgPSBjLmVsbS5zdHlsZTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtkeH1weCwke2R5fXB4KWA7XG4gICAgICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gICAgVHJhbnNpdGlvbixcbiAgICBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZS5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZS5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZS5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5WdWUucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKGVsLCBoeWRyYXRpbmcpIHtcbiAgICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZyk7XG59O1xuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoaW5Ccm93c2VyKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgICAgICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICAgICAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKCdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKGBZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuYCArXG4gICAgICAgICAgICAgICAgYE1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5gICtcbiAgICAgICAgICAgICAgICBgU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxgKTtcbiAgICAgICAgfVxuICAgIH0sIDApO1xufVxuXG5leHRlbmQoVnVlLCB2Y2EpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZ1ZTtcbiIsImlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi92dWUucnVudGltZS5jb21tb24ucHJvZC5qcycpXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vdnVlLnJ1bnRpbWUuY29tbW9uLmRldi5qcycpXG59XG4iLCIvKiFcbiAqIFZ1ZS5qcyB2Mi43LjE0XG4gKiAoYykgMjAxNC0yMDIyIEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qIVxuICogVnVlLmpzIHYyLjcuMTRcbiAqIChjKSAyMDE0LTIwMjIgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7Y29uc3QgdD1PYmplY3QuZnJlZXplKHt9KSxlPUFycmF5LmlzQXJyYXk7ZnVuY3Rpb24gbih0KXtyZXR1cm4gbnVsbD09dH1mdW5jdGlvbiBvKHQpe3JldHVybiBudWxsIT10fWZ1bmN0aW9uIHIodCl7cmV0dXJuITA9PT10fWZ1bmN0aW9uIHModCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR8fFwibnVtYmVyXCI9PXR5cGVvZiB0fHxcInN5bWJvbFwiPT10eXBlb2YgdHx8XCJib29sZWFuXCI9PXR5cGVvZiB0fWZ1bmN0aW9uIGkodCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdH1mdW5jdGlvbiBjKHQpe3JldHVybiBudWxsIT09dCYmXCJvYmplY3RcIj09dHlwZW9mIHR9Y29uc3QgYT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO2Z1bmN0aW9uIGwodCl7cmV0dXJuXCJbb2JqZWN0IE9iamVjdF1cIj09PWEuY2FsbCh0KX1mdW5jdGlvbiB1KHQpe2NvbnN0IGU9cGFyc2VGbG9hdChTdHJpbmcodCkpO3JldHVybiBlPj0wJiZNYXRoLmZsb29yKGUpPT09ZSYmaXNGaW5pdGUodCl9ZnVuY3Rpb24gZih0KXtyZXR1cm4gbyh0KSYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC50aGVuJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmNhdGNofWZ1bmN0aW9uIGQodCl7cmV0dXJuIG51bGw9PXQ/XCJcIjpBcnJheS5pc0FycmF5KHQpfHxsKHQpJiZ0LnRvU3RyaW5nPT09YT9KU09OLnN0cmluZ2lmeSh0LG51bGwsMik6U3RyaW5nKHQpfWZ1bmN0aW9uIHAodCl7Y29uc3QgZT1wYXJzZUZsb2F0KHQpO3JldHVybiBpc05hTihlKT90OmV9ZnVuY3Rpb24gaCh0LGUpe2NvbnN0IG49T2JqZWN0LmNyZWF0ZShudWxsKSxvPXQuc3BsaXQoXCIsXCIpO2ZvcihsZXQgdD0wO3Q8by5sZW5ndGg7dCsrKW5bb1t0XV09ITA7cmV0dXJuIGU/dD0+blt0LnRvTG93ZXJDYXNlKCldOnQ9Pm5bdF19Y29uc3QgbT1oKFwia2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXNcIik7ZnVuY3Rpb24gXyh0LGUpe2NvbnN0IG49dC5sZW5ndGg7aWYobil7aWYoZT09PXRbbi0xXSlyZXR1cm4gdm9pZCh0Lmxlbmd0aD1uLTEpO2NvbnN0IG89dC5pbmRleE9mKGUpO2lmKG8+LTEpcmV0dXJuIHQuc3BsaWNlKG8sMSl9fWNvbnN0IHY9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtmdW5jdGlvbiB5KHQsZSl7cmV0dXJuIHYuY2FsbCh0LGUpfWZ1bmN0aW9uIGcodCl7Y29uc3QgZT1PYmplY3QuY3JlYXRlKG51bGwpO3JldHVybiBmdW5jdGlvbihuKXtyZXR1cm4gZVtuXXx8KGVbbl09dChuKSl9fWNvbnN0IGI9Ly0oXFx3KS9nLCQ9ZygodD0+dC5yZXBsYWNlKGIsKCh0LGUpPT5lP2UudG9VcHBlckNhc2UoKTpcIlwiKSkpKSx3PWcoKHQ9PnQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrdC5zbGljZSgxKSkpLEM9L1xcQihbQS1aXSkvZyx4PWcoKHQ9PnQucmVwbGFjZShDLFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpKTtjb25zdCBrPUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kP2Z1bmN0aW9uKHQsZSl7cmV0dXJuIHQuYmluZChlKX06ZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKG4pe2NvbnN0IG89YXJndW1lbnRzLmxlbmd0aDtyZXR1cm4gbz9vPjE/dC5hcHBseShlLGFyZ3VtZW50cyk6dC5jYWxsKGUsbik6dC5jYWxsKGUpfXJldHVybiBuLl9sZW5ndGg9dC5sZW5ndGgsbn07ZnVuY3Rpb24gTyh0LGUpe2U9ZXx8MDtsZXQgbj10Lmxlbmd0aC1lO2NvbnN0IG89bmV3IEFycmF5KG4pO2Zvcig7bi0tOylvW25dPXRbbitlXTtyZXR1cm4gb31mdW5jdGlvbiBTKHQsZSl7Zm9yKGNvbnN0IG4gaW4gZSl0W25dPWVbbl07cmV0dXJuIHR9ZnVuY3Rpb24gaih0KXtjb25zdCBlPXt9O2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKXRbbl0mJlMoZSx0W25dKTtyZXR1cm4gZX1mdW5jdGlvbiBBKHQsZSxuKXt9Y29uc3QgVD0odCxlLG4pPT4hMSxFPXQ9PnQ7ZnVuY3Rpb24gUCh0LGUpe2lmKHQ9PT1lKXJldHVybiEwO2NvbnN0IG49Yyh0KSxvPWMoZSk7aWYoIW58fCFvKXJldHVybiFuJiYhbyYmU3RyaW5nKHQpPT09U3RyaW5nKGUpO3RyeXtjb25zdCBuPUFycmF5LmlzQXJyYXkodCksbz1BcnJheS5pc0FycmF5KGUpO2lmKG4mJm8pcmV0dXJuIHQubGVuZ3RoPT09ZS5sZW5ndGgmJnQuZXZlcnkoKCh0LG4pPT5QKHQsZVtuXSkpKTtpZih0IGluc3RhbmNlb2YgRGF0ZSYmZSBpbnN0YW5jZW9mIERhdGUpcmV0dXJuIHQuZ2V0VGltZSgpPT09ZS5nZXRUaW1lKCk7aWYobnx8bylyZXR1cm4hMTt7Y29uc3Qgbj1PYmplY3Qua2V5cyh0KSxvPU9iamVjdC5rZXlzKGUpO3JldHVybiBuLmxlbmd0aD09PW8ubGVuZ3RoJiZuLmV2ZXJ5KChuPT5QKHRbbl0sZVtuXSkpKX19Y2F0Y2godCl7cmV0dXJuITF9fWZ1bmN0aW9uIEkodCxlKXtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKylpZihQKHRbbl0sZSkpcmV0dXJuIG47cmV0dXJuLTF9ZnVuY3Rpb24gRCh0KXtsZXQgZT0hMTtyZXR1cm4gZnVuY3Rpb24oKXtlfHwoZT0hMCx0LmFwcGx5KHRoaXMsYXJndW1lbnRzKSl9fWZ1bmN0aW9uIE4odCxlKXtyZXR1cm4gdD09PWU/MD09PXQmJjEvdCE9MS9lOnQ9PXR8fGU9PWV9Y29uc3QgTT1bXCJjb21wb25lbnRcIixcImRpcmVjdGl2ZVwiLFwiZmlsdGVyXCJdLFI9W1wiYmVmb3JlQ3JlYXRlXCIsXCJjcmVhdGVkXCIsXCJiZWZvcmVNb3VudFwiLFwibW91bnRlZFwiLFwiYmVmb3JlVXBkYXRlXCIsXCJ1cGRhdGVkXCIsXCJiZWZvcmVEZXN0cm95XCIsXCJkZXN0cm95ZWRcIixcImFjdGl2YXRlZFwiLFwiZGVhY3RpdmF0ZWRcIixcImVycm9yQ2FwdHVyZWRcIixcInNlcnZlclByZWZldGNoXCIsXCJyZW5kZXJUcmFja2VkXCIsXCJyZW5kZXJUcmlnZ2VyZWRcIl07dmFyIEw9e29wdGlvbk1lcmdlU3RyYXRlZ2llczpPYmplY3QuY3JlYXRlKG51bGwpLHNpbGVudDohMSxwcm9kdWN0aW9uVGlwOiExLGRldnRvb2xzOiExLHBlcmZvcm1hbmNlOiExLGVycm9ySGFuZGxlcjpudWxsLHdhcm5IYW5kbGVyOm51bGwsaWdub3JlZEVsZW1lbnRzOltdLGtleUNvZGVzOk9iamVjdC5jcmVhdGUobnVsbCksaXNSZXNlcnZlZFRhZzpULGlzUmVzZXJ2ZWRBdHRyOlQsaXNVbmtub3duRWxlbWVudDpULGdldFRhZ05hbWVzcGFjZTpBLHBhcnNlUGxhdGZvcm1UYWdOYW1lOkUsbXVzdFVzZVByb3A6VCxhc3luYzohMCxfbGlmZWN5Y2xlSG9va3M6Un07ZnVuY3Rpb24gRih0KXtjb25zdCBlPSh0K1wiXCIpLmNoYXJDb2RlQXQoMCk7cmV0dXJuIDM2PT09ZXx8OTU9PT1lfWZ1bmN0aW9uIFUodCxlLG4sbyl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bixlbnVtZXJhYmxlOiEhbyx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9KX1jb25zdCBCPW5ldyBSZWdFeHAoYFteJHsvYS16QS1aXFx1MDBCN1xcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwM0YtXFx1MjA0MFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRC8uc291cmNlfS4kX1xcXFxkXWApO2NvbnN0IFY9XCJfX3Byb3RvX19cImlue30sej1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93LEg9eiYmd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSxXPUgmJi9tc2llfHRyaWRlbnQvLnRlc3QoSCksSz1IJiZILmluZGV4T2YoXCJtc2llIDkuMFwiKT4wLHE9SCYmSC5pbmRleE9mKFwiZWRnZS9cIik+MDtIJiZILmluZGV4T2YoXCJhbmRyb2lkXCIpO2NvbnN0IEc9SCYmL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KEgpO0gmJi9jaHJvbWVcXC9cXGQrLy50ZXN0KEgpLEgmJi9waGFudG9tanMvLnRlc3QoSCk7Y29uc3QgWj1IJiZILm1hdGNoKC9maXJlZm94XFwvKFxcZCspLyksSj17fS53YXRjaDtsZXQgWCxRPSExO2lmKHopdHJ5e2NvbnN0IHQ9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJwYXNzaXZlXCIse2dldCgpe1E9ITB9fSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0LXBhc3NpdmVcIixudWxsLHQpfWNhdGNoKHQpe31jb25zdCBZPSgpPT4odm9pZCAwPT09WCYmKFg9IXomJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWwmJihnbG9iYWwucHJvY2VzcyYmXCJzZXJ2ZXJcIj09PWdsb2JhbC5wcm9jZXNzLmVudi5WVUVfRU5WKSksWCksdHQ9eiYmd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187ZnVuY3Rpb24gZXQodCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmL25hdGl2ZSBjb2RlLy50ZXN0KHQudG9TdHJpbmcoKSl9Y29uc3QgbnQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmZXQoU3ltYm9sKSYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFJlZmxlY3QmJmV0KFJlZmxlY3Qub3duS2V5cyk7bGV0IG90O290PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTZXQmJmV0KFNldCk/U2V0OmNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5zZXQ9T2JqZWN0LmNyZWF0ZShudWxsKX1oYXModCl7cmV0dXJuITA9PT10aGlzLnNldFt0XX1hZGQodCl7dGhpcy5zZXRbdF09ITB9Y2xlYXIoKXt0aGlzLnNldD1PYmplY3QuY3JlYXRlKG51bGwpfX07bGV0IHJ0PW51bGw7ZnVuY3Rpb24gc3QodD1udWxsKXt0fHxydCYmcnQuX3Njb3BlLm9mZigpLHJ0PXQsdCYmdC5fc2NvcGUub24oKX1jbGFzcyBpdHtjb25zdHJ1Y3Rvcih0LGUsbixvLHIscyxpLGMpe3RoaXMudGFnPXQsdGhpcy5kYXRhPWUsdGhpcy5jaGlsZHJlbj1uLHRoaXMudGV4dD1vLHRoaXMuZWxtPXIsdGhpcy5ucz12b2lkIDAsdGhpcy5jb250ZXh0PXMsdGhpcy5mbkNvbnRleHQ9dm9pZCAwLHRoaXMuZm5PcHRpb25zPXZvaWQgMCx0aGlzLmZuU2NvcGVJZD12b2lkIDAsdGhpcy5rZXk9ZSYmZS5rZXksdGhpcy5jb21wb25lbnRPcHRpb25zPWksdGhpcy5jb21wb25lbnRJbnN0YW5jZT12b2lkIDAsdGhpcy5wYXJlbnQ9dm9pZCAwLHRoaXMucmF3PSExLHRoaXMuaXNTdGF0aWM9ITEsdGhpcy5pc1Jvb3RJbnNlcnQ9ITAsdGhpcy5pc0NvbW1lbnQ9ITEsdGhpcy5pc0Nsb25lZD0hMSx0aGlzLmlzT25jZT0hMSx0aGlzLmFzeW5jRmFjdG9yeT1jLHRoaXMuYXN5bmNNZXRhPXZvaWQgMCx0aGlzLmlzQXN5bmNQbGFjZWhvbGRlcj0hMX1nZXQgY2hpbGQoKXtyZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZX19Y29uc3QgY3Q9KHQ9XCJcIik9Pntjb25zdCBlPW5ldyBpdDtyZXR1cm4gZS50ZXh0PXQsZS5pc0NvbW1lbnQ9ITAsZX07ZnVuY3Rpb24gYXQodCl7cmV0dXJuIG5ldyBpdCh2b2lkIDAsdm9pZCAwLHZvaWQgMCxTdHJpbmcodCkpfWZ1bmN0aW9uIGx0KHQpe2NvbnN0IGU9bmV3IGl0KHQudGFnLHQuZGF0YSx0LmNoaWxkcmVuJiZ0LmNoaWxkcmVuLnNsaWNlKCksdC50ZXh0LHQuZWxtLHQuY29udGV4dCx0LmNvbXBvbmVudE9wdGlvbnMsdC5hc3luY0ZhY3RvcnkpO3JldHVybiBlLm5zPXQubnMsZS5pc1N0YXRpYz10LmlzU3RhdGljLGUua2V5PXQua2V5LGUuaXNDb21tZW50PXQuaXNDb21tZW50LGUuZm5Db250ZXh0PXQuZm5Db250ZXh0LGUuZm5PcHRpb25zPXQuZm5PcHRpb25zLGUuZm5TY29wZUlkPXQuZm5TY29wZUlkLGUuYXN5bmNNZXRhPXQuYXN5bmNNZXRhLGUuaXNDbG9uZWQ9ITAsZX1sZXQgdXQ9MDtjb25zdCBmdD1bXTtjbGFzcyBkdHtjb25zdHJ1Y3Rvcigpe3RoaXMuX3BlbmRpbmc9ITEsdGhpcy5pZD11dCsrLHRoaXMuc3Vicz1bXX1hZGRTdWIodCl7dGhpcy5zdWJzLnB1c2godCl9cmVtb3ZlU3ViKHQpe3RoaXMuc3Vic1t0aGlzLnN1YnMuaW5kZXhPZih0KV09bnVsbCx0aGlzLl9wZW5kaW5nfHwodGhpcy5fcGVuZGluZz0hMCxmdC5wdXNoKHRoaXMpKX1kZXBlbmQodCl7ZHQudGFyZ2V0JiZkdC50YXJnZXQuYWRkRGVwKHRoaXMpfW5vdGlmeSh0KXtjb25zdCBlPXRoaXMuc3Vicy5maWx0ZXIoKHQ9PnQpKTtmb3IobGV0IHQ9MCxuPWUubGVuZ3RoO3Q8bjt0Kyspe2VbdF0udXBkYXRlKCl9fX1kdC50YXJnZXQ9bnVsbDtjb25zdCBwdD1bXTtmdW5jdGlvbiBodCh0KXtwdC5wdXNoKHQpLGR0LnRhcmdldD10fWZ1bmN0aW9uIG10KCl7cHQucG9wKCksZHQudGFyZ2V0PXB0W3B0Lmxlbmd0aC0xXX1jb25zdCBfdD1BcnJheS5wcm90b3R5cGUsdnQ9T2JqZWN0LmNyZWF0ZShfdCk7W1wicHVzaFwiLFwicG9wXCIsXCJzaGlmdFwiLFwidW5zaGlmdFwiLFwic3BsaWNlXCIsXCJzb3J0XCIsXCJyZXZlcnNlXCJdLmZvckVhY2goKGZ1bmN0aW9uKHQpe2NvbnN0IGU9X3RbdF07VSh2dCx0LChmdW5jdGlvbiguLi5uKXtjb25zdCBvPWUuYXBwbHkodGhpcyxuKSxyPXRoaXMuX19vYl9fO2xldCBzO3N3aXRjaCh0KXtjYXNlXCJwdXNoXCI6Y2FzZVwidW5zaGlmdFwiOnM9bjticmVhaztjYXNlXCJzcGxpY2VcIjpzPW4uc2xpY2UoMil9cmV0dXJuIHMmJnIub2JzZXJ2ZUFycmF5KHMpLHIuZGVwLm5vdGlmeSgpLG99KSl9KSk7Y29uc3QgeXQ9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModnQpLGd0PXt9O2xldCBidD0hMDtmdW5jdGlvbiAkdCh0KXtidD10fWNvbnN0IHd0PXtub3RpZnk6QSxkZXBlbmQ6QSxhZGRTdWI6QSxyZW1vdmVTdWI6QX07Y2xhc3MgQ3R7Y29uc3RydWN0b3IodCxuPSExLG89ITEpe2lmKHRoaXMudmFsdWU9dCx0aGlzLnNoYWxsb3c9bix0aGlzLm1vY2s9byx0aGlzLmRlcD1vP3d0Om5ldyBkdCx0aGlzLnZtQ291bnQ9MCxVKHQsXCJfX29iX19cIix0aGlzKSxlKHQpKXtpZighbylpZihWKXQuX19wcm90b19fPXZ0O2Vsc2UgZm9yKGxldCBlPTAsbj15dC5sZW5ndGg7ZTxuO2UrKyl7Y29uc3Qgbj15dFtlXTtVKHQsbix2dFtuXSl9bnx8dGhpcy5vYnNlcnZlQXJyYXkodCl9ZWxzZXtjb25zdCBlPU9iamVjdC5rZXlzKHQpO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKXtrdCh0LGVbcl0sZ3Qsdm9pZCAwLG4sbyl9fX1vYnNlcnZlQXJyYXkodCl7Zm9yKGxldCBlPTAsbj10Lmxlbmd0aDtlPG47ZSsrKXh0KHRbZV0sITEsdGhpcy5tb2NrKX19ZnVuY3Rpb24geHQodCxuLG8pe3JldHVybiB0JiZ5KHQsXCJfX29iX19cIikmJnQuX19vYl9fIGluc3RhbmNlb2YgQ3Q/dC5fX29iX186IWJ0fHwhbyYmWSgpfHwhZSh0KSYmIWwodCl8fCFPYmplY3QuaXNFeHRlbnNpYmxlKHQpfHx0Ll9fdl9za2lwfHxEdCh0KXx8dCBpbnN0YW5jZW9mIGl0P3ZvaWQgMDpuZXcgQ3QodCxuLG8pfWZ1bmN0aW9uIGt0KHQsbixvLHIscyxpKXtjb25zdCBjPW5ldyBkdCxhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxuKTtpZihhJiYhMT09PWEuY29uZmlndXJhYmxlKXJldHVybjtjb25zdCBsPWEmJmEuZ2V0LHU9YSYmYS5zZXQ7bCYmIXV8fG8hPT1ndCYmMiE9PWFyZ3VtZW50cy5sZW5ndGh8fChvPXRbbl0pO2xldCBmPSFzJiZ4dChvLCExLGkpO3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtjb25zdCBuPWw/bC5jYWxsKHQpOm87cmV0dXJuIGR0LnRhcmdldCYmKGMuZGVwZW5kKCksZiYmKGYuZGVwLmRlcGVuZCgpLGUobikmJmp0KG4pKSksRHQobikmJiFzP24udmFsdWU6bn0sc2V0OmZ1bmN0aW9uKGUpe2NvbnN0IG49bD9sLmNhbGwodCk6bztpZihOKG4sZSkpe2lmKHUpdS5jYWxsKHQsZSk7ZWxzZXtpZihsKXJldHVybjtpZighcyYmRHQobikmJiFEdChlKSlyZXR1cm4gdm9pZChuLnZhbHVlPWUpO289ZX1mPSFzJiZ4dChlLCExLGkpLGMubm90aWZ5KCl9fX0pLGN9ZnVuY3Rpb24gT3QodCxuLG8pe2lmKEl0KHQpKXJldHVybjtjb25zdCByPXQuX19vYl9fO3JldHVybiBlKHQpJiZ1KG4pPyh0Lmxlbmd0aD1NYXRoLm1heCh0Lmxlbmd0aCxuKSx0LnNwbGljZShuLDEsbyksciYmIXIuc2hhbGxvdyYmci5tb2NrJiZ4dChvLCExLCEwKSxvKTpuIGluIHQmJiEobiBpbiBPYmplY3QucHJvdG90eXBlKT8odFtuXT1vLG8pOnQuX2lzVnVlfHxyJiZyLnZtQ291bnQ/bzpyPyhrdChyLnZhbHVlLG4sbyx2b2lkIDAsci5zaGFsbG93LHIubW9jayksci5kZXAubm90aWZ5KCksbyk6KHRbbl09byxvKX1mdW5jdGlvbiBTdCh0LG4pe2lmKGUodCkmJnUobikpcmV0dXJuIHZvaWQgdC5zcGxpY2UobiwxKTtjb25zdCBvPXQuX19vYl9fO3QuX2lzVnVlfHxvJiZvLnZtQ291bnR8fEl0KHQpfHx5KHQsbikmJihkZWxldGUgdFtuXSxvJiZvLmRlcC5ub3RpZnkoKSl9ZnVuY3Rpb24ganQodCl7Zm9yKGxldCBuLG89MCxyPXQubGVuZ3RoO288cjtvKyspbj10W29dLG4mJm4uX19vYl9fJiZuLl9fb2JfXy5kZXAuZGVwZW5kKCksZShuKSYmanQobil9ZnVuY3Rpb24gQXQodCl7cmV0dXJuIFR0KHQsITApLFUodCxcIl9fdl9pc1NoYWxsb3dcIiwhMCksdH1mdW5jdGlvbiBUdCh0LGUpe0l0KHQpfHx4dCh0LGUsWSgpKX1mdW5jdGlvbiBFdCh0KXtyZXR1cm4gSXQodCk/RXQodC5fX3ZfcmF3KTohKCF0fHwhdC5fX29iX18pfWZ1bmN0aW9uIFB0KHQpe3JldHVybiEoIXR8fCF0Ll9fdl9pc1NoYWxsb3cpfWZ1bmN0aW9uIEl0KHQpe3JldHVybiEoIXR8fCF0Ll9fdl9pc1JlYWRvbmx5KX1mdW5jdGlvbiBEdCh0KXtyZXR1cm4hKCF0fHwhMCE9PXQuX192X2lzUmVmKX1mdW5jdGlvbiBOdCh0LGUpe2lmKER0KHQpKXJldHVybiB0O2NvbnN0IG49e307cmV0dXJuIFUobixcIl9fdl9pc1JlZlwiLCEwKSxVKG4sXCJfX3ZfaXNTaGFsbG93XCIsZSksVShuLFwiZGVwXCIsa3QobixcInZhbHVlXCIsdCxudWxsLGUsWSgpKSksbn1mdW5jdGlvbiBNdCh0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OigpPT57Y29uc3QgdD1lW25dO2lmKER0KHQpKXJldHVybiB0LnZhbHVlO3tjb25zdCBlPXQmJnQuX19vYl9fO3JldHVybiBlJiZlLmRlcC5kZXBlbmQoKSx0fX0sc2V0OnQ9Pntjb25zdCBvPWVbbl07RHQobykmJiFEdCh0KT9vLnZhbHVlPXQ6ZVtuXT10fX0pfWZ1bmN0aW9uIFJ0KHQsZSxuKXtjb25zdCBvPXRbZV07aWYoRHQobykpcmV0dXJuIG87Y29uc3Qgcj17Z2V0IHZhbHVlKCl7Y29uc3Qgbz10W2VdO3JldHVybiB2b2lkIDA9PT1vP246b30sc2V0IHZhbHVlKG4pe3RbZV09bn19O3JldHVybiBVKHIsXCJfX3ZfaXNSZWZcIiwhMCkscn1mdW5jdGlvbiBMdCh0KXtyZXR1cm4gRnQodCwhMSl9ZnVuY3Rpb24gRnQodCxlKXtpZighbCh0KSlyZXR1cm4gdDtpZihJdCh0KSlyZXR1cm4gdDtjb25zdCBuPWU/XCJfX3ZfcmF3VG9TaGFsbG93UmVhZG9ubHlcIjpcIl9fdl9yYXdUb1JlYWRvbmx5XCIsbz10W25dO2lmKG8pcmV0dXJuIG87Y29uc3Qgcj1PYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSk7VSh0LG4sciksVShyLFwiX192X2lzUmVhZG9ubHlcIiwhMCksVShyLFwiX192X3Jhd1wiLHQpLER0KHQpJiZVKHIsXCJfX3ZfaXNSZWZcIiwhMCksKGV8fFB0KHQpKSYmVShyLFwiX192X2lzU2hhbGxvd1wiLCEwKTtjb25zdCBzPU9iamVjdC5rZXlzKHQpO2ZvcihsZXQgbj0wO248cy5sZW5ndGg7bisrKVV0KHIsdCxzW25dLGUpO3JldHVybiByfWZ1bmN0aW9uIFV0KHQsZSxuLG8pe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4se2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldCgpe2NvbnN0IHQ9ZVtuXTtyZXR1cm4gb3x8IWwodCk/dDpMdCh0KX0sc2V0KCl7fX0pfWZ1bmN0aW9uIEJ0KHQsZSl7cmV0dXJuIHp0KHQsbnVsbCx7Zmx1c2g6XCJwb3N0XCJ9KX1jb25zdCBWdD17fTtmdW5jdGlvbiB6dChuLG8se2ltbWVkaWF0ZTpyLGRlZXA6cyxmbHVzaDpjPVwicHJlXCIsb25UcmFjazphLG9uVHJpZ2dlcjpsfT10KXtjb25zdCB1PXJ0LGY9KHQsZSxuPW51bGwpPT5JZSh0LG51bGwsbix1LGUpO2xldCBkLHAsaD0hMSxtPSExO2lmKER0KG4pPyhkPSgpPT5uLnZhbHVlLGg9UHQobikpOkV0KG4pPyhkPSgpPT4obi5fX29iX18uZGVwLmRlcGVuZCgpLG4pLHM9ITApOmUobik/KG09ITAsaD1uLnNvbWUoKHQ9PkV0KHQpfHxQdCh0KSkpLGQ9KCk9Pm4ubWFwKCh0PT5EdCh0KT90LnZhbHVlOkV0KHQpP29uKHQpOmkodCk/Zih0LFwid2F0Y2hlciBnZXR0ZXJcIik6dm9pZCAwKSkpOmQ9aShuKT9vPygpPT5mKG4sXCJ3YXRjaGVyIGdldHRlclwiKTooKT0+e2lmKCF1fHwhdS5faXNEZXN0cm95ZWQpcmV0dXJuIHAmJnAoKSxmKG4sXCJ3YXRjaGVyXCIsW19dKX06QSxvJiZzKXtjb25zdCB0PWQ7ZD0oKT0+b24odCgpKX1sZXQgXz10PT57cD12Lm9uU3RvcD0oKT0+e2YodCxcIndhdGNoZXIgY2xlYW51cFwiKX19O2lmKFkoKSlyZXR1cm4gXz1BLG8/ciYmZihvLFwid2F0Y2hlciBjYWxsYmFja1wiLFtkKCksbT9bXTp2b2lkIDAsX10pOmQoKSxBO2NvbnN0IHY9bmV3IGFuKHJ0LGQsQSx7bGF6eTohMH0pO3Yubm9SZWN1cnNlPSFvO2xldCB5PW0/W106VnQ7cmV0dXJuIHYucnVuPSgpPT57aWYodi5hY3RpdmUpaWYobyl7Y29uc3QgdD12LmdldCgpOyhzfHxofHwobT90LnNvbWUoKCh0LGUpPT5OKHQseVtlXSkpKTpOKHQseSkpKSYmKHAmJnAoKSxmKG8sXCJ3YXRjaGVyIGNhbGxiYWNrXCIsW3QseT09PVZ0P3ZvaWQgMDp5LF9dKSx5PXQpfWVsc2Ugdi5nZXQoKX0sXCJzeW5jXCI9PT1jP3YudXBkYXRlPXYucnVuOlwicG9zdFwiPT09Yz8odi5wb3N0PSEwLHYudXBkYXRlPSgpPT5Bbih2KSk6di51cGRhdGU9KCk9PntpZih1JiZ1PT09cnQmJiF1Ll9pc01vdW50ZWQpe2NvbnN0IHQ9dS5fcHJlV2F0Y2hlcnN8fCh1Ll9wcmVXYXRjaGVycz1bXSk7dC5pbmRleE9mKHYpPDAmJnQucHVzaCh2KX1lbHNlIEFuKHYpfSxvP3I/di5ydW4oKTp5PXYuZ2V0KCk6XCJwb3N0XCI9PT1jJiZ1P3UuJG9uY2UoXCJob29rOm1vdW50ZWRcIiwoKCk9PnYuZ2V0KCkpKTp2LmdldCgpLCgpPT57di50ZWFyZG93bigpfX1sZXQgSHQ7Y2xhc3MgV3R7Y29uc3RydWN0b3IodD0hMSl7dGhpcy5kZXRhY2hlZD10LHRoaXMuYWN0aXZlPSEwLHRoaXMuZWZmZWN0cz1bXSx0aGlzLmNsZWFudXBzPVtdLHRoaXMucGFyZW50PUh0LCF0JiZIdCYmKHRoaXMuaW5kZXg9KEh0LnNjb3Blc3x8KEh0LnNjb3Blcz1bXSkpLnB1c2godGhpcyktMSl9cnVuKHQpe2lmKHRoaXMuYWN0aXZlKXtjb25zdCBlPUh0O3RyeXtyZXR1cm4gSHQ9dGhpcyx0KCl9ZmluYWxseXtIdD1lfX19b24oKXtIdD10aGlzfW9mZigpe0h0PXRoaXMucGFyZW50fXN0b3AodCl7aWYodGhpcy5hY3RpdmUpe2xldCBlLG47Zm9yKGU9MCxuPXRoaXMuZWZmZWN0cy5sZW5ndGg7ZTxuO2UrKyl0aGlzLmVmZmVjdHNbZV0udGVhcmRvd24oKTtmb3IoZT0wLG49dGhpcy5jbGVhbnVwcy5sZW5ndGg7ZTxuO2UrKyl0aGlzLmNsZWFudXBzW2VdKCk7aWYodGhpcy5zY29wZXMpZm9yKGU9MCxuPXRoaXMuc2NvcGVzLmxlbmd0aDtlPG47ZSsrKXRoaXMuc2NvcGVzW2VdLnN0b3AoITApO2lmKCF0aGlzLmRldGFjaGVkJiZ0aGlzLnBhcmVudCYmIXQpe2NvbnN0IHQ9dGhpcy5wYXJlbnQuc2NvcGVzLnBvcCgpO3QmJnQhPT10aGlzJiYodGhpcy5wYXJlbnQuc2NvcGVzW3RoaXMuaW5kZXhdPXQsdC5pbmRleD10aGlzLmluZGV4KX10aGlzLnBhcmVudD12b2lkIDAsdGhpcy5hY3RpdmU9ITF9fX1mdW5jdGlvbiBLdCh0KXtjb25zdCBlPXQuX3Byb3ZpZGVkLG49dC4kcGFyZW50JiZ0LiRwYXJlbnQuX3Byb3ZpZGVkO3JldHVybiBuPT09ZT90Ll9wcm92aWRlZD1PYmplY3QuY3JlYXRlKG4pOmV9Y29uc3QgcXQ9ZygodD0+e2NvbnN0IGU9XCImXCI9PT10LmNoYXJBdCgwKSxuPVwiflwiPT09KHQ9ZT90LnNsaWNlKDEpOnQpLmNoYXJBdCgwKSxvPVwiIVwiPT09KHQ9bj90LnNsaWNlKDEpOnQpLmNoYXJBdCgwKTtyZXR1cm57bmFtZTp0PW8/dC5zbGljZSgxKTp0LG9uY2U6bixjYXB0dXJlOm8scGFzc2l2ZTplfX0pKTtmdW5jdGlvbiBHdCh0LG4pe2Z1bmN0aW9uIG8oKXtjb25zdCB0PW8uZm5zO2lmKCFlKHQpKXJldHVybiBJZSh0LG51bGwsYXJndW1lbnRzLG4sXCJ2LW9uIGhhbmRsZXJcIik7e2NvbnN0IGU9dC5zbGljZSgpO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKUllKGVbdF0sbnVsbCxhcmd1bWVudHMsbixcInYtb24gaGFuZGxlclwiKX19cmV0dXJuIG8uZm5zPXQsb31mdW5jdGlvbiBadCh0LGUsbyxzLGksYyl7bGV0IGEsbCx1LGY7Zm9yKGEgaW4gdClsPXRbYV0sdT1lW2FdLGY9cXQoYSksbihsKXx8KG4odSk/KG4obC5mbnMpJiYobD10W2FdPUd0KGwsYykpLHIoZi5vbmNlKSYmKGw9dFthXT1pKGYubmFtZSxsLGYuY2FwdHVyZSkpLG8oZi5uYW1lLGwsZi5jYXB0dXJlLGYucGFzc2l2ZSxmLnBhcmFtcykpOmwhPT11JiYodS5mbnM9bCx0W2FdPXUpKTtmb3IoYSBpbiBlKW4odFthXSkmJihmPXF0KGEpLHMoZi5uYW1lLGVbYV0sZi5jYXB0dXJlKSl9ZnVuY3Rpb24gSnQodCxlLHMpe2xldCBpO3QgaW5zdGFuY2VvZiBpdCYmKHQ9dC5kYXRhLmhvb2t8fCh0LmRhdGEuaG9vaz17fSkpO2NvbnN0IGM9dFtlXTtmdW5jdGlvbiBhKCl7cy5hcHBseSh0aGlzLGFyZ3VtZW50cyksXyhpLmZucyxhKX1uKGMpP2k9R3QoW2FdKTpvKGMuZm5zKSYmcihjLm1lcmdlZCk/KGk9YyxpLmZucy5wdXNoKGEpKTppPUd0KFtjLGFdKSxpLm1lcmdlZD0hMCx0W2VdPWl9ZnVuY3Rpb24gWHQodCxlLG4scixzKXtpZihvKGUpKXtpZih5KGUsbikpcmV0dXJuIHRbbl09ZVtuXSxzfHxkZWxldGUgZVtuXSwhMDtpZih5KGUscikpcmV0dXJuIHRbbl09ZVtyXSxzfHxkZWxldGUgZVtyXSwhMH1yZXR1cm4hMX1mdW5jdGlvbiBRdCh0KXtyZXR1cm4gcyh0KT9bYXQodCldOmUodCk/dGUodCk6dm9pZCAwfWZ1bmN0aW9uIFl0KHQpe3JldHVybiBvKHQpJiZvKHQudGV4dCkmJiExPT09dC5pc0NvbW1lbnR9ZnVuY3Rpb24gdGUodCxpKXtjb25zdCBjPVtdO2xldCBhLGwsdSxmO2ZvcihhPTA7YTx0Lmxlbmd0aDthKyspbD10W2FdLG4obCl8fFwiYm9vbGVhblwiPT10eXBlb2YgbHx8KHU9Yy5sZW5ndGgtMSxmPWNbdV0sZShsKT9sLmxlbmd0aD4wJiYobD10ZShsLGAke2l8fFwiXCJ9XyR7YX1gKSxZdChsWzBdKSYmWXQoZikmJihjW3VdPWF0KGYudGV4dCtsWzBdLnRleHQpLGwuc2hpZnQoKSksYy5wdXNoLmFwcGx5KGMsbCkpOnMobCk/WXQoZik/Y1t1XT1hdChmLnRleHQrbCk6XCJcIiE9PWwmJmMucHVzaChhdChsKSk6WXQobCkmJll0KGYpP2NbdV09YXQoZi50ZXh0K2wudGV4dCk6KHIodC5faXNWTGlzdCkmJm8obC50YWcpJiZuKGwua2V5KSYmbyhpKSYmKGwua2V5PWBfX3ZsaXN0JHtpfV8ke2F9X19gKSxjLnB1c2gobCkpKTtyZXR1cm4gY31mdW5jdGlvbiBlZSh0LG4pe2xldCByLHMsaSxhLGw9bnVsbDtpZihlKHQpfHxcInN0cmluZ1wiPT10eXBlb2YgdClmb3IobD1uZXcgQXJyYXkodC5sZW5ndGgpLHI9MCxzPXQubGVuZ3RoO3I8cztyKyspbFtyXT1uKHRbcl0scik7ZWxzZSBpZihcIm51bWJlclwiPT10eXBlb2YgdClmb3IobD1uZXcgQXJyYXkodCkscj0wO3I8dDtyKyspbFtyXT1uKHIrMSxyKTtlbHNlIGlmKGModCkpaWYobnQmJnRbU3ltYm9sLml0ZXJhdG9yXSl7bD1bXTtjb25zdCBlPXRbU3ltYm9sLml0ZXJhdG9yXSgpO2xldCBvPWUubmV4dCgpO2Zvcig7IW8uZG9uZTspbC5wdXNoKG4oby52YWx1ZSxsLmxlbmd0aCkpLG89ZS5uZXh0KCl9ZWxzZSBmb3IoaT1PYmplY3Qua2V5cyh0KSxsPW5ldyBBcnJheShpLmxlbmd0aCkscj0wLHM9aS5sZW5ndGg7cjxzO3IrKylhPWlbcl0sbFtyXT1uKHRbYV0sYSxyKTtyZXR1cm4gbyhsKXx8KGw9W10pLGwuX2lzVkxpc3Q9ITAsbH1mdW5jdGlvbiBuZSh0LGUsbixvKXtjb25zdCByPXRoaXMuJHNjb3BlZFNsb3RzW3RdO2xldCBzO3I/KG49bnx8e30sbyYmKG49UyhTKHt9LG8pLG4pKSxzPXIobil8fChpKGUpP2UoKTplKSk6cz10aGlzLiRzbG90c1t0XXx8KGkoZSk/ZSgpOmUpO2NvbnN0IGM9biYmbi5zbG90O3JldHVybiBjP3RoaXMuJGNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiLHtzbG90OmN9LHMpOnN9ZnVuY3Rpb24gb2UodCl7cmV0dXJuIHFuKHRoaXMuJG9wdGlvbnMsXCJmaWx0ZXJzXCIsdCl8fEV9ZnVuY3Rpb24gcmUodCxuKXtyZXR1cm4gZSh0KT8tMT09PXQuaW5kZXhPZihuKTp0IT09bn1mdW5jdGlvbiBzZSh0LGUsbixvLHIpe2NvbnN0IHM9TC5rZXlDb2Rlc1tlXXx8bjtyZXR1cm4gciYmbyYmIUwua2V5Q29kZXNbZV0/cmUocixvKTpzP3JlKHMsdCk6bz94KG8pIT09ZTp2b2lkIDA9PT10fWZ1bmN0aW9uIGllKHQsbixvLHIscyl7aWYobylpZihjKG8pKXtsZXQgaTtlKG8pJiYobz1qKG8pKTtmb3IoY29uc3QgZSBpbiBvKXtpZihcImNsYXNzXCI9PT1lfHxcInN0eWxlXCI9PT1lfHxtKGUpKWk9dDtlbHNle2NvbnN0IG89dC5hdHRycyYmdC5hdHRycy50eXBlO2k9cnx8TC5tdXN0VXNlUHJvcChuLG8sZSk/dC5kb21Qcm9wc3x8KHQuZG9tUHJvcHM9e30pOnQuYXR0cnN8fCh0LmF0dHJzPXt9KX1jb25zdCBjPSQoZSksYT14KGUpO2lmKCEoYyBpbiBpKSYmIShhIGluIGkpJiYoaVtlXT1vW2VdLHMpKXsodC5vbnx8KHQub249e30pKVtgdXBkYXRlOiR7ZX1gXT1mdW5jdGlvbih0KXtvW2VdPXR9fX19ZWxzZTtyZXR1cm4gdH1mdW5jdGlvbiBjZSh0LGUpe2NvbnN0IG49dGhpcy5fc3RhdGljVHJlZXN8fCh0aGlzLl9zdGF0aWNUcmVlcz1bXSk7bGV0IG89blt0XTtyZXR1cm4gbyYmIWV8fChvPW5bdF09dGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbdF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSx0aGlzLl9jLHRoaXMpLGxlKG8sYF9fc3RhdGljX18ke3R9YCwhMSkpLG99ZnVuY3Rpb24gYWUodCxlLG4pe3JldHVybiBsZSh0LGBfX29uY2VfXyR7ZX0ke24/YF8ke259YDpcIlwifWAsITApLHR9ZnVuY3Rpb24gbGUodCxuLG8pe2lmKGUodCkpZm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXSYmXCJzdHJpbmdcIiE9dHlwZW9mIHRbZV0mJnVlKHRbZV0sYCR7bn1fJHtlfWAsbyk7ZWxzZSB1ZSh0LG4sbyl9ZnVuY3Rpb24gdWUodCxlLG4pe3QuaXNTdGF0aWM9ITAsdC5rZXk9ZSx0LmlzT25jZT1ufWZ1bmN0aW9uIGZlKHQsZSl7aWYoZSlpZihsKGUpKXtjb25zdCBuPXQub249dC5vbj9TKHt9LHQub24pOnt9O2Zvcihjb25zdCB0IGluIGUpe2NvbnN0IG89blt0XSxyPWVbdF07blt0XT1vP1tdLmNvbmNhdChvLHIpOnJ9fWVsc2U7cmV0dXJuIHR9ZnVuY3Rpb24gZGUodCxuLG8scil7bj1ufHx7JHN0YWJsZTohb307Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspe2NvbnN0IHM9dFtyXTtlKHMpP2RlKHMsbixvKTpzJiYocy5wcm94eSYmKHMuZm4ucHJveHk9ITApLG5bcy5rZXldPXMuZm4pfXJldHVybiByJiYobi4ka2V5PXIpLG59ZnVuY3Rpb24gcGUodCxlKXtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rPTIpe2NvbnN0IG89ZVtuXTtcInN0cmluZ1wiPT10eXBlb2YgbyYmbyYmKHRbZVtuXV09ZVtuKzFdKX1yZXR1cm4gdH1mdW5jdGlvbiBoZSh0LGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0P2UrdDp0fWZ1bmN0aW9uIG1lKHQpe3QuX289YWUsdC5fbj1wLHQuX3M9ZCx0Ll9sPWVlLHQuX3Q9bmUsdC5fcT1QLHQuX2k9SSx0Ll9tPWNlLHQuX2Y9b2UsdC5faz1zZSx0Ll9iPWllLHQuX3Y9YXQsdC5fZT1jdCx0Ll91PWRlLHQuX2c9ZmUsdC5fZD1wZSx0Ll9wPWhlfWZ1bmN0aW9uIF9lKHQsZSl7aWYoIXR8fCF0Lmxlbmd0aClyZXR1cm57fTtjb25zdCBuPXt9O2ZvcihsZXQgbz0wLHI9dC5sZW5ndGg7bzxyO28rKyl7Y29uc3Qgcj10W29dLHM9ci5kYXRhO2lmKHMmJnMuYXR0cnMmJnMuYXR0cnMuc2xvdCYmZGVsZXRlIHMuYXR0cnMuc2xvdCxyLmNvbnRleHQhPT1lJiZyLmZuQ29udGV4dCE9PWV8fCFzfHxudWxsPT1zLnNsb3QpKG4uZGVmYXVsdHx8KG4uZGVmYXVsdD1bXSkpLnB1c2gocik7ZWxzZXtjb25zdCB0PXMuc2xvdCxlPW5bdF18fChuW3RdPVtdKTtcInRlbXBsYXRlXCI9PT1yLnRhZz9lLnB1c2guYXBwbHkoZSxyLmNoaWxkcmVufHxbXSk6ZS5wdXNoKHIpfX1mb3IoY29uc3QgdCBpbiBuKW5bdF0uZXZlcnkodmUpJiZkZWxldGUgblt0XTtyZXR1cm4gbn1mdW5jdGlvbiB2ZSh0KXtyZXR1cm4gdC5pc0NvbW1lbnQmJiF0LmFzeW5jRmFjdG9yeXx8XCIgXCI9PT10LnRleHR9ZnVuY3Rpb24geWUodCl7cmV0dXJuIHQuaXNDb21tZW50JiZ0LmFzeW5jRmFjdG9yeX1mdW5jdGlvbiBnZShlLG4sbyxyKXtsZXQgcztjb25zdCBpPU9iamVjdC5rZXlzKG8pLmxlbmd0aD4wLGM9bj8hIW4uJHN0YWJsZTohaSxhPW4mJm4uJGtleTtpZihuKXtpZihuLl9ub3JtYWxpemVkKXJldHVybiBuLl9ub3JtYWxpemVkO2lmKGMmJnImJnIhPT10JiZhPT09ci4ka2V5JiYhaSYmIXIuJGhhc05vcm1hbClyZXR1cm4gcjtzPXt9O2Zvcihjb25zdCB0IGluIG4pblt0XSYmXCIkXCIhPT10WzBdJiYoc1t0XT1iZShlLG8sdCxuW3RdKSl9ZWxzZSBzPXt9O2Zvcihjb25zdCB0IGluIG8pdCBpbiBzfHwoc1t0XT0kZShvLHQpKTtyZXR1cm4gbiYmT2JqZWN0LmlzRXh0ZW5zaWJsZShuKSYmKG4uX25vcm1hbGl6ZWQ9cyksVShzLFwiJHN0YWJsZVwiLGMpLFUocyxcIiRrZXlcIixhKSxVKHMsXCIkaGFzTm9ybWFsXCIsaSksc31mdW5jdGlvbiBiZSh0LG4sbyxyKXtjb25zdCBzPWZ1bmN0aW9uKCl7Y29uc3Qgbj1ydDtzdCh0KTtsZXQgbz1hcmd1bWVudHMubGVuZ3RoP3IuYXBwbHkobnVsbCxhcmd1bWVudHMpOnIoe30pO289byYmXCJvYmplY3RcIj09dHlwZW9mIG8mJiFlKG8pP1tvXTpRdChvKTtjb25zdCBzPW8mJm9bMF07cmV0dXJuIHN0KG4pLG8mJighc3x8MT09PW8ubGVuZ3RoJiZzLmlzQ29tbWVudCYmIXllKHMpKT92b2lkIDA6b307cmV0dXJuIHIucHJveHkmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8se2dldDpzLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksc31mdW5jdGlvbiAkZSh0LGUpe3JldHVybigpPT50W2VdfWZ1bmN0aW9uIHdlKGUpe3JldHVybntnZXQgYXR0cnMoKXtpZighZS5fYXR0cnNQcm94eSl7Y29uc3Qgbj1lLl9hdHRyc1Byb3h5PXt9O1UobixcIl92X2F0dHJfcHJveHlcIiwhMCksQ2UobixlLiRhdHRycyx0LGUsXCIkYXR0cnNcIil9cmV0dXJuIGUuX2F0dHJzUHJveHl9LGdldCBsaXN0ZW5lcnMoKXtpZighZS5fbGlzdGVuZXJzUHJveHkpe0NlKGUuX2xpc3RlbmVyc1Byb3h5PXt9LGUuJGxpc3RlbmVycyx0LGUsXCIkbGlzdGVuZXJzXCIpfXJldHVybiBlLl9saXN0ZW5lcnNQcm94eX0sZ2V0IHNsb3RzKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3QuX3Nsb3RzUHJveHl8fGtlKHQuX3Nsb3RzUHJveHk9e30sdC4kc2NvcGVkU2xvdHMpO3JldHVybiB0Ll9zbG90c1Byb3h5fShlKX0sZW1pdDprKGUuJGVtaXQsZSksZXhwb3NlKHQpe3QmJk9iamVjdC5rZXlzKHQpLmZvckVhY2goKG49Pk10KGUsdCxuKSkpfX19ZnVuY3Rpb24gQ2UodCxlLG4sbyxyKXtsZXQgcz0hMTtmb3IoY29uc3QgaSBpbiBlKWkgaW4gdD9lW2ldIT09bltpXSYmKHM9ITApOihzPSEwLHhlKHQsaSxvLHIpKTtmb3IoY29uc3QgbiBpbiB0KW4gaW4gZXx8KHM9ITAsZGVsZXRlIHRbbl0pO3JldHVybiBzfWZ1bmN0aW9uIHhlKHQsZSxuLG8pe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDooKT0+bltvXVtlXX0pfWZ1bmN0aW9uIGtlKHQsZSl7Zm9yKGNvbnN0IG4gaW4gZSl0W25dPWVbbl07Zm9yKGNvbnN0IG4gaW4gdCluIGluIGV8fGRlbGV0ZSB0W25dfWZ1bmN0aW9uIE9lKCl7Y29uc3QgdD1ydDtyZXR1cm4gdC5fc2V0dXBDb250ZXh0fHwodC5fc2V0dXBDb250ZXh0PXdlKHQpKX1sZXQgU2U9bnVsbDtmdW5jdGlvbiBqZSh0LGUpe3JldHVybih0Ll9fZXNNb2R1bGV8fG50JiZcIk1vZHVsZVwiPT09dFtTeW1ib2wudG9TdHJpbmdUYWddKSYmKHQ9dC5kZWZhdWx0KSxjKHQpP2UuZXh0ZW5kKHQpOnR9ZnVuY3Rpb24gQWUodCl7aWYoZSh0KSlmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgbj10W2VdO2lmKG8obikmJihvKG4uY29tcG9uZW50T3B0aW9ucyl8fHllKG4pKSlyZXR1cm4gbn19ZnVuY3Rpb24gVGUodCxuLGEsbCx1LGYpe3JldHVybihlKGEpfHxzKGEpKSYmKHU9bCxsPWEsYT12b2lkIDApLHIoZikmJih1PTIpLGZ1bmN0aW9uKHQsbixyLHMsYSl7aWYobyhyKSYmbyhyLl9fb2JfXykpcmV0dXJuIGN0KCk7byhyKSYmbyhyLmlzKSYmKG49ci5pcyk7aWYoIW4pcmV0dXJuIGN0KCk7ZShzKSYmaShzWzBdKSYmKChyPXJ8fHt9KS5zY29wZWRTbG90cz17ZGVmYXVsdDpzWzBdfSxzLmxlbmd0aD0wKTsyPT09YT9zPVF0KHMpOjE9PT1hJiYocz1mdW5jdGlvbih0KXtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKylpZihlKHRbbl0pKXJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLHQpO3JldHVybiB0fShzKSk7bGV0IGwsdTtpZihcInN0cmluZ1wiPT10eXBlb2Ygbil7bGV0IGU7dT10LiR2bm9kZSYmdC4kdm5vZGUubnN8fEwuZ2V0VGFnTmFtZXNwYWNlKG4pLGw9TC5pc1Jlc2VydmVkVGFnKG4pP25ldyBpdChMLnBhcnNlUGxhdGZvcm1UYWdOYW1lKG4pLHIscyx2b2lkIDAsdm9pZCAwLHQpOnImJnIucHJlfHwhbyhlPXFuKHQuJG9wdGlvbnMsXCJjb21wb25lbnRzXCIsbikpP25ldyBpdChuLHIscyx2b2lkIDAsdm9pZCAwLHQpOlJuKGUscix0LHMsbil9ZWxzZSBsPVJuKG4scix0LHMpO3JldHVybiBlKGwpP2w6byhsKT8obyh1KSYmRWUobCx1KSxvKHIpJiZmdW5jdGlvbih0KXtjKHQuc3R5bGUpJiZvbih0LnN0eWxlKTtjKHQuY2xhc3MpJiZvbih0LmNsYXNzKX0ociksbCk6Y3QoKX0odCxuLGEsbCx1KX1mdW5jdGlvbiBFZSh0LGUscyl7aWYodC5ucz1lLFwiZm9yZWlnbk9iamVjdFwiPT09dC50YWcmJihlPXZvaWQgMCxzPSEwKSxvKHQuY2hpbGRyZW4pKWZvcihsZXQgaT0wLGM9dC5jaGlsZHJlbi5sZW5ndGg7aTxjO2krKyl7Y29uc3QgYz10LmNoaWxkcmVuW2ldO28oYy50YWcpJiYobihjLm5zKXx8cihzKSYmXCJzdmdcIiE9PWMudGFnKSYmRWUoYyxlLHMpfX1mdW5jdGlvbiBQZSh0LGUsbil7aHQoKTt0cnl7aWYoZSl7bGV0IG89ZTtmb3IoO289by4kcGFyZW50Oyl7Y29uc3Qgcj1vLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7aWYocilmb3IobGV0IHM9MDtzPHIubGVuZ3RoO3MrKyl0cnl7aWYoITE9PT1yW3NdLmNhbGwobyx0LGUsbikpcmV0dXJufWNhdGNoKHQpe0RlKHQsbyxcImVycm9yQ2FwdHVyZWQgaG9va1wiKX19fURlKHQsZSxuKX1maW5hbGx5e210KCl9fWZ1bmN0aW9uIEllKHQsZSxuLG8scil7bGV0IHM7dHJ5e3M9bj90LmFwcGx5KGUsbik6dC5jYWxsKGUpLHMmJiFzLl9pc1Z1ZSYmZihzKSYmIXMuX2hhbmRsZWQmJihzLmNhdGNoKCh0PT5QZSh0LG8scitcIiAoUHJvbWlzZS9hc3luYylcIikpKSxzLl9oYW5kbGVkPSEwKX1jYXRjaCh0KXtQZSh0LG8scil9cmV0dXJuIHN9ZnVuY3Rpb24gRGUodCxlLG4pe2lmKEwuZXJyb3JIYW5kbGVyKXRyeXtyZXR1cm4gTC5lcnJvckhhbmRsZXIuY2FsbChudWxsLHQsZSxuKX1jYXRjaChlKXtlIT09dCYmTmUoZSl9TmUodCl9ZnVuY3Rpb24gTmUodCxlLG4pe2lmKCF6fHxcInVuZGVmaW5lZFwiPT10eXBlb2YgY29uc29sZSl0aHJvdyB0O2NvbnNvbGUuZXJyb3IodCl9bGV0IE1lPSExO2NvbnN0IFJlPVtdO2xldCBMZSxGZT0hMTtmdW5jdGlvbiBVZSgpe0ZlPSExO2NvbnN0IHQ9UmUuc2xpY2UoMCk7UmUubGVuZ3RoPTA7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXSgpfWlmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBQcm9taXNlJiZldChQcm9taXNlKSl7Y29uc3QgdD1Qcm9taXNlLnJlc29sdmUoKTtMZT0oKT0+e3QudGhlbihVZSksRyYmc2V0VGltZW91dChBKX0sTWU9ITB9ZWxzZSBpZihXfHxcInVuZGVmaW5lZFwiPT10eXBlb2YgTXV0YXRpb25PYnNlcnZlcnx8IWV0KE11dGF0aW9uT2JzZXJ2ZXIpJiZcIltvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXVwiIT09TXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpKUxlPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZXRJbW1lZGlhdGUmJmV0KHNldEltbWVkaWF0ZSk/KCk9PntzZXRJbW1lZGlhdGUoVWUpfTooKT0+e3NldFRpbWVvdXQoVWUsMCl9O2Vsc2V7bGV0IHQ9MTtjb25zdCBlPW5ldyBNdXRhdGlvbk9ic2VydmVyKFVlKSxuPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyh0KSk7ZS5vYnNlcnZlKG4se2NoYXJhY3RlckRhdGE6ITB9KSxMZT0oKT0+e3Q9KHQrMSklMixuLmRhdGE9U3RyaW5nKHQpfSxNZT0hMH1mdW5jdGlvbiBCZSh0LGUpe2xldCBuO2lmKFJlLnB1c2goKCgpPT57aWYodCl0cnl7dC5jYWxsKGUpfWNhdGNoKHQpe1BlKHQsZSxcIm5leHRUaWNrXCIpfWVsc2UgbiYmbihlKX0pKSxGZXx8KEZlPSEwLExlKCkpLCF0JiZcInVuZGVmaW5lZFwiIT10eXBlb2YgUHJvbWlzZSlyZXR1cm4gbmV3IFByb21pc2UoKHQ9PntuPXR9KSl9ZnVuY3Rpb24gVmUodCl7cmV0dXJuKGUsbj1ydCk9PntpZihuKXJldHVybiBmdW5jdGlvbih0LGUsbil7Y29uc3Qgbz10LiRvcHRpb25zO29bZV09em4ob1tlXSxuKX0obix0LGUpfX1jb25zdCB6ZT1WZShcImJlZm9yZU1vdW50XCIpLEhlPVZlKFwibW91bnRlZFwiKSxXZT1WZShcImJlZm9yZVVwZGF0ZVwiKSxLZT1WZShcInVwZGF0ZWRcIikscWU9VmUoXCJiZWZvcmVEZXN0cm95XCIpLEdlPVZlKFwiZGVzdHJveWVkXCIpLFplPVZlKFwiYWN0aXZhdGVkXCIpLEplPVZlKFwiZGVhY3RpdmF0ZWRcIiksWGU9VmUoXCJzZXJ2ZXJQcmVmZXRjaFwiKSxRZT1WZShcInJlbmRlclRyYWNrZWRcIiksWWU9VmUoXCJyZW5kZXJUcmlnZ2VyZWRcIiksdG49VmUoXCJlcnJvckNhcHR1cmVkXCIpO3ZhciBlbj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCx2ZXJzaW9uOlwiMi43LjE0XCIsZGVmaW5lQ29tcG9uZW50OmZ1bmN0aW9uKHQpe3JldHVybiB0fSxyZWY6ZnVuY3Rpb24odCl7cmV0dXJuIE50KHQsITEpfSxzaGFsbG93UmVmOmZ1bmN0aW9uKHQpe3JldHVybiBOdCh0LCEwKX0saXNSZWY6RHQsdG9SZWY6UnQsdG9SZWZzOmZ1bmN0aW9uKHQpe2NvbnN0IG49ZSh0KT9uZXcgQXJyYXkodC5sZW5ndGgpOnt9O2Zvcihjb25zdCBlIGluIHQpbltlXT1SdCh0LGUpO3JldHVybiBufSx1bnJlZjpmdW5jdGlvbih0KXtyZXR1cm4gRHQodCk/dC52YWx1ZTp0fSxwcm94eVJlZnM6ZnVuY3Rpb24odCl7aWYoRXQodCkpcmV0dXJuIHQ7Y29uc3QgZT17fSxuPU9iamVjdC5rZXlzKHQpO2ZvcihsZXQgbz0wO288bi5sZW5ndGg7bysrKU10KGUsdCxuW29dKTtyZXR1cm4gZX0sY3VzdG9tUmVmOmZ1bmN0aW9uKHQpe2NvbnN0IGU9bmV3IGR0LHtnZXQ6bixzZXQ6b309dCgoKCk9PntlLmRlcGVuZCgpfSksKCgpPT57ZS5ub3RpZnkoKX0pKSxyPXtnZXQgdmFsdWUoKXtyZXR1cm4gbigpfSxzZXQgdmFsdWUodCl7byh0KX19O3JldHVybiBVKHIsXCJfX3ZfaXNSZWZcIiwhMCkscn0sdHJpZ2dlclJlZjpmdW5jdGlvbih0KXt0LmRlcCYmdC5kZXAubm90aWZ5KCl9LHJlYWN0aXZlOmZ1bmN0aW9uKHQpe3JldHVybiBUdCh0LCExKSx0fSxpc1JlYWN0aXZlOkV0LGlzUmVhZG9ubHk6SXQsaXNTaGFsbG93OlB0LGlzUHJveHk6ZnVuY3Rpb24odCl7cmV0dXJuIEV0KHQpfHxJdCh0KX0sc2hhbGxvd1JlYWN0aXZlOkF0LG1hcmtSYXc6ZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5pc0V4dGVuc2libGUodCkmJlUodCxcIl9fdl9za2lwXCIsITApLHR9LHRvUmF3OmZ1bmN0aW9uIHQoZSl7Y29uc3Qgbj1lJiZlLl9fdl9yYXc7cmV0dXJuIG4/dChuKTplfSxyZWFkb25seTpMdCxzaGFsbG93UmVhZG9ubHk6ZnVuY3Rpb24odCl7cmV0dXJuIEZ0KHQsITApfSxjb21wdXRlZDpmdW5jdGlvbih0LGUpe2xldCBuLG87Y29uc3Qgcj1pKHQpO3I/KG49dCxvPUEpOihuPXQuZ2V0LG89dC5zZXQpO2NvbnN0IHM9WSgpP251bGw6bmV3IGFuKHJ0LG4sQSx7bGF6eTohMH0pLGM9e2VmZmVjdDpzLGdldCB2YWx1ZSgpe3JldHVybiBzPyhzLmRpcnR5JiZzLmV2YWx1YXRlKCksZHQudGFyZ2V0JiZzLmRlcGVuZCgpLHMudmFsdWUpOm4oKX0sc2V0IHZhbHVlKHQpe28odCl9fTtyZXR1cm4gVShjLFwiX192X2lzUmVmXCIsITApLFUoYyxcIl9fdl9pc1JlYWRvbmx5XCIsciksY30sd2F0Y2g6ZnVuY3Rpb24odCxlLG4pe3JldHVybiB6dCh0LGUsbil9LHdhdGNoRWZmZWN0OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHp0KHQsbnVsbCxlKX0sd2F0Y2hQb3N0RWZmZWN0OkJ0LHdhdGNoU3luY0VmZmVjdDpmdW5jdGlvbih0LGUpe3JldHVybiB6dCh0LG51bGwse2ZsdXNoOlwic3luY1wifSl9LEVmZmVjdFNjb3BlOld0LGVmZmVjdFNjb3BlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgV3QodCl9LG9uU2NvcGVEaXNwb3NlOmZ1bmN0aW9uKHQpe0h0JiZIdC5jbGVhbnVwcy5wdXNoKHQpfSxnZXRDdXJyZW50U2NvcGU6ZnVuY3Rpb24oKXtyZXR1cm4gSHR9LHByb3ZpZGU6ZnVuY3Rpb24odCxlKXtydCYmKEt0KHJ0KVt0XT1lKX0saW5qZWN0OmZ1bmN0aW9uKHQsZSxuPSExKXtjb25zdCBvPXJ0O2lmKG8pe2NvbnN0IHI9by4kcGFyZW50JiZvLiRwYXJlbnQuX3Byb3ZpZGVkO2lmKHImJnQgaW4gcilyZXR1cm4gclt0XTtpZihhcmd1bWVudHMubGVuZ3RoPjEpcmV0dXJuIG4mJmkoZSk/ZS5jYWxsKG8pOmV9fSxoOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gVGUocnQsdCxlLG4sMiwhMCl9LGdldEN1cnJlbnRJbnN0YW5jZTpmdW5jdGlvbigpe3JldHVybiBydCYme3Byb3h5OnJ0fX0sdXNlU2xvdHM6ZnVuY3Rpb24oKXtyZXR1cm4gT2UoKS5zbG90c30sdXNlQXR0cnM6ZnVuY3Rpb24oKXtyZXR1cm4gT2UoKS5hdHRyc30sdXNlTGlzdGVuZXJzOmZ1bmN0aW9uKCl7cmV0dXJuIE9lKCkubGlzdGVuZXJzfSxtZXJnZURlZmF1bHRzOmZ1bmN0aW9uKHQsbil7Y29uc3Qgbz1lKHQpP3QucmVkdWNlKCgodCxlKT0+KHRbZV09e30sdCkpLHt9KTp0O2Zvcihjb25zdCB0IGluIG4pe2NvbnN0IHI9b1t0XTtyP2Uocil8fGkocik/b1t0XT17dHlwZTpyLGRlZmF1bHQ6blt0XX06ci5kZWZhdWx0PW5bdF06bnVsbD09PXImJihvW3RdPXtkZWZhdWx0Om5bdF19KX1yZXR1cm4gb30sbmV4dFRpY2s6QmUsc2V0Ok90LGRlbDpTdCx1c2VDc3NNb2R1bGU6ZnVuY3Rpb24oZT1cIiRzdHlsZVwiKXt7aWYoIXJ0KXJldHVybiB0O2NvbnN0IG49cnRbZV07cmV0dXJuIG58fHR9fSx1c2VDc3NWYXJzOmZ1bmN0aW9uKHQpe2lmKCF6KXJldHVybjtjb25zdCBlPXJ0O2UmJkJ0KCgoKT0+e2NvbnN0IG49ZS4kZWwsbz10KGUsZS5fc2V0dXBQcm94eSk7aWYobiYmMT09PW4ubm9kZVR5cGUpe2NvbnN0IHQ9bi5zdHlsZTtmb3IoY29uc3QgZSBpbiBvKXQuc2V0UHJvcGVydHkoYC0tJHtlfWAsb1tlXSl9fSkpfSxkZWZpbmVBc3luY0NvbXBvbmVudDpmdW5jdGlvbih0KXtpKHQpJiYodD17bG9hZGVyOnR9KTtjb25zdHtsb2FkZXI6ZSxsb2FkaW5nQ29tcG9uZW50Om4sZXJyb3JDb21wb25lbnQ6byxkZWxheTpyPTIwMCx0aW1lb3V0OnMsc3VzcGVuc2libGU6Yz0hMSxvbkVycm9yOmF9PXQ7bGV0IGw9bnVsbCx1PTA7Y29uc3QgZj0oKT0+e2xldCB0O3JldHVybiBsfHwodD1sPWUoKS5jYXRjaCgodD0+e2lmKHQ9dCBpbnN0YW5jZW9mIEVycm9yP3Q6bmV3IEVycm9yKFN0cmluZyh0KSksYSlyZXR1cm4gbmV3IFByb21pc2UoKChlLG4pPT57YSh0LCgoKT0+ZSgodSsrLGw9bnVsbCxmKCkpKSksKCgpPT5uKHQpKSx1KzEpfSkpO3Rocm93IHR9KSkudGhlbigoZT0+dCE9PWwmJmw/bDooZSYmKGUuX19lc01vZHVsZXx8XCJNb2R1bGVcIj09PWVbU3ltYm9sLnRvU3RyaW5nVGFnXSkmJihlPWUuZGVmYXVsdCksZSkpKSl9O3JldHVybigpPT4oe2NvbXBvbmVudDpmKCksZGVsYXk6cix0aW1lb3V0OnMsZXJyb3I6byxsb2FkaW5nOm59KX0sb25CZWZvcmVNb3VudDp6ZSxvbk1vdW50ZWQ6SGUsb25CZWZvcmVVcGRhdGU6V2Usb25VcGRhdGVkOktlLG9uQmVmb3JlVW5tb3VudDpxZSxvblVubW91bnRlZDpHZSxvbkFjdGl2YXRlZDpaZSxvbkRlYWN0aXZhdGVkOkplLG9uU2VydmVyUHJlZmV0Y2g6WGUsb25SZW5kZXJUcmFja2VkOlFlLG9uUmVuZGVyVHJpZ2dlcmVkOlllLG9uRXJyb3JDYXB0dXJlZDpmdW5jdGlvbih0LGU9cnQpe3RuKHQsZSl9fSk7Y29uc3Qgbm49bmV3IG90O2Z1bmN0aW9uIG9uKHQpe3JldHVybiBybih0LG5uKSxubi5jbGVhcigpLHR9ZnVuY3Rpb24gcm4odCxuKXtsZXQgbyxyO2NvbnN0IHM9ZSh0KTtpZighKCFzJiYhYyh0KXx8dC5fX3Zfc2tpcHx8T2JqZWN0LmlzRnJvemVuKHQpfHx0IGluc3RhbmNlb2YgaXQpKXtpZih0Ll9fb2JfXyl7Y29uc3QgZT10Ll9fb2JfXy5kZXAuaWQ7aWYobi5oYXMoZSkpcmV0dXJuO24uYWRkKGUpfWlmKHMpZm9yKG89dC5sZW5ndGg7by0tOylybih0W29dLG4pO2Vsc2UgaWYoRHQodCkpcm4odC52YWx1ZSxuKTtlbHNlIGZvcihyPU9iamVjdC5rZXlzKHQpLG89ci5sZW5ndGg7by0tOylybih0W3Jbb11dLG4pfX1sZXQgc24sY249MDtjbGFzcyBhbntjb25zdHJ1Y3Rvcih0LGUsbixvLHIpeyFmdW5jdGlvbih0LGU9SHQpe2UmJmUuYWN0aXZlJiZlLmVmZmVjdHMucHVzaCh0KX0odGhpcyxIdCYmIUh0Ll92bT9IdDp0P3QuX3Njb3BlOnZvaWQgMCksKHRoaXMudm09dCkmJnImJih0Ll93YXRjaGVyPXRoaXMpLG8/KHRoaXMuZGVlcD0hIW8uZGVlcCx0aGlzLnVzZXI9ISFvLnVzZXIsdGhpcy5sYXp5PSEhby5sYXp5LHRoaXMuc3luYz0hIW8uc3luYyx0aGlzLmJlZm9yZT1vLmJlZm9yZSk6dGhpcy5kZWVwPXRoaXMudXNlcj10aGlzLmxhenk9dGhpcy5zeW5jPSExLHRoaXMuY2I9bix0aGlzLmlkPSsrY24sdGhpcy5hY3RpdmU9ITAsdGhpcy5wb3N0PSExLHRoaXMuZGlydHk9dGhpcy5sYXp5LHRoaXMuZGVwcz1bXSx0aGlzLm5ld0RlcHM9W10sdGhpcy5kZXBJZHM9bmV3IG90LHRoaXMubmV3RGVwSWRzPW5ldyBvdCx0aGlzLmV4cHJlc3Npb249XCJcIixpKGUpP3RoaXMuZ2V0dGVyPWU6KHRoaXMuZ2V0dGVyPWZ1bmN0aW9uKHQpe2lmKEIudGVzdCh0KSlyZXR1cm47Y29uc3QgZT10LnNwbGl0KFwiLlwiKTtyZXR1cm4gZnVuY3Rpb24odCl7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspe2lmKCF0KXJldHVybjt0PXRbZVtuXV19cmV0dXJuIHR9fShlKSx0aGlzLmdldHRlcnx8KHRoaXMuZ2V0dGVyPUEpKSx0aGlzLnZhbHVlPXRoaXMubGF6eT92b2lkIDA6dGhpcy5nZXQoKX1nZXQoKXtsZXQgdDtodCh0aGlzKTtjb25zdCBlPXRoaXMudm07dHJ5e3Q9dGhpcy5nZXR0ZXIuY2FsbChlLGUpfWNhdGNoKHQpe2lmKCF0aGlzLnVzZXIpdGhyb3cgdDtQZSh0LGUsYGdldHRlciBmb3Igd2F0Y2hlciBcIiR7dGhpcy5leHByZXNzaW9ufVwiYCl9ZmluYWxseXt0aGlzLmRlZXAmJm9uKHQpLG10KCksdGhpcy5jbGVhbnVwRGVwcygpfXJldHVybiB0fWFkZERlcCh0KXtjb25zdCBlPXQuaWQ7dGhpcy5uZXdEZXBJZHMuaGFzKGUpfHwodGhpcy5uZXdEZXBJZHMuYWRkKGUpLHRoaXMubmV3RGVwcy5wdXNoKHQpLHRoaXMuZGVwSWRzLmhhcyhlKXx8dC5hZGRTdWIodGhpcykpfWNsZWFudXBEZXBzKCl7bGV0IHQ9dGhpcy5kZXBzLmxlbmd0aDtmb3IoO3QtLTspe2NvbnN0IGU9dGhpcy5kZXBzW3RdO3RoaXMubmV3RGVwSWRzLmhhcyhlLmlkKXx8ZS5yZW1vdmVTdWIodGhpcyl9bGV0IGU9dGhpcy5kZXBJZHM7dGhpcy5kZXBJZHM9dGhpcy5uZXdEZXBJZHMsdGhpcy5uZXdEZXBJZHM9ZSx0aGlzLm5ld0RlcElkcy5jbGVhcigpLGU9dGhpcy5kZXBzLHRoaXMuZGVwcz10aGlzLm5ld0RlcHMsdGhpcy5uZXdEZXBzPWUsdGhpcy5uZXdEZXBzLmxlbmd0aD0wfXVwZGF0ZSgpe3RoaXMubGF6eT90aGlzLmRpcnR5PSEwOnRoaXMuc3luYz90aGlzLnJ1bigpOkFuKHRoaXMpfXJ1bigpe2lmKHRoaXMuYWN0aXZlKXtjb25zdCB0PXRoaXMuZ2V0KCk7aWYodCE9PXRoaXMudmFsdWV8fGModCl8fHRoaXMuZGVlcCl7Y29uc3QgZT10aGlzLnZhbHVlO2lmKHRoaXMudmFsdWU9dCx0aGlzLnVzZXIpe2NvbnN0IG49YGNhbGxiYWNrIGZvciB3YXRjaGVyIFwiJHt0aGlzLmV4cHJlc3Npb259XCJgO0llKHRoaXMuY2IsdGhpcy52bSxbdCxlXSx0aGlzLnZtLG4pfWVsc2UgdGhpcy5jYi5jYWxsKHRoaXMudm0sdCxlKX19fWV2YWx1YXRlKCl7dGhpcy52YWx1ZT10aGlzLmdldCgpLHRoaXMuZGlydHk9ITF9ZGVwZW5kKCl7bGV0IHQ9dGhpcy5kZXBzLmxlbmd0aDtmb3IoO3QtLTspdGhpcy5kZXBzW3RdLmRlcGVuZCgpfXRlYXJkb3duKCl7aWYodGhpcy52bSYmIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQmJl8odGhpcy52bS5fc2NvcGUuZWZmZWN0cyx0aGlzKSx0aGlzLmFjdGl2ZSl7bGV0IHQ9dGhpcy5kZXBzLmxlbmd0aDtmb3IoO3QtLTspdGhpcy5kZXBzW3RdLnJlbW92ZVN1Yih0aGlzKTt0aGlzLmFjdGl2ZT0hMSx0aGlzLm9uU3RvcCYmdGhpcy5vblN0b3AoKX19fWZ1bmN0aW9uIGxuKHQsZSl7c24uJG9uKHQsZSl9ZnVuY3Rpb24gdW4odCxlKXtzbi4kb2ZmKHQsZSl9ZnVuY3Rpb24gZm4odCxlKXtjb25zdCBuPXNuO3JldHVybiBmdW5jdGlvbiBvKCl7Y29uc3Qgcj1lLmFwcGx5KG51bGwsYXJndW1lbnRzKTtudWxsIT09ciYmbi4kb2ZmKHQsbyl9fWZ1bmN0aW9uIGRuKHQsZSxuKXtzbj10LFp0KGUsbnx8e30sbG4sdW4sZm4sdCksc249dm9pZCAwfWxldCBwbj1udWxsO2Z1bmN0aW9uIGhuKHQpe2NvbnN0IGU9cG47cmV0dXJuIHBuPXQsKCk9Pntwbj1lfX1mdW5jdGlvbiBtbih0KXtmb3IoO3QmJih0PXQuJHBhcmVudCk7KWlmKHQuX2luYWN0aXZlKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIF9uKHQsZSl7aWYoZSl7aWYodC5fZGlyZWN0SW5hY3RpdmU9ITEsbW4odCkpcmV0dXJufWVsc2UgaWYodC5fZGlyZWN0SW5hY3RpdmUpcmV0dXJuO2lmKHQuX2luYWN0aXZlfHxudWxsPT09dC5faW5hY3RpdmUpe3QuX2luYWN0aXZlPSExO2ZvcihsZXQgZT0wO2U8dC4kY2hpbGRyZW4ubGVuZ3RoO2UrKylfbih0LiRjaGlsZHJlbltlXSk7eW4odCxcImFjdGl2YXRlZFwiKX19ZnVuY3Rpb24gdm4odCxlKXtpZighKGUmJih0Ll9kaXJlY3RJbmFjdGl2ZT0hMCxtbih0KSl8fHQuX2luYWN0aXZlKSl7dC5faW5hY3RpdmU9ITA7Zm9yKGxldCBlPTA7ZTx0LiRjaGlsZHJlbi5sZW5ndGg7ZSsrKXZuKHQuJGNoaWxkcmVuW2VdKTt5bih0LFwiZGVhY3RpdmF0ZWRcIil9fWZ1bmN0aW9uIHluKHQsZSxuLG89ITApe2h0KCk7Y29uc3Qgcj1ydDtvJiZzdCh0KTtjb25zdCBzPXQuJG9wdGlvbnNbZV0saT1gJHtlfSBob29rYDtpZihzKWZvcihsZXQgZT0wLG89cy5sZW5ndGg7ZTxvO2UrKylJZShzW2VdLHQsbnx8bnVsbCx0LGkpO3QuX2hhc0hvb2tFdmVudCYmdC4kZW1pdChcImhvb2s6XCIrZSksbyYmc3QociksbXQoKX1jb25zdCBnbj1bXSxibj1bXTtsZXQgJG49e30sd249ITEsQ249ITEseG49MDtsZXQga249MCxPbj1EYXRlLm5vdztpZih6JiYhVyl7Y29uc3QgdD13aW5kb3cucGVyZm9ybWFuY2U7dCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC5ub3cmJk9uKCk+ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKS50aW1lU3RhbXAmJihPbj0oKT0+dC5ub3coKSl9Y29uc3QgU249KHQsZSk9PntpZih0LnBvc3Qpe2lmKCFlLnBvc3QpcmV0dXJuIDF9ZWxzZSBpZihlLnBvc3QpcmV0dXJuLTE7cmV0dXJuIHQuaWQtZS5pZH07ZnVuY3Rpb24gam4oKXtsZXQgdCxlO2Zvcihrbj1PbigpLENuPSEwLGduLnNvcnQoU24pLHhuPTA7eG48Z24ubGVuZ3RoO3huKyspdD1nblt4bl0sdC5iZWZvcmUmJnQuYmVmb3JlKCksZT10LmlkLCRuW2VdPW51bGwsdC5ydW4oKTtjb25zdCBuPWJuLnNsaWNlKCksbz1nbi5zbGljZSgpO3huPWduLmxlbmd0aD1ibi5sZW5ndGg9MCwkbj17fSx3bj1Dbj0hMSxmdW5jdGlvbih0KXtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdLl9pbmFjdGl2ZT0hMCxfbih0W2VdLCEwKX0obiksZnVuY3Rpb24odCl7bGV0IGU9dC5sZW5ndGg7Zm9yKDtlLS07KXtjb25zdCBuPXRbZV0sbz1uLnZtO28mJm8uX3dhdGNoZXI9PT1uJiZvLl9pc01vdW50ZWQmJiFvLl9pc0Rlc3Ryb3llZCYmeW4obyxcInVwZGF0ZWRcIil9fShvKSwoKCk9Pntmb3IobGV0IHQ9MDt0PGZ0Lmxlbmd0aDt0Kyspe2NvbnN0IGU9ZnRbdF07ZS5zdWJzPWUuc3Vicy5maWx0ZXIoKHQ9PnQpKSxlLl9wZW5kaW5nPSExfWZ0Lmxlbmd0aD0wfSkoKSx0dCYmTC5kZXZ0b29scyYmdHQuZW1pdChcImZsdXNoXCIpfWZ1bmN0aW9uIEFuKHQpe2NvbnN0IGU9dC5pZDtpZihudWxsPT0kbltlXSYmKHQhPT1kdC50YXJnZXR8fCF0Lm5vUmVjdXJzZSkpe2lmKCRuW2VdPSEwLENuKXtsZXQgZT1nbi5sZW5ndGgtMTtmb3IoO2U+eG4mJmduW2VdLmlkPnQuaWQ7KWUtLTtnbi5zcGxpY2UoZSsxLDAsdCl9ZWxzZSBnbi5wdXNoKHQpO3dufHwod249ITAsQmUoam4pKX19ZnVuY3Rpb24gVG4odCxlKXtpZih0KXtjb25zdCBuPU9iamVjdC5jcmVhdGUobnVsbCksbz1udD9SZWZsZWN0Lm93bktleXModCk6T2JqZWN0LmtleXModCk7Zm9yKGxldCByPTA7cjxvLmxlbmd0aDtyKyspe2NvbnN0IHM9b1tyXTtpZihcIl9fb2JfX1wiPT09cyljb250aW51ZTtjb25zdCBjPXRbc10uZnJvbTtpZihjIGluIGUuX3Byb3ZpZGVkKW5bc109ZS5fcHJvdmlkZWRbY107ZWxzZSBpZihcImRlZmF1bHRcImluIHRbc10pe2NvbnN0IG89dFtzXS5kZWZhdWx0O25bc109aShvKT9vLmNhbGwoZSk6b319cmV0dXJuIG59fWZ1bmN0aW9uIEVuKG4sbyxzLGksYyl7Y29uc3QgYT1jLm9wdGlvbnM7bGV0IGw7eShpLFwiX3VpZFwiKT8obD1PYmplY3QuY3JlYXRlKGkpLGwuX29yaWdpbmFsPWkpOihsPWksaT1pLl9vcmlnaW5hbCk7Y29uc3QgdT1yKGEuX2NvbXBpbGVkKSxmPSF1O3RoaXMuZGF0YT1uLHRoaXMucHJvcHM9byx0aGlzLmNoaWxkcmVuPXMsdGhpcy5wYXJlbnQ9aSx0aGlzLmxpc3RlbmVycz1uLm9ufHx0LHRoaXMuaW5qZWN0aW9ucz1UbihhLmluamVjdCxpKSx0aGlzLnNsb3RzPSgpPT4odGhpcy4kc2xvdHN8fGdlKGksbi5zY29wZWRTbG90cyx0aGlzLiRzbG90cz1fZShzLGkpKSx0aGlzLiRzbG90cyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJzY29wZWRTbG90c1wiLHtlbnVtZXJhYmxlOiEwLGdldCgpe3JldHVybiBnZShpLG4uc2NvcGVkU2xvdHMsdGhpcy5zbG90cygpKX19KSx1JiYodGhpcy4kb3B0aW9ucz1hLHRoaXMuJHNsb3RzPXRoaXMuc2xvdHMoKSx0aGlzLiRzY29wZWRTbG90cz1nZShpLG4uc2NvcGVkU2xvdHMsdGhpcy4kc2xvdHMpKSxhLl9zY29wZUlkP3RoaXMuX2M9KHQsbixvLHIpPT57Y29uc3Qgcz1UZShsLHQsbixvLHIsZik7cmV0dXJuIHMmJiFlKHMpJiYocy5mblNjb3BlSWQ9YS5fc2NvcGVJZCxzLmZuQ29udGV4dD1pKSxzfTp0aGlzLl9jPSh0LGUsbixvKT0+VGUobCx0LGUsbixvLGYpfWZ1bmN0aW9uIFBuKHQsZSxuLG8scil7Y29uc3Qgcz1sdCh0KTtyZXR1cm4gcy5mbkNvbnRleHQ9bixzLmZuT3B0aW9ucz1vLGUuc2xvdCYmKChzLmRhdGF8fChzLmRhdGE9e30pKS5zbG90PWUuc2xvdCksc31mdW5jdGlvbiBJbih0LGUpe2Zvcihjb25zdCBuIGluIGUpdFskKG4pXT1lW25dfWZ1bmN0aW9uIERuKHQpe3JldHVybiB0Lm5hbWV8fHQuX19uYW1lfHx0Ll9jb21wb25lbnRUYWd9bWUoRW4ucHJvdG90eXBlKTtjb25zdCBObj17aW5pdCh0LGUpe2lmKHQuY29tcG9uZW50SW5zdGFuY2UmJiF0LmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCYmdC5kYXRhLmtlZXBBbGl2ZSl7Y29uc3QgZT10O05uLnByZXBhdGNoKGUsZSl9ZWxzZXsodC5jb21wb25lbnRJbnN0YW5jZT1mdW5jdGlvbih0LGUpe2NvbnN0IG49e19pc0NvbXBvbmVudDohMCxfcGFyZW50Vm5vZGU6dCxwYXJlbnQ6ZX0scj10LmRhdGEuaW5saW5lVGVtcGxhdGU7byhyKSYmKG4ucmVuZGVyPXIucmVuZGVyLG4uc3RhdGljUmVuZGVyRm5zPXIuc3RhdGljUmVuZGVyRm5zKTtyZXR1cm4gbmV3IHQuY29tcG9uZW50T3B0aW9ucy5DdG9yKG4pfSh0LHBuKSkuJG1vdW50KGU/dC5lbG06dm9pZCAwLGUpfX0scHJlcGF0Y2goZSxuKXtjb25zdCBvPW4uY29tcG9uZW50T3B0aW9uczshZnVuY3Rpb24oZSxuLG8scixzKXtjb25zdCBpPXIuZGF0YS5zY29wZWRTbG90cyxjPWUuJHNjb3BlZFNsb3RzLGE9ISEoaSYmIWkuJHN0YWJsZXx8YyE9PXQmJiFjLiRzdGFibGV8fGkmJmUuJHNjb3BlZFNsb3RzLiRrZXkhPT1pLiRrZXl8fCFpJiZlLiRzY29wZWRTbG90cy4ka2V5KTtsZXQgbD0hIShzfHxlLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbnx8YSk7Y29uc3QgdT1lLiR2bm9kZTtlLiRvcHRpb25zLl9wYXJlbnRWbm9kZT1yLGUuJHZub2RlPXIsZS5fdm5vZGUmJihlLl92bm9kZS5wYXJlbnQ9ciksZS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW49cztjb25zdCBmPXIuZGF0YS5hdHRyc3x8dDtlLl9hdHRyc1Byb3h5JiZDZShlLl9hdHRyc1Byb3h5LGYsdS5kYXRhJiZ1LmRhdGEuYXR0cnN8fHQsZSxcIiRhdHRyc1wiKSYmKGw9ITApLGUuJGF0dHJzPWYsbz1vfHx0O2NvbnN0IGQ9ZS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO2lmKGUuX2xpc3RlbmVyc1Byb3h5JiZDZShlLl9saXN0ZW5lcnNQcm94eSxvLGR8fHQsZSxcIiRsaXN0ZW5lcnNcIiksZS4kbGlzdGVuZXJzPWUuJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycz1vLGRuKGUsbyxkKSxuJiZlLiRvcHRpb25zLnByb3BzKXskdCghMSk7Y29uc3QgdD1lLl9wcm9wcyxvPWUuJG9wdGlvbnMuX3Byb3BLZXlzfHxbXTtmb3IobGV0IHI9MDtyPG8ubGVuZ3RoO3IrKyl7Y29uc3Qgcz1vW3JdLGk9ZS4kb3B0aW9ucy5wcm9wczt0W3NdPUduKHMsaSxuLGUpfSR0KCEwKSxlLiRvcHRpb25zLnByb3BzRGF0YT1ufWwmJihlLiRzbG90cz1fZShzLHIuY29udGV4dCksZS4kZm9yY2VVcGRhdGUoKSl9KG4uY29tcG9uZW50SW5zdGFuY2U9ZS5jb21wb25lbnRJbnN0YW5jZSxvLnByb3BzRGF0YSxvLmxpc3RlbmVycyxuLG8uY2hpbGRyZW4pfSxpbnNlcnQodCl7Y29uc3R7Y29udGV4dDplLGNvbXBvbmVudEluc3RhbmNlOm59PXQ7dmFyIG87bi5faXNNb3VudGVkfHwobi5faXNNb3VudGVkPSEwLHluKG4sXCJtb3VudGVkXCIpKSx0LmRhdGEua2VlcEFsaXZlJiYoZS5faXNNb3VudGVkPygobz1uKS5faW5hY3RpdmU9ITEsYm4ucHVzaChvKSk6X24obiwhMCkpfSxkZXN0cm95KHQpe2NvbnN0e2NvbXBvbmVudEluc3RhbmNlOmV9PXQ7ZS5faXNEZXN0cm95ZWR8fCh0LmRhdGEua2VlcEFsaXZlP3ZuKGUsITApOmUuJGRlc3Ryb3koKSl9fSxNbj1PYmplY3Qua2V5cyhObik7ZnVuY3Rpb24gUm4ocyxpLGEsbCx1KXtpZihuKHMpKXJldHVybjtjb25zdCBkPWEuJG9wdGlvbnMuX2Jhc2U7aWYoYyhzKSYmKHM9ZC5leHRlbmQocykpLFwiZnVuY3Rpb25cIiE9dHlwZW9mIHMpcmV0dXJuO2xldCBwO2lmKG4ocy5jaWQpJiYocD1zLHM9ZnVuY3Rpb24odCxlKXtpZihyKHQuZXJyb3IpJiZvKHQuZXJyb3JDb21wKSlyZXR1cm4gdC5lcnJvckNvbXA7aWYobyh0LnJlc29sdmVkKSlyZXR1cm4gdC5yZXNvbHZlZDtjb25zdCBzPVNlO2lmKHMmJm8odC5vd25lcnMpJiYtMT09PXQub3duZXJzLmluZGV4T2YocykmJnQub3duZXJzLnB1c2gocykscih0LmxvYWRpbmcpJiZvKHQubG9hZGluZ0NvbXApKXJldHVybiB0LmxvYWRpbmdDb21wO2lmKHMmJiFvKHQub3duZXJzKSl7Y29uc3Qgcj10Lm93bmVycz1bc107bGV0IGk9ITAsYT1udWxsLGw9bnVsbDtzLiRvbihcImhvb2s6ZGVzdHJveWVkXCIsKCgpPT5fKHIscykpKTtjb25zdCB1PXQ9Pntmb3IobGV0IHQ9MCxlPXIubGVuZ3RoO3Q8ZTt0Kyspclt0XS4kZm9yY2VVcGRhdGUoKTt0JiYoci5sZW5ndGg9MCxudWxsIT09YSYmKGNsZWFyVGltZW91dChhKSxhPW51bGwpLG51bGwhPT1sJiYoY2xlYXJUaW1lb3V0KGwpLGw9bnVsbCkpfSxkPUQoKG49Pnt0LnJlc29sdmVkPWplKG4sZSksaT9yLmxlbmd0aD0wOnUoITApfSkpLHA9RCgoZT0+e28odC5lcnJvckNvbXApJiYodC5lcnJvcj0hMCx1KCEwKSl9KSksaD10KGQscCk7cmV0dXJuIGMoaCkmJihmKGgpP24odC5yZXNvbHZlZCkmJmgudGhlbihkLHApOmYoaC5jb21wb25lbnQpJiYoaC5jb21wb25lbnQudGhlbihkLHApLG8oaC5lcnJvcikmJih0LmVycm9yQ29tcD1qZShoLmVycm9yLGUpKSxvKGgubG9hZGluZykmJih0LmxvYWRpbmdDb21wPWplKGgubG9hZGluZyxlKSwwPT09aC5kZWxheT90LmxvYWRpbmc9ITA6YT1zZXRUaW1lb3V0KCgoKT0+e2E9bnVsbCxuKHQucmVzb2x2ZWQpJiZuKHQuZXJyb3IpJiYodC5sb2FkaW5nPSEwLHUoITEpKX0pLGguZGVsYXl8fDIwMCkpLG8oaC50aW1lb3V0KSYmKGw9c2V0VGltZW91dCgoKCk9PntsPW51bGwsbih0LnJlc29sdmVkKSYmcChudWxsKX0pLGgudGltZW91dCkpKSksaT0hMSx0LmxvYWRpbmc/dC5sb2FkaW5nQ29tcDp0LnJlc29sdmVkfX0ocCxkKSx2b2lkIDA9PT1zKSlyZXR1cm4gZnVuY3Rpb24odCxlLG4sbyxyKXtjb25zdCBzPWN0KCk7cmV0dXJuIHMuYXN5bmNGYWN0b3J5PXQscy5hc3luY01ldGE9e2RhdGE6ZSxjb250ZXh0Om4sY2hpbGRyZW46byx0YWc6cn0sc30ocCxpLGEsbCx1KTtpPWl8fHt9LGFvKHMpLG8oaS5tb2RlbCkmJmZ1bmN0aW9uKHQsbil7Y29uc3Qgcj10Lm1vZGVsJiZ0Lm1vZGVsLnByb3B8fFwidmFsdWVcIixzPXQubW9kZWwmJnQubW9kZWwuZXZlbnR8fFwiaW5wdXRcIjsobi5hdHRyc3x8KG4uYXR0cnM9e30pKVtyXT1uLm1vZGVsLnZhbHVlO2NvbnN0IGk9bi5vbnx8KG4ub249e30pLGM9aVtzXSxhPW4ubW9kZWwuY2FsbGJhY2s7byhjKT8oZShjKT8tMT09PWMuaW5kZXhPZihhKTpjIT09YSkmJihpW3NdPVthXS5jb25jYXQoYykpOmlbc109YX0ocy5vcHRpb25zLGkpO2NvbnN0IGg9ZnVuY3Rpb24odCxlLHIpe2NvbnN0IHM9ZS5vcHRpb25zLnByb3BzO2lmKG4ocykpcmV0dXJuO2NvbnN0IGk9e30se2F0dHJzOmMscHJvcHM6YX09dDtpZihvKGMpfHxvKGEpKWZvcihjb25zdCB0IGluIHMpe2NvbnN0IGU9eCh0KTtYdChpLGEsdCxlLCEwKXx8WHQoaSxjLHQsZSwhMSl9cmV0dXJuIGl9KGkscyk7aWYocihzLm9wdGlvbnMuZnVuY3Rpb25hbCkpcmV0dXJuIGZ1bmN0aW9uKG4scixzLGksYyl7Y29uc3QgYT1uLm9wdGlvbnMsbD17fSx1PWEucHJvcHM7aWYobyh1KSlmb3IoY29uc3QgZSBpbiB1KWxbZV09R24oZSx1LHJ8fHQpO2Vsc2UgbyhzLmF0dHJzKSYmSW4obCxzLmF0dHJzKSxvKHMucHJvcHMpJiZJbihsLHMucHJvcHMpO2NvbnN0IGY9bmV3IEVuKHMsbCxjLGksbiksZD1hLnJlbmRlci5jYWxsKG51bGwsZi5fYyxmKTtpZihkIGluc3RhbmNlb2YgaXQpcmV0dXJuIFBuKGQscyxmLnBhcmVudCxhKTtpZihlKGQpKXtjb25zdCB0PVF0KGQpfHxbXSxlPW5ldyBBcnJheSh0Lmxlbmd0aCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspZVtuXT1Qbih0W25dLHMsZi5wYXJlbnQsYSk7cmV0dXJuIGV9fShzLGgsaSxhLGwpO2NvbnN0IG09aS5vbjtpZihpLm9uPWkubmF0aXZlT24scihzLm9wdGlvbnMuYWJzdHJhY3QpKXtjb25zdCB0PWkuc2xvdDtpPXt9LHQmJihpLnNsb3Q9dCl9IWZ1bmN0aW9uKHQpe2NvbnN0IGU9dC5ob29rfHwodC5ob29rPXt9KTtmb3IobGV0IHQ9MDt0PE1uLmxlbmd0aDt0Kyspe2NvbnN0IG49TW5bdF0sbz1lW25dLHI9Tm5bbl07bz09PXJ8fG8mJm8uX21lcmdlZHx8KGVbbl09bz9MbihyLG8pOnIpfX0oaSk7Y29uc3Qgdj1EbihzLm9wdGlvbnMpfHx1O3JldHVybiBuZXcgaXQoYHZ1ZS1jb21wb25lbnQtJHtzLmNpZH0ke3Y/YC0ke3Z9YDpcIlwifWAsaSx2b2lkIDAsdm9pZCAwLHZvaWQgMCxhLHtDdG9yOnMscHJvcHNEYXRhOmgsbGlzdGVuZXJzOm0sdGFnOnUsY2hpbGRyZW46bH0scCl9ZnVuY3Rpb24gTG4odCxlKXtjb25zdCBuPShuLG8pPT57dChuLG8pLGUobixvKX07cmV0dXJuIG4uX21lcmdlZD0hMCxufWxldCBGbj1BO2NvbnN0IFVuPUwub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO2Z1bmN0aW9uIEJuKHQsZSxuPSEwKXtpZighZSlyZXR1cm4gdDtsZXQgbyxyLHM7Y29uc3QgaT1udD9SZWZsZWN0Lm93bktleXMoZSk6T2JqZWN0LmtleXMoZSk7Zm9yKGxldCBjPTA7YzxpLmxlbmd0aDtjKyspbz1pW2NdLFwiX19vYl9fXCIhPT1vJiYocj10W29dLHM9ZVtvXSxuJiZ5KHQsbyk/ciE9PXMmJmwocikmJmwocykmJkJuKHIscyk6T3QodCxvLHMpKTtyZXR1cm4gdH1mdW5jdGlvbiBWbih0LGUsbil7cmV0dXJuIG4/ZnVuY3Rpb24oKXtjb25zdCBvPWkoZSk/ZS5jYWxsKG4sbik6ZSxyPWkodCk/dC5jYWxsKG4sbik6dDtyZXR1cm4gbz9CbihvLHIpOnJ9OmU/dD9mdW5jdGlvbigpe3JldHVybiBCbihpKGUpP2UuY2FsbCh0aGlzLHRoaXMpOmUsaSh0KT90LmNhbGwodGhpcyx0aGlzKTp0KX06ZTp0fWZ1bmN0aW9uIHpuKHQsbil7Y29uc3Qgbz1uP3Q/dC5jb25jYXQobik6ZShuKT9uOltuXTp0O3JldHVybiBvP2Z1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspLTE9PT1lLmluZGV4T2YodFtuXSkmJmUucHVzaCh0W25dKTtyZXR1cm4gZX0obyk6b31mdW5jdGlvbiBIbih0LGUsbixvKXtjb25zdCByPU9iamVjdC5jcmVhdGUodHx8bnVsbCk7cmV0dXJuIGU/UyhyLGUpOnJ9VW4uZGF0YT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIG4/Vm4odCxlLG4pOmUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGU/dDpWbih0LGUpfSxSLmZvckVhY2goKHQ9PntVblt0XT16bn0pKSxNLmZvckVhY2goKGZ1bmN0aW9uKHQpe1VuW3QrXCJzXCJdPUhufSkpLFVuLndhdGNoPWZ1bmN0aW9uKHQsbixvLHIpe2lmKHQ9PT1KJiYodD12b2lkIDApLG49PT1KJiYobj12b2lkIDApLCFuKXJldHVybiBPYmplY3QuY3JlYXRlKHR8fG51bGwpO2lmKCF0KXJldHVybiBuO2NvbnN0IHM9e307UyhzLHQpO2Zvcihjb25zdCB0IGluIG4pe2xldCBvPXNbdF07Y29uc3Qgcj1uW3RdO28mJiFlKG8pJiYobz1bb10pLHNbdF09bz9vLmNvbmNhdChyKTplKHIpP3I6W3JdfXJldHVybiBzfSxVbi5wcm9wcz1Vbi5tZXRob2RzPVVuLmluamVjdD1Vbi5jb21wdXRlZD1mdW5jdGlvbih0LGUsbixvKXtpZighdClyZXR1cm4gZTtjb25zdCByPU9iamVjdC5jcmVhdGUobnVsbCk7cmV0dXJuIFMocix0KSxlJiZTKHIsZSkscn0sVW4ucHJvdmlkZT1mdW5jdGlvbih0LGUpe3JldHVybiB0P2Z1bmN0aW9uKCl7Y29uc3Qgbj1PYmplY3QuY3JlYXRlKG51bGwpO3JldHVybiBCbihuLGkodCk/dC5jYWxsKHRoaXMpOnQpLGUmJkJuKG4saShlKT9lLmNhbGwodGhpcyk6ZSwhMSksbn06ZX07Y29uc3QgV249ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZT90OmV9O2Z1bmN0aW9uIEtuKHQsbixvKXtpZihpKG4pJiYobj1uLm9wdGlvbnMpLGZ1bmN0aW9uKHQsbil7Y29uc3Qgbz10LnByb3BzO2lmKCFvKXJldHVybjtjb25zdCByPXt9O2xldCBzLGksYztpZihlKG8pKWZvcihzPW8ubGVuZ3RoO3MtLTspaT1vW3NdLFwic3RyaW5nXCI9PXR5cGVvZiBpJiYoYz0kKGkpLHJbY109e3R5cGU6bnVsbH0pO2Vsc2UgaWYobChvKSlmb3IoY29uc3QgdCBpbiBvKWk9b1t0XSxjPSQodCkscltjXT1sKGkpP2k6e3R5cGU6aX07dC5wcm9wcz1yfShuKSxmdW5jdGlvbih0LG4pe2NvbnN0IG89dC5pbmplY3Q7aWYoIW8pcmV0dXJuO2NvbnN0IHI9dC5pbmplY3Q9e307aWYoZShvKSlmb3IobGV0IHQ9MDt0PG8ubGVuZ3RoO3QrKylyW29bdF1dPXtmcm9tOm9bdF19O2Vsc2UgaWYobChvKSlmb3IoY29uc3QgdCBpbiBvKXtjb25zdCBlPW9bdF07clt0XT1sKGUpP1Moe2Zyb206dH0sZSk6e2Zyb206ZX19fShuKSxmdW5jdGlvbih0KXtjb25zdCBlPXQuZGlyZWN0aXZlcztpZihlKWZvcihjb25zdCB0IGluIGUpe2NvbnN0IG49ZVt0XTtpKG4pJiYoZVt0XT17YmluZDpuLHVwZGF0ZTpufSl9fShuKSwhbi5fYmFzZSYmKG4uZXh0ZW5kcyYmKHQ9S24odCxuLmV4dGVuZHMsbykpLG4ubWl4aW5zKSlmb3IobGV0IGU9MCxyPW4ubWl4aW5zLmxlbmd0aDtlPHI7ZSsrKXQ9S24odCxuLm1peGluc1tlXSxvKTtjb25zdCByPXt9O2xldCBzO2ZvcihzIGluIHQpYyhzKTtmb3IocyBpbiBuKXkodCxzKXx8YyhzKTtmdW5jdGlvbiBjKGUpe2NvbnN0IHM9VW5bZV18fFduO3JbZV09cyh0W2VdLG5bZV0sbyxlKX1yZXR1cm4gcn1mdW5jdGlvbiBxbih0LGUsbixvKXtpZihcInN0cmluZ1wiIT10eXBlb2YgbilyZXR1cm47Y29uc3Qgcj10W2VdO2lmKHkocixuKSlyZXR1cm4gcltuXTtjb25zdCBzPSQobik7aWYoeShyLHMpKXJldHVybiByW3NdO2NvbnN0IGk9dyhzKTtpZih5KHIsaSkpcmV0dXJuIHJbaV07cmV0dXJuIHJbbl18fHJbc118fHJbaV19ZnVuY3Rpb24gR24odCxlLG4sbyl7Y29uc3Qgcj1lW3RdLHM9IXkobix0KTtsZXQgYz1uW3RdO2NvbnN0IGE9UW4oQm9vbGVhbixyLnR5cGUpO2lmKGE+LTEpaWYocyYmIXkocixcImRlZmF1bHRcIikpYz0hMTtlbHNlIGlmKFwiXCI9PT1jfHxjPT09eCh0KSl7Y29uc3QgdD1RbihTdHJpbmcsci50eXBlKTsodDwwfHxhPHQpJiYoYz0hMCl9aWYodm9pZCAwPT09Yyl7Yz1mdW5jdGlvbih0LGUsbil7aWYoIXkoZSxcImRlZmF1bHRcIikpcmV0dXJuO2NvbnN0IG89ZS5kZWZhdWx0O2lmKHQmJnQuJG9wdGlvbnMucHJvcHNEYXRhJiZ2b2lkIDA9PT10LiRvcHRpb25zLnByb3BzRGF0YVtuXSYmdm9pZCAwIT09dC5fcHJvcHNbbl0pcmV0dXJuIHQuX3Byb3BzW25dO3JldHVybiBpKG8pJiZcIkZ1bmN0aW9uXCIhPT1KbihlLnR5cGUpP28uY2FsbCh0KTpvfShvLHIsdCk7Y29uc3QgZT1idDskdCghMCkseHQoYyksJHQoZSl9cmV0dXJuIGN9Y29uc3QgWm49L15cXHMqZnVuY3Rpb24gKFxcdyspLztmdW5jdGlvbiBKbih0KXtjb25zdCBlPXQmJnQudG9TdHJpbmcoKS5tYXRjaChabik7cmV0dXJuIGU/ZVsxXTpcIlwifWZ1bmN0aW9uIFhuKHQsZSl7cmV0dXJuIEpuKHQpPT09Sm4oZSl9ZnVuY3Rpb24gUW4odCxuKXtpZighZShuKSlyZXR1cm4gWG4obix0KT8wOi0xO2ZvcihsZXQgZT0wLG89bi5sZW5ndGg7ZTxvO2UrKylpZihYbihuW2VdLHQpKXJldHVybiBlO3JldHVybi0xfWNvbnN0IFluPXtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6QSxzZXQ6QX07ZnVuY3Rpb24gdG8odCxlLG4pe1luLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzW2VdW25dfSxZbi5zZXQ9ZnVuY3Rpb24odCl7dGhpc1tlXVtuXT10fSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLFluKX1mdW5jdGlvbiBlbyh0KXtjb25zdCBuPXQuJG9wdGlvbnM7aWYobi5wcm9wcyYmZnVuY3Rpb24odCxlKXtjb25zdCBuPXQuJG9wdGlvbnMucHJvcHNEYXRhfHx7fSxvPXQuX3Byb3BzPUF0KHt9KSxyPXQuJG9wdGlvbnMuX3Byb3BLZXlzPVtdO3QuJHBhcmVudCYmJHQoITEpO2Zvcihjb25zdCBzIGluIGUpe3IucHVzaChzKTtrdChvLHMsR24ocyxlLG4sdCkpLHMgaW4gdHx8dG8odCxcIl9wcm9wc1wiLHMpfSR0KCEwKX0odCxuLnByb3BzKSxmdW5jdGlvbih0KXtjb25zdCBlPXQuJG9wdGlvbnMsbj1lLnNldHVwO2lmKG4pe2NvbnN0IG89dC5fc2V0dXBDb250ZXh0PXdlKHQpO3N0KHQpLGh0KCk7Y29uc3Qgcj1JZShuLG51bGwsW3QuX3Byb3BzfHxBdCh7fSksb10sdCxcInNldHVwXCIpO2lmKG10KCksc3QoKSxpKHIpKWUucmVuZGVyPXI7ZWxzZSBpZihjKHIpKWlmKHQuX3NldHVwU3RhdGU9cixyLl9fc2ZjKXtjb25zdCBlPXQuX3NldHVwUHJveHk9e307Zm9yKGNvbnN0IHQgaW4gcilcIl9fc2ZjXCIhPT10JiZNdChlLHIsdCl9ZWxzZSBmb3IoY29uc3QgZSBpbiByKUYoZSl8fE10KHQscixlKX19KHQpLG4ubWV0aG9kcyYmZnVuY3Rpb24odCxlKXt0LiRvcHRpb25zLnByb3BzO2Zvcihjb25zdCBuIGluIGUpdFtuXT1cImZ1bmN0aW9uXCIhPXR5cGVvZiBlW25dP0E6ayhlW25dLHQpfSh0LG4ubWV0aG9kcyksbi5kYXRhKSFmdW5jdGlvbih0KXtsZXQgZT10LiRvcHRpb25zLmRhdGE7ZT10Ll9kYXRhPWkoZSk/ZnVuY3Rpb24odCxlKXtodCgpO3RyeXtyZXR1cm4gdC5jYWxsKGUsZSl9Y2F0Y2godCl7cmV0dXJuIFBlKHQsZSxcImRhdGEoKVwiKSx7fX1maW5hbGx5e210KCl9fShlLHQpOmV8fHt9LGwoZSl8fChlPXt9KTtjb25zdCBuPU9iamVjdC5rZXlzKGUpLG89dC4kb3B0aW9ucy5wcm9wczt0LiRvcHRpb25zLm1ldGhvZHM7bGV0IHI9bi5sZW5ndGg7Zm9yKDtyLS07KXtjb25zdCBlPW5bcl07byYmeShvLGUpfHxGKGUpfHx0byh0LFwiX2RhdGFcIixlKX1jb25zdCBzPXh0KGUpO3MmJnMudm1Db3VudCsrfSh0KTtlbHNle2NvbnN0IGU9eHQodC5fZGF0YT17fSk7ZSYmZS52bUNvdW50Kyt9bi5jb21wdXRlZCYmZnVuY3Rpb24odCxlKXtjb25zdCBuPXQuX2NvbXB1dGVkV2F0Y2hlcnM9T2JqZWN0LmNyZWF0ZShudWxsKSxvPVkoKTtmb3IoY29uc3QgciBpbiBlKXtjb25zdCBzPWVbcl0sYz1pKHMpP3M6cy5nZXQ7b3x8KG5bcl09bmV3IGFuKHQsY3x8QSxBLG5vKSksciBpbiB0fHxvbyh0LHIscyl9fSh0LG4uY29tcHV0ZWQpLG4ud2F0Y2gmJm4ud2F0Y2ghPT1KJiZmdW5jdGlvbih0LG4pe2Zvcihjb25zdCBvIGluIG4pe2NvbnN0IHI9bltvXTtpZihlKHIpKWZvcihsZXQgZT0wO2U8ci5sZW5ndGg7ZSsrKWlvKHQsbyxyW2VdKTtlbHNlIGlvKHQsbyxyKX19KHQsbi53YXRjaCl9Y29uc3Qgbm89e2xhenk6ITB9O2Z1bmN0aW9uIG9vKHQsZSxuKXtjb25zdCBvPSFZKCk7aShuKT8oWW4uZ2V0PW8/cm8oZSk6c28obiksWW4uc2V0PUEpOihZbi5nZXQ9bi5nZXQ/byYmITEhPT1uLmNhY2hlP3JvKGUpOnNvKG4uZ2V0KTpBLFluLnNldD1uLnNldHx8QSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSxZbil9ZnVuY3Rpb24gcm8odCl7cmV0dXJuIGZ1bmN0aW9uKCl7Y29uc3QgZT10aGlzLl9jb21wdXRlZFdhdGNoZXJzJiZ0aGlzLl9jb21wdXRlZFdhdGNoZXJzW3RdO2lmKGUpcmV0dXJuIGUuZGlydHkmJmUuZXZhbHVhdGUoKSxkdC50YXJnZXQmJmUuZGVwZW5kKCksZS52YWx1ZX19ZnVuY3Rpb24gc28odCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuY2FsbCh0aGlzLHRoaXMpfX1mdW5jdGlvbiBpbyh0LGUsbixvKXtyZXR1cm4gbChuKSYmKG89bixuPW4uaGFuZGxlciksXCJzdHJpbmdcIj09dHlwZW9mIG4mJihuPXRbbl0pLHQuJHdhdGNoKGUsbixvKX1sZXQgY289MDtmdW5jdGlvbiBhbyh0KXtsZXQgZT10Lm9wdGlvbnM7aWYodC5zdXBlcil7Y29uc3Qgbj1hbyh0LnN1cGVyKTtpZihuIT09dC5zdXBlck9wdGlvbnMpe3Quc3VwZXJPcHRpb25zPW47Y29uc3Qgbz1mdW5jdGlvbih0KXtsZXQgZTtjb25zdCBuPXQub3B0aW9ucyxvPXQuc2VhbGVkT3B0aW9ucztmb3IoY29uc3QgdCBpbiBuKW5bdF0hPT1vW3RdJiYoZXx8KGU9e30pLGVbdF09blt0XSk7cmV0dXJuIGV9KHQpO28mJlModC5leHRlbmRPcHRpb25zLG8pLGU9dC5vcHRpb25zPUtuKG4sdC5leHRlbmRPcHRpb25zKSxlLm5hbWUmJihlLmNvbXBvbmVudHNbZS5uYW1lXT10KX19cmV0dXJuIGV9ZnVuY3Rpb24gbG8odCl7dGhpcy5faW5pdCh0KX1mdW5jdGlvbiB1byh0KXt0LmNpZD0wO2xldCBlPTE7dC5leHRlbmQ9ZnVuY3Rpb24odCl7dD10fHx7fTtjb25zdCBuPXRoaXMsbz1uLmNpZCxyPXQuX0N0b3J8fCh0Ll9DdG9yPXt9KTtpZihyW29dKXJldHVybiByW29dO2NvbnN0IHM9RG4odCl8fERuKG4ub3B0aW9ucyksaT1mdW5jdGlvbih0KXt0aGlzLl9pbml0KHQpfTtyZXR1cm4oaS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShuLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yPWksaS5jaWQ9ZSsrLGkub3B0aW9ucz1LbihuLm9wdGlvbnMsdCksaS5zdXBlcj1uLGkub3B0aW9ucy5wcm9wcyYmZnVuY3Rpb24odCl7Y29uc3QgZT10Lm9wdGlvbnMucHJvcHM7Zm9yKGNvbnN0IG4gaW4gZSl0byh0LnByb3RvdHlwZSxcIl9wcm9wc1wiLG4pfShpKSxpLm9wdGlvbnMuY29tcHV0ZWQmJmZ1bmN0aW9uKHQpe2NvbnN0IGU9dC5vcHRpb25zLmNvbXB1dGVkO2Zvcihjb25zdCBuIGluIGUpb28odC5wcm90b3R5cGUsbixlW25dKX0oaSksaS5leHRlbmQ9bi5leHRlbmQsaS5taXhpbj1uLm1peGluLGkudXNlPW4udXNlLE0uZm9yRWFjaCgoZnVuY3Rpb24odCl7aVt0XT1uW3RdfSkpLHMmJihpLm9wdGlvbnMuY29tcG9uZW50c1tzXT1pKSxpLnN1cGVyT3B0aW9ucz1uLm9wdGlvbnMsaS5leHRlbmRPcHRpb25zPXQsaS5zZWFsZWRPcHRpb25zPVMoe30saS5vcHRpb25zKSxyW29dPWksaX19ZnVuY3Rpb24gZm8odCl7cmV0dXJuIHQmJihEbih0LkN0b3Iub3B0aW9ucyl8fHQudGFnKX1mdW5jdGlvbiBwbyh0LG4pe3JldHVybiBlKHQpP3QuaW5kZXhPZihuKT4tMTpcInN0cmluZ1wiPT10eXBlb2YgdD90LnNwbGl0KFwiLFwiKS5pbmRleE9mKG4pPi0xOihvPXQsXCJbb2JqZWN0IFJlZ0V4cF1cIj09PWEuY2FsbChvKSYmdC50ZXN0KG4pKTt2YXIgb31mdW5jdGlvbiBobyh0LGUpe2NvbnN0e2NhY2hlOm4sa2V5czpvLF92bm9kZTpyfT10O2Zvcihjb25zdCB0IGluIG4pe2NvbnN0IHM9blt0XTtpZihzKXtjb25zdCBpPXMubmFtZTtpJiYhZShpKSYmbW8obix0LG8scil9fX1mdW5jdGlvbiBtbyh0LGUsbixvKXtjb25zdCByPXRbZV07IXJ8fG8mJnIudGFnPT09by50YWd8fHIuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKSx0W2VdPW51bGwsXyhuLGUpfSFmdW5jdGlvbihlKXtlLnByb3RvdHlwZS5faW5pdD1mdW5jdGlvbihlKXtjb25zdCBuPXRoaXM7bi5fdWlkPWNvKyssbi5faXNWdWU9ITAsbi5fX3Zfc2tpcD0hMCxuLl9zY29wZT1uZXcgV3QoITApLG4uX3Njb3BlLl92bT0hMCxlJiZlLl9pc0NvbXBvbmVudD9mdW5jdGlvbih0LGUpe2NvbnN0IG49dC4kb3B0aW9ucz1PYmplY3QuY3JlYXRlKHQuY29uc3RydWN0b3Iub3B0aW9ucyksbz1lLl9wYXJlbnRWbm9kZTtuLnBhcmVudD1lLnBhcmVudCxuLl9wYXJlbnRWbm9kZT1vO2NvbnN0IHI9by5jb21wb25lbnRPcHRpb25zO24ucHJvcHNEYXRhPXIucHJvcHNEYXRhLG4uX3BhcmVudExpc3RlbmVycz1yLmxpc3RlbmVycyxuLl9yZW5kZXJDaGlsZHJlbj1yLmNoaWxkcmVuLG4uX2NvbXBvbmVudFRhZz1yLnRhZyxlLnJlbmRlciYmKG4ucmVuZGVyPWUucmVuZGVyLG4uc3RhdGljUmVuZGVyRm5zPWUuc3RhdGljUmVuZGVyRm5zKX0obixlKTpuLiRvcHRpb25zPUtuKGFvKG4uY29uc3RydWN0b3IpLGV8fHt9LG4pLG4uX3JlbmRlclByb3h5PW4sbi5fc2VsZj1uLGZ1bmN0aW9uKHQpe2NvbnN0IGU9dC4kb3B0aW9ucztsZXQgbj1lLnBhcmVudDtpZihuJiYhZS5hYnN0cmFjdCl7Zm9yKDtuLiRvcHRpb25zLmFic3RyYWN0JiZuLiRwYXJlbnQ7KW49bi4kcGFyZW50O24uJGNoaWxkcmVuLnB1c2godCl9dC4kcGFyZW50PW4sdC4kcm9vdD1uP24uJHJvb3Q6dCx0LiRjaGlsZHJlbj1bXSx0LiRyZWZzPXt9LHQuX3Byb3ZpZGVkPW4/bi5fcHJvdmlkZWQ6T2JqZWN0LmNyZWF0ZShudWxsKSx0Ll93YXRjaGVyPW51bGwsdC5faW5hY3RpdmU9bnVsbCx0Ll9kaXJlY3RJbmFjdGl2ZT0hMSx0Ll9pc01vdW50ZWQ9ITEsdC5faXNEZXN0cm95ZWQ9ITEsdC5faXNCZWluZ0Rlc3Ryb3llZD0hMX0obiksZnVuY3Rpb24odCl7dC5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCksdC5faGFzSG9va0V2ZW50PSExO2NvbnN0IGU9dC4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO2UmJmRuKHQsZSl9KG4pLGZ1bmN0aW9uKGUpe2UuX3Zub2RlPW51bGwsZS5fc3RhdGljVHJlZXM9bnVsbDtjb25zdCBuPWUuJG9wdGlvbnMsbz1lLiR2bm9kZT1uLl9wYXJlbnRWbm9kZSxyPW8mJm8uY29udGV4dDtlLiRzbG90cz1fZShuLl9yZW5kZXJDaGlsZHJlbixyKSxlLiRzY29wZWRTbG90cz1vP2dlKGUuJHBhcmVudCxvLmRhdGEuc2NvcGVkU2xvdHMsZS4kc2xvdHMpOnQsZS5fYz0odCxuLG8scik9PlRlKGUsdCxuLG8sciwhMSksZS4kY3JlYXRlRWxlbWVudD0odCxuLG8scik9PlRlKGUsdCxuLG8sciwhMCk7Y29uc3Qgcz1vJiZvLmRhdGE7a3QoZSxcIiRhdHRyc1wiLHMmJnMuYXR0cnN8fHQsbnVsbCwhMCksa3QoZSxcIiRsaXN0ZW5lcnNcIixuLl9wYXJlbnRMaXN0ZW5lcnN8fHQsbnVsbCwhMCl9KG4pLHluKG4sXCJiZWZvcmVDcmVhdGVcIix2b2lkIDAsITEpLGZ1bmN0aW9uKHQpe2NvbnN0IGU9VG4odC4kb3B0aW9ucy5pbmplY3QsdCk7ZSYmKCR0KCExKSxPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChuPT57a3QodCxuLGVbbl0pfSkpLCR0KCEwKSl9KG4pLGVvKG4pLGZ1bmN0aW9uKHQpe2NvbnN0IGU9dC4kb3B0aW9ucy5wcm92aWRlO2lmKGUpe2NvbnN0IG49aShlKT9lLmNhbGwodCk6ZTtpZighYyhuKSlyZXR1cm47Y29uc3Qgbz1LdCh0KSxyPW50P1JlZmxlY3Qub3duS2V5cyhuKTpPYmplY3Qua2V5cyhuKTtmb3IobGV0IHQ9MDt0PHIubGVuZ3RoO3QrKyl7Y29uc3QgZT1yW3RdO09iamVjdC5kZWZpbmVQcm9wZXJ0eShvLGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLGUpKX19fShuKSx5bihuLFwiY3JlYXRlZFwiKSxuLiRvcHRpb25zLmVsJiZuLiRtb3VudChuLiRvcHRpb25zLmVsKX19KGxvKSxmdW5jdGlvbih0KXtjb25zdCBlPXtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZGF0YX19LG49e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wcm9wc319O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIiRkYXRhXCIsZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiJHByb3BzXCIsbiksdC5wcm90b3R5cGUuJHNldD1PdCx0LnByb3RvdHlwZS4kZGVsZXRlPVN0LHQucHJvdG90eXBlLiR3YXRjaD1mdW5jdGlvbih0LGUsbil7Y29uc3Qgbz10aGlzO2lmKGwoZSkpcmV0dXJuIGlvKG8sdCxlLG4pOyhuPW58fHt9KS51c2VyPSEwO2NvbnN0IHI9bmV3IGFuKG8sdCxlLG4pO2lmKG4uaW1tZWRpYXRlKXtjb25zdCB0PWBjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXCIke3IuZXhwcmVzc2lvbn1cImA7aHQoKSxJZShlLG8sW3IudmFsdWVdLG8sdCksbXQoKX1yZXR1cm4gZnVuY3Rpb24oKXtyLnRlYXJkb3duKCl9fX0obG8pLGZ1bmN0aW9uKHQpe2NvbnN0IG49L15ob29rOi87dC5wcm90b3R5cGUuJG9uPWZ1bmN0aW9uKHQsbyl7Y29uc3Qgcj10aGlzO2lmKGUodCkpZm9yKGxldCBlPTAsbj10Lmxlbmd0aDtlPG47ZSsrKXIuJG9uKHRbZV0sbyk7ZWxzZShyLl9ldmVudHNbdF18fChyLl9ldmVudHNbdF09W10pKS5wdXNoKG8pLG4udGVzdCh0KSYmKHIuX2hhc0hvb2tFdmVudD0hMCk7cmV0dXJuIHJ9LHQucHJvdG90eXBlLiRvbmNlPWZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj10aGlzO2Z1bmN0aW9uIG8oKXtuLiRvZmYodCxvKSxlLmFwcGx5KG4sYXJndW1lbnRzKX1yZXR1cm4gby5mbj1lLG4uJG9uKHQsbyksbn0sdC5wcm90b3R5cGUuJG9mZj1mdW5jdGlvbih0LG4pe2NvbnN0IG89dGhpcztpZighYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gby5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCksbztpZihlKHQpKXtmb3IobGV0IGU9MCxyPXQubGVuZ3RoO2U8cjtlKyspby4kb2ZmKHRbZV0sbik7cmV0dXJuIG99Y29uc3Qgcj1vLl9ldmVudHNbdF07aWYoIXIpcmV0dXJuIG87aWYoIW4pcmV0dXJuIG8uX2V2ZW50c1t0XT1udWxsLG87bGV0IHMsaT1yLmxlbmd0aDtmb3IoO2ktLTspaWYocz1yW2ldLHM9PT1ufHxzLmZuPT09bil7ci5zcGxpY2UoaSwxKTticmVha31yZXR1cm4gb30sdC5wcm90b3R5cGUuJGVtaXQ9ZnVuY3Rpb24odCl7Y29uc3QgZT10aGlzO2xldCBuPWUuX2V2ZW50c1t0XTtpZihuKXtuPW4ubGVuZ3RoPjE/TyhuKTpuO2NvbnN0IG89Tyhhcmd1bWVudHMsMSkscj1gZXZlbnQgaGFuZGxlciBmb3IgXCIke3R9XCJgO2ZvcihsZXQgdD0wLHM9bi5sZW5ndGg7dDxzO3QrKylJZShuW3RdLGUsbyxlLHIpfXJldHVybiBlfX0obG8pLGZ1bmN0aW9uKHQpe3QucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24odCxlKXtjb25zdCBuPXRoaXMsbz1uLiRlbCxyPW4uX3Zub2RlLHM9aG4obik7bi5fdm5vZGU9dCxuLiRlbD1yP24uX19wYXRjaF9fKHIsdCk6bi5fX3BhdGNoX18obi4kZWwsdCxlLCExKSxzKCksbyYmKG8uX192dWVfXz1udWxsKSxuLiRlbCYmKG4uJGVsLl9fdnVlX189bik7bGV0IGk9bjtmb3IoO2kmJmkuJHZub2RlJiZpLiRwYXJlbnQmJmkuJHZub2RlPT09aS4kcGFyZW50Ll92bm9kZTspaS4kcGFyZW50LiRlbD1pLiRlbCxpPWkuJHBhcmVudH0sdC5wcm90b3R5cGUuJGZvcmNlVXBkYXRlPWZ1bmN0aW9uKCl7Y29uc3QgdD10aGlzO3QuX3dhdGNoZXImJnQuX3dhdGNoZXIudXBkYXRlKCl9LHQucHJvdG90eXBlLiRkZXN0cm95PWZ1bmN0aW9uKCl7Y29uc3QgdD10aGlzO2lmKHQuX2lzQmVpbmdEZXN0cm95ZWQpcmV0dXJuO3luKHQsXCJiZWZvcmVEZXN0cm95XCIpLHQuX2lzQmVpbmdEZXN0cm95ZWQ9ITA7Y29uc3QgZT10LiRwYXJlbnQ7IWV8fGUuX2lzQmVpbmdEZXN0cm95ZWR8fHQuJG9wdGlvbnMuYWJzdHJhY3R8fF8oZS4kY2hpbGRyZW4sdCksdC5fc2NvcGUuc3RvcCgpLHQuX2RhdGEuX19vYl9fJiZ0Ll9kYXRhLl9fb2JfXy52bUNvdW50LS0sdC5faXNEZXN0cm95ZWQ9ITAsdC5fX3BhdGNoX18odC5fdm5vZGUsbnVsbCkseW4odCxcImRlc3Ryb3llZFwiKSx0LiRvZmYoKSx0LiRlbCYmKHQuJGVsLl9fdnVlX189bnVsbCksdC4kdm5vZGUmJih0LiR2bm9kZS5wYXJlbnQ9bnVsbCl9fShsbyksZnVuY3Rpb24odCl7bWUodC5wcm90b3R5cGUpLHQucHJvdG90eXBlLiRuZXh0VGljaz1mdW5jdGlvbih0KXtyZXR1cm4gQmUodCx0aGlzKX0sdC5wcm90b3R5cGUuX3JlbmRlcj1mdW5jdGlvbigpe2NvbnN0IHQ9dGhpcyx7cmVuZGVyOm4sX3BhcmVudFZub2RlOm99PXQuJG9wdGlvbnM7bGV0IHI7byYmdC5faXNNb3VudGVkJiYodC4kc2NvcGVkU2xvdHM9Z2UodC4kcGFyZW50LG8uZGF0YS5zY29wZWRTbG90cyx0LiRzbG90cyx0LiRzY29wZWRTbG90cyksdC5fc2xvdHNQcm94eSYma2UodC5fc2xvdHNQcm94eSx0LiRzY29wZWRTbG90cykpLHQuJHZub2RlPW87dHJ5e3N0KHQpLFNlPXQscj1uLmNhbGwodC5fcmVuZGVyUHJveHksdC4kY3JlYXRlRWxlbWVudCl9Y2F0Y2goZSl7UGUoZSx0LFwicmVuZGVyXCIpLHI9dC5fdm5vZGV9ZmluYWxseXtTZT1udWxsLHN0KCl9cmV0dXJuIGUocikmJjE9PT1yLmxlbmd0aCYmKHI9clswXSksciBpbnN0YW5jZW9mIGl0fHwocj1jdCgpKSxyLnBhcmVudD1vLHJ9fShsbyk7Y29uc3QgX289W1N0cmluZyxSZWdFeHAsQXJyYXldO3ZhciB2bz17S2VlcEFsaXZlOntuYW1lOlwia2VlcC1hbGl2ZVwiLGFic3RyYWN0OiEwLHByb3BzOntpbmNsdWRlOl9vLGV4Y2x1ZGU6X28sbWF4OltTdHJpbmcsTnVtYmVyXX0sbWV0aG9kczp7Y2FjaGVWTm9kZSgpe2NvbnN0e2NhY2hlOnQsa2V5czplLHZub2RlVG9DYWNoZTpuLGtleVRvQ2FjaGU6b309dGhpcztpZihuKXtjb25zdHt0YWc6cixjb21wb25lbnRJbnN0YW5jZTpzLGNvbXBvbmVudE9wdGlvbnM6aX09bjt0W29dPXtuYW1lOmZvKGkpLHRhZzpyLGNvbXBvbmVudEluc3RhbmNlOnN9LGUucHVzaChvKSx0aGlzLm1heCYmZS5sZW5ndGg+cGFyc2VJbnQodGhpcy5tYXgpJiZtbyh0LGVbMF0sZSx0aGlzLl92bm9kZSksdGhpcy52bm9kZVRvQ2FjaGU9bnVsbH19fSxjcmVhdGVkKCl7dGhpcy5jYWNoZT1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMua2V5cz1bXX0sZGVzdHJveWVkKCl7Zm9yKGNvbnN0IHQgaW4gdGhpcy5jYWNoZSltbyh0aGlzLmNhY2hlLHQsdGhpcy5rZXlzKX0sbW91bnRlZCgpe3RoaXMuY2FjaGVWTm9kZSgpLHRoaXMuJHdhdGNoKFwiaW5jbHVkZVwiLCh0PT57aG8odGhpcywoZT0+cG8odCxlKSkpfSkpLHRoaXMuJHdhdGNoKFwiZXhjbHVkZVwiLCh0PT57aG8odGhpcywoZT0+IXBvKHQsZSkpKX0pKX0sdXBkYXRlZCgpe3RoaXMuY2FjaGVWTm9kZSgpfSxyZW5kZXIoKXtjb25zdCB0PXRoaXMuJHNsb3RzLmRlZmF1bHQsZT1BZSh0KSxuPWUmJmUuY29tcG9uZW50T3B0aW9ucztpZihuKXtjb25zdCB0PWZvKG4pLHtpbmNsdWRlOm8sZXhjbHVkZTpyfT10aGlzO2lmKG8mJighdHx8IXBvKG8sdCkpfHxyJiZ0JiZwbyhyLHQpKXJldHVybiBlO2NvbnN0e2NhY2hlOnMsa2V5czppfT10aGlzLGM9bnVsbD09ZS5rZXk/bi5DdG9yLmNpZCsobi50YWc/YDo6JHtuLnRhZ31gOlwiXCIpOmUua2V5O3NbY10/KGUuY29tcG9uZW50SW5zdGFuY2U9c1tjXS5jb21wb25lbnRJbnN0YW5jZSxfKGksYyksaS5wdXNoKGMpKToodGhpcy52bm9kZVRvQ2FjaGU9ZSx0aGlzLmtleVRvQ2FjaGU9YyksZS5kYXRhLmtlZXBBbGl2ZT0hMH1yZXR1cm4gZXx8dCYmdFswXX19fTshZnVuY3Rpb24odCl7Y29uc3QgZT17Z2V0OigpPT5MfTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImNvbmZpZ1wiLGUpLHQudXRpbD17d2FybjpGbixleHRlbmQ6UyxtZXJnZU9wdGlvbnM6S24sZGVmaW5lUmVhY3RpdmU6a3R9LHQuc2V0PU90LHQuZGVsZXRlPVN0LHQubmV4dFRpY2s9QmUsdC5vYnNlcnZhYmxlPXQ9Pih4dCh0KSx0KSx0Lm9wdGlvbnM9T2JqZWN0LmNyZWF0ZShudWxsKSxNLmZvckVhY2goKGU9Pnt0Lm9wdGlvbnNbZStcInNcIl09T2JqZWN0LmNyZWF0ZShudWxsKX0pKSx0Lm9wdGlvbnMuX2Jhc2U9dCxTKHQub3B0aW9ucy5jb21wb25lbnRzLHZvKSxmdW5jdGlvbih0KXt0LnVzZT1mdW5jdGlvbih0KXtjb25zdCBlPXRoaXMuX2luc3RhbGxlZFBsdWdpbnN8fCh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zPVtdKTtpZihlLmluZGV4T2YodCk+LTEpcmV0dXJuIHRoaXM7Y29uc3Qgbj1PKGFyZ3VtZW50cywxKTtyZXR1cm4gbi51bnNoaWZ0KHRoaXMpLGkodC5pbnN0YWxsKT90Lmluc3RhbGwuYXBwbHkodCxuKTppKHQpJiZ0LmFwcGx5KG51bGwsbiksZS5wdXNoKHQpLHRoaXN9fSh0KSxmdW5jdGlvbih0KXt0Lm1peGluPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbnM9S24odGhpcy5vcHRpb25zLHQpLHRoaXN9fSh0KSx1byh0KSxmdW5jdGlvbih0KXtNLmZvckVhY2goKGU9Pnt0W2VdPWZ1bmN0aW9uKHQsbil7cmV0dXJuIG4/KFwiY29tcG9uZW50XCI9PT1lJiZsKG4pJiYobi5uYW1lPW4ubmFtZXx8dCxuPXRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQobikpLFwiZGlyZWN0aXZlXCI9PT1lJiZpKG4pJiYobj17YmluZDpuLHVwZGF0ZTpufSksdGhpcy5vcHRpb25zW2UrXCJzXCJdW3RdPW4sbik6dGhpcy5vcHRpb25zW2UrXCJzXCJdW3RdfX0pKX0odCl9KGxvKSxPYmplY3QuZGVmaW5lUHJvcGVydHkobG8ucHJvdG90eXBlLFwiJGlzU2VydmVyXCIse2dldDpZfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGxvLnByb3RvdHlwZSxcIiRzc3JDb250ZXh0XCIse2dldCgpe3JldHVybiB0aGlzLiR2bm9kZSYmdGhpcy4kdm5vZGUuc3NyQ29udGV4dH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkobG8sXCJGdW5jdGlvbmFsUmVuZGVyQ29udGV4dFwiLHt2YWx1ZTpFbn0pLGxvLnZlcnNpb249XCIyLjcuMTRcIjtjb25zdCB5bz1oKFwic3R5bGUsY2xhc3NcIiksZ289aChcImlucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3NcIiksYm89aChcImNvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVja1wiKSwkbz1oKFwiZXZlbnRzLGNhcmV0LHR5cGluZyxwbGFpbnRleHQtb25seVwiKSx3bz1oKFwiYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSxkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSxtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LHJlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlXCIpLENvPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLHhvPXQ9PlwiOlwiPT09dC5jaGFyQXQoNSkmJlwieGxpbmtcIj09PXQuc2xpY2UoMCw1KSxrbz10PT54byh0KT90LnNsaWNlKDYsdC5sZW5ndGgpOlwiXCIsT289dD0+bnVsbD09dHx8ITE9PT10O2Z1bmN0aW9uIFNvKHQpe2xldCBlPXQuZGF0YSxuPXQscj10O2Zvcig7byhyLmNvbXBvbmVudEluc3RhbmNlKTspcj1yLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSxyJiZyLmRhdGEmJihlPWpvKHIuZGF0YSxlKSk7Zm9yKDtvKG49bi5wYXJlbnQpOyluJiZuLmRhdGEmJihlPWpvKGUsbi5kYXRhKSk7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7aWYobyh0KXx8byhlKSlyZXR1cm4gQW8odCxUbyhlKSk7cmV0dXJuXCJcIn0oZS5zdGF0aWNDbGFzcyxlLmNsYXNzKX1mdW5jdGlvbiBqbyh0LGUpe3JldHVybntzdGF0aWNDbGFzczpBbyh0LnN0YXRpY0NsYXNzLGUuc3RhdGljQ2xhc3MpLGNsYXNzOm8odC5jbGFzcyk/W3QuY2xhc3MsZS5jbGFzc106ZS5jbGFzc319ZnVuY3Rpb24gQW8odCxlKXtyZXR1cm4gdD9lP3QrXCIgXCIrZTp0OmV8fFwiXCJ9ZnVuY3Rpb24gVG8odCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodCk/ZnVuY3Rpb24odCl7bGV0IGUsbj1cIlwiO2ZvcihsZXQgcj0wLHM9dC5sZW5ndGg7cjxzO3IrKylvKGU9VG8odFtyXSkpJiZcIlwiIT09ZSYmKG4mJihuKz1cIiBcIiksbis9ZSk7cmV0dXJuIG59KHQpOmModCk/ZnVuY3Rpb24odCl7bGV0IGU9XCJcIjtmb3IoY29uc3QgbiBpbiB0KXRbbl0mJihlJiYoZSs9XCIgXCIpLGUrPW4pO3JldHVybiBlfSh0KTpcInN0cmluZ1wiPT10eXBlb2YgdD90OlwiXCJ9Y29uc3QgRW89e3N2ZzpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsbWF0aDpcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIn0sUG89aChcImh0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbixkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSxjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290XCIpLElvPWgoXCJzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsZm9yZWlnbm9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4scG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2Usdmlld1wiLCEwKSxEbz10PT5Qbyh0KXx8SW8odCk7Y29uc3QgTm89T2JqZWN0LmNyZWF0ZShudWxsKTtjb25zdCBNbz1oKFwidGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmxcIik7dmFyIFJvPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGNyZWF0ZUVsZW1lbnQ6ZnVuY3Rpb24odCxlKXtjb25zdCBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodCk7cmV0dXJuXCJzZWxlY3RcIiE9PXR8fGUuZGF0YSYmZS5kYXRhLmF0dHJzJiZ2b2lkIDAhPT1lLmRhdGEuYXR0cnMubXVsdGlwbGUmJm4uc2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIixcIm11bHRpcGxlXCIpLG59LGNyZWF0ZUVsZW1lbnROUzpmdW5jdGlvbih0LGUpe3JldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoRW9bdF0sZSl9LGNyZWF0ZVRleHROb2RlOmZ1bmN0aW9uKHQpe3JldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0KX0sY3JlYXRlQ29tbWVudDpmdW5jdGlvbih0KXtyZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0KX0saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKHQsZSxuKXt0Lmluc2VydEJlZm9yZShlLG4pfSxyZW1vdmVDaGlsZDpmdW5jdGlvbih0LGUpe3QucmVtb3ZlQ2hpbGQoZSl9LGFwcGVuZENoaWxkOmZ1bmN0aW9uKHQsZSl7dC5hcHBlbmRDaGlsZChlKX0scGFyZW50Tm9kZTpmdW5jdGlvbih0KXtyZXR1cm4gdC5wYXJlbnROb2RlfSxuZXh0U2libGluZzpmdW5jdGlvbih0KXtyZXR1cm4gdC5uZXh0U2libGluZ30sdGFnTmFtZTpmdW5jdGlvbih0KXtyZXR1cm4gdC50YWdOYW1lfSxzZXRUZXh0Q29udGVudDpmdW5jdGlvbih0LGUpe3QudGV4dENvbnRlbnQ9ZX0sc2V0U3R5bGVTY29wZTpmdW5jdGlvbih0LGUpe3Quc2V0QXR0cmlidXRlKGUsXCJcIil9fSksTG89e2NyZWF0ZSh0LGUpe0ZvKGUpfSx1cGRhdGUodCxlKXt0LmRhdGEucmVmIT09ZS5kYXRhLnJlZiYmKEZvKHQsITApLEZvKGUpKX0sZGVzdHJveSh0KXtGbyh0LCEwKX19O2Z1bmN0aW9uIEZvKHQsbil7Y29uc3Qgcj10LmRhdGEucmVmO2lmKCFvKHIpKXJldHVybjtjb25zdCBzPXQuY29udGV4dCxjPXQuY29tcG9uZW50SW5zdGFuY2V8fHQuZWxtLGE9bj9udWxsOmMsbD1uP3ZvaWQgMDpjO2lmKGkocikpcmV0dXJuIHZvaWQgSWUocixzLFthXSxzLFwidGVtcGxhdGUgcmVmIGZ1bmN0aW9uXCIpO2NvbnN0IHU9dC5kYXRhLnJlZkluRm9yLGY9XCJzdHJpbmdcIj09dHlwZW9mIHJ8fFwibnVtYmVyXCI9PXR5cGVvZiByLGQ9RHQocikscD1zLiRyZWZzO2lmKGZ8fGQpaWYodSl7Y29uc3QgdD1mP3Bbcl06ci52YWx1ZTtuP2UodCkmJl8odCxjKTplKHQpP3QuaW5jbHVkZXMoYyl8fHQucHVzaChjKTpmPyhwW3JdPVtjXSxVbyhzLHIscFtyXSkpOnIudmFsdWU9W2NdfWVsc2UgaWYoZil7aWYobiYmcFtyXSE9PWMpcmV0dXJuO3Bbcl09bCxVbyhzLHIsYSl9ZWxzZSBpZihkKXtpZihuJiZyLnZhbHVlIT09YylyZXR1cm47ci52YWx1ZT1hfX1mdW5jdGlvbiBVbyh7X3NldHVwU3RhdGU6dH0sZSxuKXt0JiZ5KHQsZSkmJihEdCh0W2VdKT90W2VdLnZhbHVlPW46dFtlXT1uKX1jb25zdCBCbz1uZXcgaXQoXCJcIix7fSxbXSksVm89W1wiY3JlYXRlXCIsXCJhY3RpdmF0ZVwiLFwidXBkYXRlXCIsXCJyZW1vdmVcIixcImRlc3Ryb3lcIl07ZnVuY3Rpb24gem8odCxlKXtyZXR1cm4gdC5rZXk9PT1lLmtleSYmdC5hc3luY0ZhY3Rvcnk9PT1lLmFzeW5jRmFjdG9yeSYmKHQudGFnPT09ZS50YWcmJnQuaXNDb21tZW50PT09ZS5pc0NvbW1lbnQmJm8odC5kYXRhKT09PW8oZS5kYXRhKSYmZnVuY3Rpb24odCxlKXtpZihcImlucHV0XCIhPT10LnRhZylyZXR1cm4hMDtsZXQgbjtjb25zdCByPW8obj10LmRhdGEpJiZvKG49bi5hdHRycykmJm4udHlwZSxzPW8obj1lLmRhdGEpJiZvKG49bi5hdHRycykmJm4udHlwZTtyZXR1cm4gcj09PXN8fE1vKHIpJiZNbyhzKX0odCxlKXx8cih0LmlzQXN5bmNQbGFjZWhvbGRlcikmJm4oZS5hc3luY0ZhY3RvcnkuZXJyb3IpKX1mdW5jdGlvbiBIbyh0LGUsbil7bGV0IHIscztjb25zdCBpPXt9O2ZvcihyPWU7cjw9bjsrK3Ipcz10W3JdLmtleSxvKHMpJiYoaVtzXT1yKTtyZXR1cm4gaX12YXIgV289e2NyZWF0ZTpLbyx1cGRhdGU6S28sZGVzdHJveTpmdW5jdGlvbih0KXtLbyh0LEJvKX19O2Z1bmN0aW9uIEtvKHQsZSl7KHQuZGF0YS5kaXJlY3RpdmVzfHxlLmRhdGEuZGlyZWN0aXZlcykmJmZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj10PT09Qm8sbz1lPT09Qm8scj1Hbyh0LmRhdGEuZGlyZWN0aXZlcyx0LmNvbnRleHQpLHM9R28oZS5kYXRhLmRpcmVjdGl2ZXMsZS5jb250ZXh0KSxpPVtdLGM9W107bGV0IGEsbCx1O2ZvcihhIGluIHMpbD1yW2FdLHU9c1thXSxsPyh1Lm9sZFZhbHVlPWwudmFsdWUsdS5vbGRBcmc9bC5hcmcsSm8odSxcInVwZGF0ZVwiLGUsdCksdS5kZWYmJnUuZGVmLmNvbXBvbmVudFVwZGF0ZWQmJmMucHVzaCh1KSk6KEpvKHUsXCJiaW5kXCIsZSx0KSx1LmRlZiYmdS5kZWYuaW5zZXJ0ZWQmJmkucHVzaCh1KSk7aWYoaS5sZW5ndGgpe2NvbnN0IG89KCk9Pntmb3IobGV0IG49MDtuPGkubGVuZ3RoO24rKylKbyhpW25dLFwiaW5zZXJ0ZWRcIixlLHQpfTtuP0p0KGUsXCJpbnNlcnRcIixvKTpvKCl9Yy5sZW5ndGgmJkp0KGUsXCJwb3N0cGF0Y2hcIiwoKCk9Pntmb3IobGV0IG49MDtuPGMubGVuZ3RoO24rKylKbyhjW25dLFwiY29tcG9uZW50VXBkYXRlZFwiLGUsdCl9KSk7aWYoIW4pZm9yKGEgaW4gcilzW2FdfHxKbyhyW2FdLFwidW5iaW5kXCIsdCx0LG8pfSh0LGUpfWNvbnN0IHFvPU9iamVjdC5jcmVhdGUobnVsbCk7ZnVuY3Rpb24gR28odCxlKXtjb25zdCBuPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoIXQpcmV0dXJuIG47bGV0IG8scjtmb3Iobz0wO288dC5sZW5ndGg7bysrKXtpZihyPXRbb10sci5tb2RpZmllcnN8fChyLm1vZGlmaWVycz1xbyksbltabyhyKV09cixlLl9zZXR1cFN0YXRlJiZlLl9zZXR1cFN0YXRlLl9fc2ZjKXtjb25zdCB0PXIuZGVmfHxxbihlLFwiX3NldHVwU3RhdGVcIixcInYtXCIrci5uYW1lKTtyLmRlZj1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3tiaW5kOnQsdXBkYXRlOnR9OnR9ci5kZWY9ci5kZWZ8fHFuKGUuJG9wdGlvbnMsXCJkaXJlY3RpdmVzXCIsci5uYW1lKX1yZXR1cm4gbn1mdW5jdGlvbiBabyh0KXtyZXR1cm4gdC5yYXdOYW1lfHxgJHt0Lm5hbWV9LiR7T2JqZWN0LmtleXModC5tb2RpZmllcnN8fHt9KS5qb2luKFwiLlwiKX1gfWZ1bmN0aW9uIEpvKHQsZSxuLG8scil7Y29uc3Qgcz10LmRlZiYmdC5kZWZbZV07aWYocyl0cnl7cyhuLmVsbSx0LG4sbyxyKX1jYXRjaChvKXtQZShvLG4uY29udGV4dCxgZGlyZWN0aXZlICR7dC5uYW1lfSAke2V9IGhvb2tgKX19dmFyIFhvPVtMbyxXb107ZnVuY3Rpb24gUW8odCxlKXtjb25zdCBzPWUuY29tcG9uZW50T3B0aW9ucztpZihvKHMpJiYhMT09PXMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycylyZXR1cm47aWYobih0LmRhdGEuYXR0cnMpJiZuKGUuZGF0YS5hdHRycykpcmV0dXJuO2xldCBpLGMsYTtjb25zdCBsPWUuZWxtLHU9dC5kYXRhLmF0dHJzfHx7fTtsZXQgZj1lLmRhdGEuYXR0cnN8fHt9O2ZvcihpIGluKG8oZi5fX29iX18pfHxyKGYuX3ZfYXR0cl9wcm94eSkpJiYoZj1lLmRhdGEuYXR0cnM9Uyh7fSxmKSksZiljPWZbaV0sYT11W2ldLGEhPT1jJiZZbyhsLGksYyxlLmRhdGEucHJlKTtmb3IoaSBpbihXfHxxKSYmZi52YWx1ZSE9PXUudmFsdWUmJllvKGwsXCJ2YWx1ZVwiLGYudmFsdWUpLHUpbihmW2ldKSYmKHhvKGkpP2wucmVtb3ZlQXR0cmlidXRlTlMoQ28sa28oaSkpOmJvKGkpfHxsLnJlbW92ZUF0dHJpYnV0ZShpKSl9ZnVuY3Rpb24gWW8odCxlLG4sbyl7b3x8dC50YWdOYW1lLmluZGV4T2YoXCItXCIpPi0xP3RyKHQsZSxuKTp3byhlKT9PbyhuKT90LnJlbW92ZUF0dHJpYnV0ZShlKToobj1cImFsbG93ZnVsbHNjcmVlblwiPT09ZSYmXCJFTUJFRFwiPT09dC50YWdOYW1lP1widHJ1ZVwiOmUsdC5zZXRBdHRyaWJ1dGUoZSxuKSk6Ym8oZSk/dC5zZXRBdHRyaWJ1dGUoZSwoKHQsZSk9Pk9vKGUpfHxcImZhbHNlXCI9PT1lP1wiZmFsc2VcIjpcImNvbnRlbnRlZGl0YWJsZVwiPT09dCYmJG8oZSk/ZTpcInRydWVcIikoZSxuKSk6eG8oZSk/T28obik/dC5yZW1vdmVBdHRyaWJ1dGVOUyhDbyxrbyhlKSk6dC5zZXRBdHRyaWJ1dGVOUyhDbyxlLG4pOnRyKHQsZSxuKX1mdW5jdGlvbiB0cih0LGUsbil7aWYoT28obikpdC5yZW1vdmVBdHRyaWJ1dGUoZSk7ZWxzZXtpZihXJiYhSyYmXCJURVhUQVJFQVwiPT09dC50YWdOYW1lJiZcInBsYWNlaG9sZGVyXCI9PT1lJiZcIlwiIT09biYmIXQuX19pZXBoKXtjb25zdCBlPW49PntuLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsZSl9O3QuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsZSksdC5fX2llcGg9ITB9dC5zZXRBdHRyaWJ1dGUoZSxuKX19dmFyIGVyPXtjcmVhdGU6UW8sdXBkYXRlOlFvfTtmdW5jdGlvbiBucih0LGUpe2NvbnN0IHI9ZS5lbG0scz1lLmRhdGEsaT10LmRhdGE7aWYobihzLnN0YXRpY0NsYXNzKSYmbihzLmNsYXNzKSYmKG4oaSl8fG4oaS5zdGF0aWNDbGFzcykmJm4oaS5jbGFzcykpKXJldHVybjtsZXQgYz1TbyhlKTtjb25zdCBhPXIuX3RyYW5zaXRpb25DbGFzc2VzO28oYSkmJihjPUFvKGMsVG8oYSkpKSxjIT09ci5fcHJldkNsYXNzJiYoci5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLGMpLHIuX3ByZXZDbGFzcz1jKX12YXIgb3I9e2NyZWF0ZTpucix1cGRhdGU6bnJ9O2xldCBycjtmdW5jdGlvbiBzcih0LGUsbil7Y29uc3Qgbz1ycjtyZXR1cm4gZnVuY3Rpb24gcigpe2NvbnN0IHM9ZS5hcHBseShudWxsLGFyZ3VtZW50cyk7bnVsbCE9PXMmJmFyKHQscixuLG8pfX1jb25zdCBpcj1NZSYmIShaJiZOdW1iZXIoWlsxXSk8PTUzKTtmdW5jdGlvbiBjcih0LGUsbixvKXtpZihpcil7Y29uc3QgdD1rbixuPWU7ZT1uLl93cmFwcGVyPWZ1bmN0aW9uKGUpe2lmKGUudGFyZ2V0PT09ZS5jdXJyZW50VGFyZ2V0fHxlLnRpbWVTdGFtcD49dHx8ZS50aW1lU3RhbXA8PTB8fGUudGFyZ2V0Lm93bmVyRG9jdW1lbnQhPT1kb2N1bWVudClyZXR1cm4gbi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fXJyLmFkZEV2ZW50TGlzdGVuZXIodCxlLFE/e2NhcHR1cmU6bixwYXNzaXZlOm99Om4pfWZ1bmN0aW9uIGFyKHQsZSxuLG8peyhvfHxycikucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LGUuX3dyYXBwZXJ8fGUsbil9ZnVuY3Rpb24gbHIodCxlKXtpZihuKHQuZGF0YS5vbikmJm4oZS5kYXRhLm9uKSlyZXR1cm47Y29uc3Qgcj1lLmRhdGEub258fHt9LHM9dC5kYXRhLm9ufHx7fTtycj1lLmVsbXx8dC5lbG0sZnVuY3Rpb24odCl7aWYobyh0Ll9fcikpe2NvbnN0IGU9Vz9cImNoYW5nZVwiOlwiaW5wdXRcIjt0W2VdPVtdLmNvbmNhdCh0Ll9fcix0W2VdfHxbXSksZGVsZXRlIHQuX19yfW8odC5fX2MpJiYodC5jaGFuZ2U9W10uY29uY2F0KHQuX19jLHQuY2hhbmdlfHxbXSksZGVsZXRlIHQuX19jKX0ociksWnQocixzLGNyLGFyLHNyLGUuY29udGV4dCkscnI9dm9pZCAwfXZhciB1cj17Y3JlYXRlOmxyLHVwZGF0ZTpscixkZXN0cm95OnQ9PmxyKHQsQm8pfTtsZXQgZnI7ZnVuY3Rpb24gZHIodCxlKXtpZihuKHQuZGF0YS5kb21Qcm9wcykmJm4oZS5kYXRhLmRvbVByb3BzKSlyZXR1cm47bGV0IHMsaTtjb25zdCBjPWUuZWxtLGE9dC5kYXRhLmRvbVByb3BzfHx7fTtsZXQgbD1lLmRhdGEuZG9tUHJvcHN8fHt9O2ZvcihzIGluKG8obC5fX29iX18pfHxyKGwuX3ZfYXR0cl9wcm94eSkpJiYobD1lLmRhdGEuZG9tUHJvcHM9Uyh7fSxsKSksYSlzIGluIGx8fChjW3NdPVwiXCIpO2ZvcihzIGluIGwpe2lmKGk9bFtzXSxcInRleHRDb250ZW50XCI9PT1zfHxcImlubmVySFRNTFwiPT09cyl7aWYoZS5jaGlsZHJlbiYmKGUuY2hpbGRyZW4ubGVuZ3RoPTApLGk9PT1hW3NdKWNvbnRpbnVlOzE9PT1jLmNoaWxkTm9kZXMubGVuZ3RoJiZjLnJlbW92ZUNoaWxkKGMuY2hpbGROb2Rlc1swXSl9aWYoXCJ2YWx1ZVwiPT09cyYmXCJQUk9HUkVTU1wiIT09Yy50YWdOYW1lKXtjLl92YWx1ZT1pO2NvbnN0IHQ9bihpKT9cIlwiOlN0cmluZyhpKTtwcihjLHQpJiYoYy52YWx1ZT10KX1lbHNlIGlmKFwiaW5uZXJIVE1MXCI9PT1zJiZJbyhjLnRhZ05hbWUpJiZuKGMuaW5uZXJIVE1MKSl7ZnI9ZnJ8fGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksZnIuaW5uZXJIVE1MPWA8c3ZnPiR7aX08L3N2Zz5gO2NvbnN0IHQ9ZnIuZmlyc3RDaGlsZDtmb3IoO2MuZmlyc3RDaGlsZDspYy5yZW1vdmVDaGlsZChjLmZpcnN0Q2hpbGQpO2Zvcig7dC5maXJzdENoaWxkOyljLmFwcGVuZENoaWxkKHQuZmlyc3RDaGlsZCl9ZWxzZSBpZihpIT09YVtzXSl0cnl7Y1tzXT1pfWNhdGNoKHQpe319fWZ1bmN0aW9uIHByKHQsZSl7cmV0dXJuIXQuY29tcG9zaW5nJiYoXCJPUFRJT05cIj09PXQudGFnTmFtZXx8ZnVuY3Rpb24odCxlKXtsZXQgbj0hMDt0cnl7bj1kb2N1bWVudC5hY3RpdmVFbGVtZW50IT09dH1jYXRjaCh0KXt9cmV0dXJuIG4mJnQudmFsdWUhPT1lfSh0LGUpfHxmdW5jdGlvbih0LGUpe2NvbnN0IG49dC52YWx1ZSxyPXQuX3ZNb2RpZmllcnM7aWYobyhyKSl7aWYoci5udW1iZXIpcmV0dXJuIHAobikhPT1wKGUpO2lmKHIudHJpbSlyZXR1cm4gbi50cmltKCkhPT1lLnRyaW0oKX1yZXR1cm4gbiE9PWV9KHQsZSkpfXZhciBocj17Y3JlYXRlOmRyLHVwZGF0ZTpkcn07Y29uc3QgbXI9ZygoZnVuY3Rpb24odCl7Y29uc3QgZT17fSxuPS86KC4rKS87cmV0dXJuIHQuc3BsaXQoLzsoPyFbXihdKlxcKSkvZykuZm9yRWFjaCgoZnVuY3Rpb24odCl7aWYodCl7Y29uc3Qgbz10LnNwbGl0KG4pO28ubGVuZ3RoPjEmJihlW29bMF0udHJpbSgpXT1vWzFdLnRyaW0oKSl9fSkpLGV9KSk7ZnVuY3Rpb24gX3IodCl7Y29uc3QgZT12cih0LnN0eWxlKTtyZXR1cm4gdC5zdGF0aWNTdHlsZT9TKHQuc3RhdGljU3R5bGUsZSk6ZX1mdW5jdGlvbiB2cih0KXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0KT9qKHQpOlwic3RyaW5nXCI9PXR5cGVvZiB0P21yKHQpOnR9Y29uc3QgeXI9L14tLS8sZ3I9L1xccyohaW1wb3J0YW50JC8sYnI9KHQsZSxuKT0+e2lmKHlyLnRlc3QoZSkpdC5zdHlsZS5zZXRQcm9wZXJ0eShlLG4pO2Vsc2UgaWYoZ3IudGVzdChuKSl0LnN0eWxlLnNldFByb3BlcnR5KHgoZSksbi5yZXBsYWNlKGdyLFwiXCIpLFwiaW1wb3J0YW50XCIpO2Vsc2V7Y29uc3Qgbz1DcihlKTtpZihBcnJheS5pc0FycmF5KG4pKWZvcihsZXQgZT0wLHI9bi5sZW5ndGg7ZTxyO2UrKyl0LnN0eWxlW29dPW5bZV07ZWxzZSB0LnN0eWxlW29dPW59fSwkcj1bXCJXZWJraXRcIixcIk1velwiLFwibXNcIl07bGV0IHdyO2NvbnN0IENyPWcoKGZ1bmN0aW9uKHQpe2lmKHdyPXdyfHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlLFwiZmlsdGVyXCIhPT0odD0kKHQpKSYmdCBpbiB3cilyZXR1cm4gdDtjb25zdCBlPXQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrdC5zbGljZSgxKTtmb3IobGV0IHQ9MDt0PCRyLmxlbmd0aDt0Kyspe2NvbnN0IG49JHJbdF0rZTtpZihuIGluIHdyKXJldHVybiBufX0pKTtmdW5jdGlvbiB4cih0LGUpe2NvbnN0IHI9ZS5kYXRhLHM9dC5kYXRhO2lmKG4oci5zdGF0aWNTdHlsZSkmJm4oci5zdHlsZSkmJm4ocy5zdGF0aWNTdHlsZSkmJm4ocy5zdHlsZSkpcmV0dXJuO2xldCBpLGM7Y29uc3QgYT1lLmVsbSxsPXMuc3RhdGljU3R5bGUsdT1zLm5vcm1hbGl6ZWRTdHlsZXx8cy5zdHlsZXx8e30sZj1sfHx1LGQ9dnIoZS5kYXRhLnN0eWxlKXx8e307ZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZT1vKGQuX19vYl9fKT9TKHt9LGQpOmQ7Y29uc3QgcD1mdW5jdGlvbih0LGUpe2NvbnN0IG49e307bGV0IG87aWYoZSl7bGV0IGU9dDtmb3IoO2UuY29tcG9uZW50SW5zdGFuY2U7KWU9ZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUsZSYmZS5kYXRhJiYobz1fcihlLmRhdGEpKSYmUyhuLG8pfShvPV9yKHQuZGF0YSkpJiZTKG4sbyk7bGV0IHI9dDtmb3IoO3I9ci5wYXJlbnQ7KXIuZGF0YSYmKG89X3Ioci5kYXRhKSkmJlMobixvKTtyZXR1cm4gbn0oZSwhMCk7Zm9yKGMgaW4gZiluKHBbY10pJiZicihhLGMsXCJcIik7Zm9yKGMgaW4gcClpPXBbY10saSE9PWZbY10mJmJyKGEsYyxudWxsPT1pP1wiXCI6aSl9dmFyIGtyPXtjcmVhdGU6eHIsdXBkYXRlOnhyfTtjb25zdCBPcj0vXFxzKy87ZnVuY3Rpb24gU3IodCxlKXtpZihlJiYoZT1lLnRyaW0oKSkpaWYodC5jbGFzc0xpc3QpZS5pbmRleE9mKFwiIFwiKT4tMT9lLnNwbGl0KE9yKS5mb3JFYWNoKChlPT50LmNsYXNzTGlzdC5hZGQoZSkpKTp0LmNsYXNzTGlzdC5hZGQoZSk7ZWxzZXtjb25zdCBuPWAgJHt0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpfHxcIlwifSBgO24uaW5kZXhPZihcIiBcIitlK1wiIFwiKTwwJiZ0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsKG4rZSkudHJpbSgpKX19ZnVuY3Rpb24ganIodCxlKXtpZihlJiYoZT1lLnRyaW0oKSkpaWYodC5jbGFzc0xpc3QpZS5pbmRleE9mKFwiIFwiKT4tMT9lLnNwbGl0KE9yKS5mb3JFYWNoKChlPT50LmNsYXNzTGlzdC5yZW1vdmUoZSkpKTp0LmNsYXNzTGlzdC5yZW1vdmUoZSksdC5jbGFzc0xpc3QubGVuZ3RofHx0LnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpO2Vsc2V7bGV0IG49YCAke3QuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIil8fFwiXCJ9IGA7Y29uc3Qgbz1cIiBcIitlK1wiIFwiO2Zvcig7bi5pbmRleE9mKG8pPj0wOyluPW4ucmVwbGFjZShvLFwiIFwiKTtuPW4udHJpbSgpLG4/dC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLG4pOnQucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIil9fWZ1bmN0aW9uIEFyKHQpe2lmKHQpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiB0KXtjb25zdCBlPXt9O3JldHVybiExIT09dC5jc3MmJlMoZSxUcih0Lm5hbWV8fFwidlwiKSksUyhlLHQpLGV9cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQ/VHIodCk6dm9pZCAwfX1jb25zdCBUcj1nKCh0PT4oe2VudGVyQ2xhc3M6YCR7dH0tZW50ZXJgLGVudGVyVG9DbGFzczpgJHt0fS1lbnRlci10b2AsZW50ZXJBY3RpdmVDbGFzczpgJHt0fS1lbnRlci1hY3RpdmVgLGxlYXZlQ2xhc3M6YCR7dH0tbGVhdmVgLGxlYXZlVG9DbGFzczpgJHt0fS1sZWF2ZS10b2AsbGVhdmVBY3RpdmVDbGFzczpgJHt0fS1sZWF2ZS1hY3RpdmVgfSkpKSxFcj16JiYhSztsZXQgUHI9XCJ0cmFuc2l0aW9uXCIsSXI9XCJ0cmFuc2l0aW9uZW5kXCIsRHI9XCJhbmltYXRpb25cIixOcj1cImFuaW1hdGlvbmVuZFwiO0VyJiYodm9pZCAwPT09d2luZG93Lm9udHJhbnNpdGlvbmVuZCYmdm9pZCAwIT09d2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCYmKFByPVwiV2Via2l0VHJhbnNpdGlvblwiLElyPVwid2Via2l0VHJhbnNpdGlvbkVuZFwiKSx2b2lkIDA9PT13aW5kb3cub25hbmltYXRpb25lbmQmJnZvaWQgMCE9PXdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCYmKERyPVwiV2Via2l0QW5pbWF0aW9uXCIsTnI9XCJ3ZWJraXRBbmltYXRpb25FbmRcIikpO2NvbnN0IE1yPXo/d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZT93aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KTpzZXRUaW1lb3V0OnQ9PnQoKTtmdW5jdGlvbiBScih0KXtNcigoKCk9PntNcih0KX0pKX1mdW5jdGlvbiBMcih0LGUpe2NvbnN0IG49dC5fdHJhbnNpdGlvbkNsYXNzZXN8fCh0Ll90cmFuc2l0aW9uQ2xhc3Nlcz1bXSk7bi5pbmRleE9mKGUpPDAmJihuLnB1c2goZSksU3IodCxlKSl9ZnVuY3Rpb24gRnIodCxlKXt0Ll90cmFuc2l0aW9uQ2xhc3NlcyYmXyh0Ll90cmFuc2l0aW9uQ2xhc3NlcyxlKSxqcih0LGUpfWZ1bmN0aW9uIFVyKHQsZSxuKXtjb25zdHt0eXBlOm8sdGltZW91dDpyLHByb3BDb3VudDpzfT1Wcih0LGUpO2lmKCFvKXJldHVybiBuKCk7Y29uc3QgaT1cInRyYW5zaXRpb25cIj09PW8/SXI6TnI7bGV0IGM9MDtjb25zdCBhPSgpPT57dC5yZW1vdmVFdmVudExpc3RlbmVyKGksbCksbigpfSxsPWU9PntlLnRhcmdldD09PXQmJisrYz49cyYmYSgpfTtzZXRUaW1lb3V0KCgoKT0+e2M8cyYmYSgpfSkscisxKSx0LmFkZEV2ZW50TGlzdGVuZXIoaSxsKX1jb25zdCBCcj0vXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO2Z1bmN0aW9uIFZyKHQsZSl7Y29uc3Qgbj13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0KSxvPShuW1ByK1wiRGVsYXlcIl18fFwiXCIpLnNwbGl0KFwiLCBcIikscj0obltQcitcIkR1cmF0aW9uXCJdfHxcIlwiKS5zcGxpdChcIiwgXCIpLHM9enIobyxyKSxpPShuW0RyK1wiRGVsYXlcIl18fFwiXCIpLnNwbGl0KFwiLCBcIiksYz0obltEcitcIkR1cmF0aW9uXCJdfHxcIlwiKS5zcGxpdChcIiwgXCIpLGE9enIoaSxjKTtsZXQgbCx1PTAsZj0wO1widHJhbnNpdGlvblwiPT09ZT9zPjAmJihsPVwidHJhbnNpdGlvblwiLHU9cyxmPXIubGVuZ3RoKTpcImFuaW1hdGlvblwiPT09ZT9hPjAmJihsPVwiYW5pbWF0aW9uXCIsdT1hLGY9Yy5sZW5ndGgpOih1PU1hdGgubWF4KHMsYSksbD11PjA/cz5hP1widHJhbnNpdGlvblwiOlwiYW5pbWF0aW9uXCI6bnVsbCxmPWw/XCJ0cmFuc2l0aW9uXCI9PT1sP3IubGVuZ3RoOmMubGVuZ3RoOjApO3JldHVybnt0eXBlOmwsdGltZW91dDp1LHByb3BDb3VudDpmLGhhc1RyYW5zZm9ybTpcInRyYW5zaXRpb25cIj09PWwmJkJyLnRlc3QobltQcitcIlByb3BlcnR5XCJdKX19ZnVuY3Rpb24genIodCxlKXtmb3IoO3QubGVuZ3RoPGUubGVuZ3RoOyl0PXQuY29uY2F0KHQpO3JldHVybiBNYXRoLm1heC5hcHBseShudWxsLGUubWFwKCgoZSxuKT0+SHIoZSkrSHIodFtuXSkpKSl9ZnVuY3Rpb24gSHIodCl7cmV0dXJuIDFlMypOdW1iZXIodC5zbGljZSgwLC0xKS5yZXBsYWNlKFwiLFwiLFwiLlwiKSl9ZnVuY3Rpb24gV3IodCxlKXtjb25zdCByPXQuZWxtO28oci5fbGVhdmVDYikmJihyLl9sZWF2ZUNiLmNhbmNlbGxlZD0hMCxyLl9sZWF2ZUNiKCkpO2NvbnN0IHM9QXIodC5kYXRhLnRyYW5zaXRpb24pO2lmKG4ocykpcmV0dXJuO2lmKG8oci5fZW50ZXJDYil8fDEhPT1yLm5vZGVUeXBlKXJldHVybjtjb25zdHtjc3M6YSx0eXBlOmwsZW50ZXJDbGFzczp1LGVudGVyVG9DbGFzczpmLGVudGVyQWN0aXZlQ2xhc3M6ZCxhcHBlYXJDbGFzczpoLGFwcGVhclRvQ2xhc3M6bSxhcHBlYXJBY3RpdmVDbGFzczpfLGJlZm9yZUVudGVyOnYsZW50ZXI6eSxhZnRlckVudGVyOmcsZW50ZXJDYW5jZWxsZWQ6YixiZWZvcmVBcHBlYXI6JCxhcHBlYXI6dyxhZnRlckFwcGVhcjpDLGFwcGVhckNhbmNlbGxlZDp4LGR1cmF0aW9uOmt9PXM7bGV0IE89cG4sUz1wbi4kdm5vZGU7Zm9yKDtTJiZTLnBhcmVudDspTz1TLmNvbnRleHQsUz1TLnBhcmVudDtjb25zdCBqPSFPLl9pc01vdW50ZWR8fCF0LmlzUm9vdEluc2VydDtpZihqJiYhdyYmXCJcIiE9PXcpcmV0dXJuO2NvbnN0IEE9aiYmaD9oOnUsVD1qJiZfP186ZCxFPWomJm0/bTpmLFA9aiYmJHx8dixJPWomJmkodyk/dzp5LE49aiYmQ3x8ZyxNPWomJnh8fGIsUj1wKGMoayk/ay5lbnRlcjprKSxMPSExIT09YSYmIUssRj1HcihJKSxVPXIuX2VudGVyQ2I9RCgoKCk9PntMJiYoRnIocixFKSxGcihyLFQpKSxVLmNhbmNlbGxlZD8oTCYmRnIocixBKSxNJiZNKHIpKTpOJiZOKHIpLHIuX2VudGVyQ2I9bnVsbH0pKTt0LmRhdGEuc2hvd3x8SnQodCxcImluc2VydFwiLCgoKT0+e2NvbnN0IGU9ci5wYXJlbnROb2RlLG49ZSYmZS5fcGVuZGluZyYmZS5fcGVuZGluZ1t0LmtleV07biYmbi50YWc9PT10LnRhZyYmbi5lbG0uX2xlYXZlQ2ImJm4uZWxtLl9sZWF2ZUNiKCksSSYmSShyLFUpfSkpLFAmJlAociksTCYmKExyKHIsQSksTHIocixUKSxScigoKCk9PntGcihyLEEpLFUuY2FuY2VsbGVkfHwoTHIocixFKSxGfHwocXIoUik/c2V0VGltZW91dChVLFIpOlVyKHIsbCxVKSkpfSkpKSx0LmRhdGEuc2hvdyYmKGUmJmUoKSxJJiZJKHIsVSkpLEx8fEZ8fFUoKX1mdW5jdGlvbiBLcih0LGUpe2NvbnN0IHI9dC5lbG07byhyLl9lbnRlckNiKSYmKHIuX2VudGVyQ2IuY2FuY2VsbGVkPSEwLHIuX2VudGVyQ2IoKSk7Y29uc3Qgcz1Bcih0LmRhdGEudHJhbnNpdGlvbik7aWYobihzKXx8MSE9PXIubm9kZVR5cGUpcmV0dXJuIGUoKTtpZihvKHIuX2xlYXZlQ2IpKXJldHVybjtjb25zdHtjc3M6aSx0eXBlOmEsbGVhdmVDbGFzczpsLGxlYXZlVG9DbGFzczp1LGxlYXZlQWN0aXZlQ2xhc3M6ZixiZWZvcmVMZWF2ZTpkLGxlYXZlOmgsYWZ0ZXJMZWF2ZTptLGxlYXZlQ2FuY2VsbGVkOl8sZGVsYXlMZWF2ZTp2LGR1cmF0aW9uOnl9PXMsZz0hMSE9PWkmJiFLLGI9R3IoaCksJD1wKGMoeSk/eS5sZWF2ZTp5KSx3PXIuX2xlYXZlQ2I9RCgoKCk9PntyLnBhcmVudE5vZGUmJnIucGFyZW50Tm9kZS5fcGVuZGluZyYmKHIucGFyZW50Tm9kZS5fcGVuZGluZ1t0LmtleV09bnVsbCksZyYmKEZyKHIsdSksRnIocixmKSksdy5jYW5jZWxsZWQ/KGcmJkZyKHIsbCksXyYmXyhyKSk6KGUoKSxtJiZtKHIpKSxyLl9sZWF2ZUNiPW51bGx9KSk7ZnVuY3Rpb24gQygpe3cuY2FuY2VsbGVkfHwoIXQuZGF0YS5zaG93JiZyLnBhcmVudE5vZGUmJigoci5wYXJlbnROb2RlLl9wZW5kaW5nfHwoci5wYXJlbnROb2RlLl9wZW5kaW5nPXt9KSlbdC5rZXldPXQpLGQmJmQociksZyYmKExyKHIsbCksTHIocixmKSxScigoKCk9PntGcihyLGwpLHcuY2FuY2VsbGVkfHwoTHIocix1KSxifHwocXIoJCk/c2V0VGltZW91dCh3LCQpOlVyKHIsYSx3KSkpfSkpKSxoJiZoKHIsdyksZ3x8Ynx8dygpKX12P3YoQyk6QygpfWZ1bmN0aW9uIHFyKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0JiYhaXNOYU4odCl9ZnVuY3Rpb24gR3IodCl7aWYobih0KSlyZXR1cm4hMTtjb25zdCBlPXQuZm5zO3JldHVybiBvKGUpP0dyKEFycmF5LmlzQXJyYXkoZSk/ZVswXTplKToodC5fbGVuZ3RofHx0Lmxlbmd0aCk+MX1mdW5jdGlvbiBacih0LGUpeyEwIT09ZS5kYXRhLnNob3cmJldyKGUpfWNvbnN0IEpyPWZ1bmN0aW9uKHQpe2xldCBpLGM7Y29uc3QgYT17fSx7bW9kdWxlczpsLG5vZGVPcHM6dX09dDtmb3IoaT0wO2k8Vm8ubGVuZ3RoOysraSlmb3IoYVtWb1tpXV09W10sYz0wO2M8bC5sZW5ndGg7KytjKW8obFtjXVtWb1tpXV0pJiZhW1ZvW2ldXS5wdXNoKGxbY11bVm9baV1dKTtmdW5jdGlvbiBmKHQpe2NvbnN0IGU9dS5wYXJlbnROb2RlKHQpO28oZSkmJnUucmVtb3ZlQ2hpbGQoZSx0KX1mdW5jdGlvbiBkKHQsZSxuLHMsaSxjLGwpe2lmKG8odC5lbG0pJiZvKGMpJiYodD1jW2xdPWx0KHQpKSx0LmlzUm9vdEluc2VydD0haSxmdW5jdGlvbih0LGUsbixzKXtsZXQgaT10LmRhdGE7aWYobyhpKSl7Y29uc3QgYz1vKHQuY29tcG9uZW50SW5zdGFuY2UpJiZpLmtlZXBBbGl2ZTtpZihvKGk9aS5ob29rKSYmbyhpPWkuaW5pdCkmJmkodCwhMSksbyh0LmNvbXBvbmVudEluc3RhbmNlKSlyZXR1cm4gcCh0LGUpLG0obix0LmVsbSxzKSxyKGMpJiZmdW5jdGlvbih0LGUsbixyKXtsZXQgcyxpPXQ7Zm9yKDtpLmNvbXBvbmVudEluc3RhbmNlOylpZihpPWkuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLG8ocz1pLmRhdGEpJiZvKHM9cy50cmFuc2l0aW9uKSl7Zm9yKHM9MDtzPGEuYWN0aXZhdGUubGVuZ3RoOysrcylhLmFjdGl2YXRlW3NdKEJvLGkpO2UucHVzaChpKTticmVha31tKG4sdC5lbG0scil9KHQsZSxuLHMpLCEwfX0odCxlLG4scykpcmV0dXJuO2NvbnN0IGY9dC5kYXRhLGQ9dC5jaGlsZHJlbixoPXQudGFnO28oaCk/KHQuZWxtPXQubnM/dS5jcmVhdGVFbGVtZW50TlModC5ucyxoKTp1LmNyZWF0ZUVsZW1lbnQoaCx0KSxnKHQpLF8odCxkLGUpLG8oZikmJnkodCxlKSxtKG4sdC5lbG0scykpOnIodC5pc0NvbW1lbnQpPyh0LmVsbT11LmNyZWF0ZUNvbW1lbnQodC50ZXh0KSxtKG4sdC5lbG0scykpOih0LmVsbT11LmNyZWF0ZVRleHROb2RlKHQudGV4dCksbShuLHQuZWxtLHMpKX1mdW5jdGlvbiBwKHQsZSl7byh0LmRhdGEucGVuZGluZ0luc2VydCkmJihlLnB1c2guYXBwbHkoZSx0LmRhdGEucGVuZGluZ0luc2VydCksdC5kYXRhLnBlbmRpbmdJbnNlcnQ9bnVsbCksdC5lbG09dC5jb21wb25lbnRJbnN0YW5jZS4kZWwsdih0KT8oeSh0LGUpLGcodCkpOihGbyh0KSxlLnB1c2godCkpfWZ1bmN0aW9uIG0odCxlLG4pe28odCkmJihvKG4pP3UucGFyZW50Tm9kZShuKT09PXQmJnUuaW5zZXJ0QmVmb3JlKHQsZSxuKTp1LmFwcGVuZENoaWxkKHQsZSkpfWZ1bmN0aW9uIF8odCxuLG8pe2lmKGUobikpZm9yKGxldCBlPTA7ZTxuLmxlbmd0aDsrK2UpZChuW2VdLG8sdC5lbG0sbnVsbCwhMCxuLGUpO2Vsc2Ugcyh0LnRleHQpJiZ1LmFwcGVuZENoaWxkKHQuZWxtLHUuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHQudGV4dCkpKX1mdW5jdGlvbiB2KHQpe2Zvcig7dC5jb21wb25lbnRJbnN0YW5jZTspdD10LmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtyZXR1cm4gbyh0LnRhZyl9ZnVuY3Rpb24geSh0LGUpe2ZvcihsZXQgZT0wO2U8YS5jcmVhdGUubGVuZ3RoOysrZSlhLmNyZWF0ZVtlXShCbyx0KTtpPXQuZGF0YS5ob29rLG8oaSkmJihvKGkuY3JlYXRlKSYmaS5jcmVhdGUoQm8sdCksbyhpLmluc2VydCkmJmUucHVzaCh0KSl9ZnVuY3Rpb24gZyh0KXtsZXQgZTtpZihvKGU9dC5mblNjb3BlSWQpKXUuc2V0U3R5bGVTY29wZSh0LmVsbSxlKTtlbHNle2xldCBuPXQ7Zm9yKDtuOylvKGU9bi5jb250ZXh0KSYmbyhlPWUuJG9wdGlvbnMuX3Njb3BlSWQpJiZ1LnNldFN0eWxlU2NvcGUodC5lbG0sZSksbj1uLnBhcmVudH1vKGU9cG4pJiZlIT09dC5jb250ZXh0JiZlIT09dC5mbkNvbnRleHQmJm8oZT1lLiRvcHRpb25zLl9zY29wZUlkKSYmdS5zZXRTdHlsZVNjb3BlKHQuZWxtLGUpfWZ1bmN0aW9uIGIodCxlLG4sbyxyLHMpe2Zvcig7bzw9cjsrK28pZChuW29dLHMsdCxlLCExLG4sbyl9ZnVuY3Rpb24gJCh0KXtsZXQgZSxuO2NvbnN0IHI9dC5kYXRhO2lmKG8ocikpZm9yKG8oZT1yLmhvb2spJiZvKGU9ZS5kZXN0cm95KSYmZSh0KSxlPTA7ZTxhLmRlc3Ryb3kubGVuZ3RoOysrZSlhLmRlc3Ryb3lbZV0odCk7aWYobyhlPXQuY2hpbGRyZW4pKWZvcihuPTA7bjx0LmNoaWxkcmVuLmxlbmd0aDsrK24pJCh0LmNoaWxkcmVuW25dKX1mdW5jdGlvbiB3KHQsZSxuKXtmb3IoO2U8PW47KytlKXtjb25zdCBuPXRbZV07byhuKSYmKG8obi50YWcpPyhDKG4pLCQobikpOmYobi5lbG0pKX19ZnVuY3Rpb24gQyh0LGUpe2lmKG8oZSl8fG8odC5kYXRhKSl7bGV0IG47Y29uc3Qgcj1hLnJlbW92ZS5sZW5ndGgrMTtmb3IobyhlKT9lLmxpc3RlbmVycys9cjplPWZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbigpezA9PS0tbi5saXN0ZW5lcnMmJmYodCl9cmV0dXJuIG4ubGlzdGVuZXJzPWUsbn0odC5lbG0sciksbyhuPXQuY29tcG9uZW50SW5zdGFuY2UpJiZvKG49bi5fdm5vZGUpJiZvKG4uZGF0YSkmJkMobixlKSxuPTA7bjxhLnJlbW92ZS5sZW5ndGg7KytuKWEucmVtb3ZlW25dKHQsZSk7byhuPXQuZGF0YS5ob29rKSYmbyhuPW4ucmVtb3ZlKT9uKHQsZSk6ZSgpfWVsc2UgZih0LmVsbSl9ZnVuY3Rpb24geCh0LGUsbixyKXtmb3IobGV0IHM9bjtzPHI7cysrKXtjb25zdCBuPWVbc107aWYobyhuKSYmem8odCxuKSlyZXR1cm4gc319ZnVuY3Rpb24gayh0LGUscyxpLGMsbCl7aWYodD09PWUpcmV0dXJuO28oZS5lbG0pJiZvKGkpJiYoZT1pW2NdPWx0KGUpKTtjb25zdCBmPWUuZWxtPXQuZWxtO2lmKHIodC5pc0FzeW5jUGxhY2Vob2xkZXIpKXJldHVybiB2b2lkKG8oZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpP2oodC5lbG0sZSxzKTplLmlzQXN5bmNQbGFjZWhvbGRlcj0hMCk7aWYocihlLmlzU3RhdGljKSYmcih0LmlzU3RhdGljKSYmZS5rZXk9PT10LmtleSYmKHIoZS5pc0Nsb25lZCl8fHIoZS5pc09uY2UpKSlyZXR1cm4gdm9pZChlLmNvbXBvbmVudEluc3RhbmNlPXQuY29tcG9uZW50SW5zdGFuY2UpO2xldCBwO2NvbnN0IGg9ZS5kYXRhO28oaCkmJm8ocD1oLmhvb2spJiZvKHA9cC5wcmVwYXRjaCkmJnAodCxlKTtjb25zdCBtPXQuY2hpbGRyZW4sXz1lLmNoaWxkcmVuO2lmKG8oaCkmJnYoZSkpe2ZvcihwPTA7cDxhLnVwZGF0ZS5sZW5ndGg7KytwKWEudXBkYXRlW3BdKHQsZSk7byhwPWguaG9vaykmJm8ocD1wLnVwZGF0ZSkmJnAodCxlKX1uKGUudGV4dCk/byhtKSYmbyhfKT9tIT09XyYmZnVuY3Rpb24odCxlLHIscyxpKXtsZXQgYyxhLGwsZixwPTAsaD0wLG09ZS5sZW5ndGgtMSxfPWVbMF0sdj1lW21dLHk9ci5sZW5ndGgtMSxnPXJbMF0sJD1yW3ldO2NvbnN0IEM9IWk7Zm9yKDtwPD1tJiZoPD15OyluKF8pP189ZVsrK3BdOm4odik/dj1lWy0tbV06em8oXyxnKT8oayhfLGcscyxyLGgpLF89ZVsrK3BdLGc9clsrK2hdKTp6byh2LCQpPyhrKHYsJCxzLHIseSksdj1lWy0tbV0sJD1yWy0teV0pOnpvKF8sJCk/KGsoXywkLHMscix5KSxDJiZ1Lmluc2VydEJlZm9yZSh0LF8uZWxtLHUubmV4dFNpYmxpbmcodi5lbG0pKSxfPWVbKytwXSwkPXJbLS15XSk6em8odixnKT8oayh2LGcscyxyLGgpLEMmJnUuaW5zZXJ0QmVmb3JlKHQsdi5lbG0sXy5lbG0pLHY9ZVstLW1dLGc9clsrK2hdKToobihjKSYmKGM9SG8oZSxwLG0pKSxhPW8oZy5rZXkpP2NbZy5rZXldOngoZyxlLHAsbSksbihhKT9kKGcscyx0LF8uZWxtLCExLHIsaCk6KGw9ZVthXSx6byhsLGcpPyhrKGwsZyxzLHIsaCksZVthXT12b2lkIDAsQyYmdS5pbnNlcnRCZWZvcmUodCxsLmVsbSxfLmVsbSkpOmQoZyxzLHQsXy5lbG0sITEscixoKSksZz1yWysraF0pO3A+bT8oZj1uKHJbeSsxXSk/bnVsbDpyW3krMV0uZWxtLGIodCxmLHIsaCx5LHMpKTpoPnkmJncoZSxwLG0pfShmLG0sXyxzLGwpOm8oXyk/KG8odC50ZXh0KSYmdS5zZXRUZXh0Q29udGVudChmLFwiXCIpLGIoZixudWxsLF8sMCxfLmxlbmd0aC0xLHMpKTpvKG0pP3cobSwwLG0ubGVuZ3RoLTEpOm8odC50ZXh0KSYmdS5zZXRUZXh0Q29udGVudChmLFwiXCIpOnQudGV4dCE9PWUudGV4dCYmdS5zZXRUZXh0Q29udGVudChmLGUudGV4dCksbyhoKSYmbyhwPWguaG9vaykmJm8ocD1wLnBvc3RwYXRjaCkmJnAodCxlKX1mdW5jdGlvbiBPKHQsZSxuKXtpZihyKG4pJiZvKHQucGFyZW50KSl0LnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQ9ZTtlbHNlIGZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7Kyt0KWVbdF0uZGF0YS5ob29rLmluc2VydChlW3RdKX1jb25zdCBTPWgoXCJhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXlcIik7ZnVuY3Rpb24gaih0LGUsbixzKXtsZXQgaTtjb25zdHt0YWc6YyxkYXRhOmEsY2hpbGRyZW46bH09ZTtpZihzPXN8fGEmJmEucHJlLGUuZWxtPXQscihlLmlzQ29tbWVudCkmJm8oZS5hc3luY0ZhY3RvcnkpKXJldHVybiBlLmlzQXN5bmNQbGFjZWhvbGRlcj0hMCwhMDtpZihvKGEpJiYobyhpPWEuaG9vaykmJm8oaT1pLmluaXQpJiZpKGUsITApLG8oaT1lLmNvbXBvbmVudEluc3RhbmNlKSkpcmV0dXJuIHAoZSxuKSwhMDtpZihvKGMpKXtpZihvKGwpKWlmKHQuaGFzQ2hpbGROb2RlcygpKWlmKG8oaT1hKSYmbyhpPWkuZG9tUHJvcHMpJiZvKGk9aS5pbm5lckhUTUwpKXtpZihpIT09dC5pbm5lckhUTUwpcmV0dXJuITF9ZWxzZXtsZXQgZT0hMCxvPXQuZmlyc3RDaGlsZDtmb3IobGV0IHQ9MDt0PGwubGVuZ3RoO3QrKyl7aWYoIW98fCFqKG8sbFt0XSxuLHMpKXtlPSExO2JyZWFrfW89by5uZXh0U2libGluZ31pZighZXx8bylyZXR1cm4hMX1lbHNlIF8oZSxsLG4pO2lmKG8oYSkpe2xldCB0PSExO2Zvcihjb25zdCBvIGluIGEpaWYoIVMobykpe3Q9ITAseShlLG4pO2JyZWFrfSF0JiZhLmNsYXNzJiZvbihhLmNsYXNzKX19ZWxzZSB0LmRhdGEhPT1lLnRleHQmJih0LmRhdGE9ZS50ZXh0KTtyZXR1cm4hMH1yZXR1cm4gZnVuY3Rpb24odCxlLHMsaSl7aWYobihlKSlyZXR1cm4gdm9pZChvKHQpJiYkKHQpKTtsZXQgYz0hMTtjb25zdCBsPVtdO2lmKG4odCkpYz0hMCxkKGUsbCk7ZWxzZXtjb25zdCBuPW8odC5ub2RlVHlwZSk7aWYoIW4mJnpvKHQsZSkpayh0LGUsbCxudWxsLG51bGwsaSk7ZWxzZXtpZihuKXtpZigxPT09dC5ub2RlVHlwZSYmdC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXNlcnZlci1yZW5kZXJlZFwiKSYmKHQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1zZXJ2ZXItcmVuZGVyZWRcIikscz0hMCkscihzKSYmaih0LGUsbCkpcmV0dXJuIE8oZSxsLCEwKSx0O2Y9dCx0PW5ldyBpdCh1LnRhZ05hbWUoZikudG9Mb3dlckNhc2UoKSx7fSxbXSx2b2lkIDAsZil9Y29uc3QgaT10LmVsbSxjPXUucGFyZW50Tm9kZShpKTtpZihkKGUsbCxpLl9sZWF2ZUNiP251bGw6Yyx1Lm5leHRTaWJsaW5nKGkpKSxvKGUucGFyZW50KSl7bGV0IHQ9ZS5wYXJlbnQ7Y29uc3Qgbj12KGUpO2Zvcig7dDspe2ZvcihsZXQgZT0wO2U8YS5kZXN0cm95Lmxlbmd0aDsrK2UpYS5kZXN0cm95W2VdKHQpO2lmKHQuZWxtPWUuZWxtLG4pe2ZvcihsZXQgZT0wO2U8YS5jcmVhdGUubGVuZ3RoOysrZSlhLmNyZWF0ZVtlXShCbyx0KTtjb25zdCBlPXQuZGF0YS5ob29rLmluc2VydDtpZihlLm1lcmdlZClmb3IobGV0IHQ9MTt0PGUuZm5zLmxlbmd0aDt0KyspZS5mbnNbdF0oKX1lbHNlIEZvKHQpO3Q9dC5wYXJlbnR9fW8oYyk/dyhbdF0sMCwwKTpvKHQudGFnKSYmJCh0KX19dmFyIGY7cmV0dXJuIE8oZSxsLGMpLGUuZWxtfX0oe25vZGVPcHM6Um8sbW9kdWxlczpbZXIsb3IsdXIsaHIsa3Isej97Y3JlYXRlOlpyLGFjdGl2YXRlOlpyLHJlbW92ZSh0LGUpeyEwIT09dC5kYXRhLnNob3c/S3IodCxlKTplKCl9fTp7fV0uY29uY2F0KFhvKX0pO0smJmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwoKCk9Pntjb25zdCB0PWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7dCYmdC52bW9kZWwmJnJzKHQsXCJpbnB1dFwiKX0pKTtjb25zdCBYcj17aW5zZXJ0ZWQodCxlLG4sbyl7XCJzZWxlY3RcIj09PW4udGFnPyhvLmVsbSYmIW8uZWxtLl92T3B0aW9ucz9KdChuLFwicG9zdHBhdGNoXCIsKCgpPT57WHIuY29tcG9uZW50VXBkYXRlZCh0LGUsbil9KSk6UXIodCxlLG4uY29udGV4dCksdC5fdk9wdGlvbnM9W10ubWFwLmNhbGwodC5vcHRpb25zLGVzKSk6KFwidGV4dGFyZWFcIj09PW4udGFnfHxNbyh0LnR5cGUpKSYmKHQuX3ZNb2RpZmllcnM9ZS5tb2RpZmllcnMsZS5tb2RpZmllcnMubGF6eXx8KHQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbXBvc2l0aW9uc3RhcnRcIixucyksdC5hZGRFdmVudExpc3RlbmVyKFwiY29tcG9zaXRpb25lbmRcIixvcyksdC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsb3MpLEsmJih0LnZtb2RlbD0hMCkpKX0sY29tcG9uZW50VXBkYXRlZCh0LGUsbil7aWYoXCJzZWxlY3RcIj09PW4udGFnKXtRcih0LGUsbi5jb250ZXh0KTtjb25zdCBvPXQuX3ZPcHRpb25zLHI9dC5fdk9wdGlvbnM9W10ubWFwLmNhbGwodC5vcHRpb25zLGVzKTtpZihyLnNvbWUoKCh0LGUpPT4hUCh0LG9bZV0pKSkpeyh0Lm11bHRpcGxlP2UudmFsdWUuc29tZSgodD0+dHModCxyKSkpOmUudmFsdWUhPT1lLm9sZFZhbHVlJiZ0cyhlLnZhbHVlLHIpKSYmcnModCxcImNoYW5nZVwiKX19fX07ZnVuY3Rpb24gUXIodCxlLG4pe1lyKHQsZSksKFd8fHEpJiZzZXRUaW1lb3V0KCgoKT0+e1lyKHQsZSl9KSwwKX1mdW5jdGlvbiBZcih0LGUsbil7Y29uc3Qgbz1lLnZhbHVlLHI9dC5tdWx0aXBsZTtpZihyJiYhQXJyYXkuaXNBcnJheShvKSlyZXR1cm47bGV0IHMsaTtmb3IobGV0IGU9MCxuPXQub3B0aW9ucy5sZW5ndGg7ZTxuO2UrKylpZihpPXQub3B0aW9uc1tlXSxyKXM9SShvLGVzKGkpKT4tMSxpLnNlbGVjdGVkIT09cyYmKGkuc2VsZWN0ZWQ9cyk7ZWxzZSBpZihQKGVzKGkpLG8pKXJldHVybiB2b2lkKHQuc2VsZWN0ZWRJbmRleCE9PWUmJih0LnNlbGVjdGVkSW5kZXg9ZSkpO3J8fCh0LnNlbGVjdGVkSW5kZXg9LTEpfWZ1bmN0aW9uIHRzKHQsZSl7cmV0dXJuIGUuZXZlcnkoKGU9PiFQKGUsdCkpKX1mdW5jdGlvbiBlcyh0KXtyZXR1cm5cIl92YWx1ZVwiaW4gdD90Ll92YWx1ZTp0LnZhbHVlfWZ1bmN0aW9uIG5zKHQpe3QudGFyZ2V0LmNvbXBvc2luZz0hMH1mdW5jdGlvbiBvcyh0KXt0LnRhcmdldC5jb21wb3NpbmcmJih0LnRhcmdldC5jb21wb3Npbmc9ITEscnModC50YXJnZXQsXCJpbnB1dFwiKSl9ZnVuY3Rpb24gcnModCxlKXtjb25zdCBuPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiSFRNTEV2ZW50c1wiKTtuLmluaXRFdmVudChlLCEwLCEwKSx0LmRpc3BhdGNoRXZlbnQobil9ZnVuY3Rpb24gc3ModCl7cmV0dXJuIXQuY29tcG9uZW50SW5zdGFuY2V8fHQuZGF0YSYmdC5kYXRhLnRyYW5zaXRpb24/dDpzcyh0LmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSl9dmFyIGlzPXtiaW5kKHQse3ZhbHVlOmV9LG4pe2NvbnN0IG89KG49c3MobikpLmRhdGEmJm4uZGF0YS50cmFuc2l0aW9uLHI9dC5fX3ZPcmlnaW5hbERpc3BsYXk9XCJub25lXCI9PT10LnN0eWxlLmRpc3BsYXk/XCJcIjp0LnN0eWxlLmRpc3BsYXk7ZSYmbz8obi5kYXRhLnNob3c9ITAsV3IobiwoKCk9Pnt0LnN0eWxlLmRpc3BsYXk9cn0pKSk6dC5zdHlsZS5kaXNwbGF5PWU/cjpcIm5vbmVcIn0sdXBkYXRlKHQse3ZhbHVlOmUsb2xkVmFsdWU6bn0sbyl7aWYoIWU9PSFuKXJldHVybjsobz1zcyhvKSkuZGF0YSYmby5kYXRhLnRyYW5zaXRpb24/KG8uZGF0YS5zaG93PSEwLGU/V3IobywoKCk9Pnt0LnN0eWxlLmRpc3BsYXk9dC5fX3ZPcmlnaW5hbERpc3BsYXl9KSk6S3IobywoKCk9Pnt0LnN0eWxlLmRpc3BsYXk9XCJub25lXCJ9KSkpOnQuc3R5bGUuZGlzcGxheT1lP3QuX192T3JpZ2luYWxEaXNwbGF5Olwibm9uZVwifSx1bmJpbmQodCxlLG4sbyxyKXtyfHwodC5zdHlsZS5kaXNwbGF5PXQuX192T3JpZ2luYWxEaXNwbGF5KX19LGNzPXttb2RlbDpYcixzaG93OmlzfTtjb25zdCBhcz17bmFtZTpTdHJpbmcsYXBwZWFyOkJvb2xlYW4sY3NzOkJvb2xlYW4sbW9kZTpTdHJpbmcsdHlwZTpTdHJpbmcsZW50ZXJDbGFzczpTdHJpbmcsbGVhdmVDbGFzczpTdHJpbmcsZW50ZXJUb0NsYXNzOlN0cmluZyxsZWF2ZVRvQ2xhc3M6U3RyaW5nLGVudGVyQWN0aXZlQ2xhc3M6U3RyaW5nLGxlYXZlQWN0aXZlQ2xhc3M6U3RyaW5nLGFwcGVhckNsYXNzOlN0cmluZyxhcHBlYXJBY3RpdmVDbGFzczpTdHJpbmcsYXBwZWFyVG9DbGFzczpTdHJpbmcsZHVyYXRpb246W051bWJlcixTdHJpbmcsT2JqZWN0XX07ZnVuY3Rpb24gbHModCl7Y29uc3QgZT10JiZ0LmNvbXBvbmVudE9wdGlvbnM7cmV0dXJuIGUmJmUuQ3Rvci5vcHRpb25zLmFic3RyYWN0P2xzKEFlKGUuY2hpbGRyZW4pKTp0fWZ1bmN0aW9uIHVzKHQpe2NvbnN0IGU9e30sbj10LiRvcHRpb25zO2Zvcihjb25zdCBvIGluIG4ucHJvcHNEYXRhKWVbb109dFtvXTtjb25zdCBvPW4uX3BhcmVudExpc3RlbmVycztmb3IoY29uc3QgdCBpbiBvKWVbJCh0KV09b1t0XTtyZXR1cm4gZX1mdW5jdGlvbiBmcyh0LGUpe2lmKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QoZS50YWcpKXJldHVybiB0KFwia2VlcC1hbGl2ZVwiLHtwcm9wczplLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhfSl9Y29uc3QgZHM9dD0+dC50YWd8fHllKHQpLHBzPXQ9Plwic2hvd1wiPT09dC5uYW1lO3ZhciBocz17bmFtZTpcInRyYW5zaXRpb25cIixwcm9wczphcyxhYnN0cmFjdDohMCxyZW5kZXIodCl7bGV0IGU9dGhpcy4kc2xvdHMuZGVmYXVsdDtpZighZSlyZXR1cm47aWYoZT1lLmZpbHRlcihkcyksIWUubGVuZ3RoKXJldHVybjtjb25zdCBuPXRoaXMubW9kZSxvPWVbMF07aWYoZnVuY3Rpb24odCl7Zm9yKDt0PXQucGFyZW50OylpZih0LmRhdGEudHJhbnNpdGlvbilyZXR1cm4hMH0odGhpcy4kdm5vZGUpKXJldHVybiBvO2NvbnN0IHI9bHMobyk7aWYoIXIpcmV0dXJuIG87aWYodGhpcy5fbGVhdmluZylyZXR1cm4gZnModCxvKTtjb25zdCBpPWBfX3RyYW5zaXRpb24tJHt0aGlzLl91aWR9LWA7ci5rZXk9bnVsbD09ci5rZXk/ci5pc0NvbW1lbnQ/aStcImNvbW1lbnRcIjppK3IudGFnOnMoci5rZXkpPzA9PT1TdHJpbmcoci5rZXkpLmluZGV4T2YoaSk/ci5rZXk6aStyLmtleTpyLmtleTtjb25zdCBjPShyLmRhdGF8fChyLmRhdGE9e30pKS50cmFuc2l0aW9uPXVzKHRoaXMpLGE9dGhpcy5fdm5vZGUsbD1scyhhKTtpZihyLmRhdGEuZGlyZWN0aXZlcyYmci5kYXRhLmRpcmVjdGl2ZXMuc29tZShwcykmJihyLmRhdGEuc2hvdz0hMCksbCYmbC5kYXRhJiYhZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5rZXk9PT10LmtleSYmZS50YWc9PT10LnRhZ30ocixsKSYmIXllKGwpJiYoIWwuY29tcG9uZW50SW5zdGFuY2V8fCFsLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZS5pc0NvbW1lbnQpKXtjb25zdCBlPWwuZGF0YS50cmFuc2l0aW9uPVMoe30sYyk7aWYoXCJvdXQtaW5cIj09PW4pcmV0dXJuIHRoaXMuX2xlYXZpbmc9ITAsSnQoZSxcImFmdGVyTGVhdmVcIiwoKCk9Pnt0aGlzLl9sZWF2aW5nPSExLHRoaXMuJGZvcmNlVXBkYXRlKCl9KSksZnModCxvKTtpZihcImluLW91dFwiPT09bil7aWYoeWUocikpcmV0dXJuIGE7bGV0IHQ7Y29uc3Qgbj0oKT0+e3QoKX07SnQoYyxcImFmdGVyRW50ZXJcIixuKSxKdChjLFwiZW50ZXJDYW5jZWxsZWRcIixuKSxKdChlLFwiZGVsYXlMZWF2ZVwiLChlPT57dD1lfSkpfX1yZXR1cm4gb319O2NvbnN0IG1zPVMoe3RhZzpTdHJpbmcsbW92ZUNsYXNzOlN0cmluZ30sYXMpO2RlbGV0ZSBtcy5tb2RlO3ZhciBfcz17cHJvcHM6bXMsYmVmb3JlTW91bnQoKXtjb25zdCB0PXRoaXMuX3VwZGF0ZTt0aGlzLl91cGRhdGU9KGUsbik9Pntjb25zdCBvPWhuKHRoaXMpO3RoaXMuX19wYXRjaF9fKHRoaXMuX3Zub2RlLHRoaXMua2VwdCwhMSwhMCksdGhpcy5fdm5vZGU9dGhpcy5rZXB0LG8oKSx0LmNhbGwodGhpcyxlLG4pfX0scmVuZGVyKHQpe2NvbnN0IGU9dGhpcy50YWd8fHRoaXMuJHZub2RlLmRhdGEudGFnfHxcInNwYW5cIixuPU9iamVjdC5jcmVhdGUobnVsbCksbz10aGlzLnByZXZDaGlsZHJlbj10aGlzLmNoaWxkcmVuLHI9dGhpcy4kc2xvdHMuZGVmYXVsdHx8W10scz10aGlzLmNoaWxkcmVuPVtdLGk9dXModGhpcyk7Zm9yKGxldCB0PTA7dDxyLmxlbmd0aDt0Kyspe2NvbnN0IGU9clt0XTtlLnRhZyYmbnVsbCE9ZS5rZXkmJjAhPT1TdHJpbmcoZS5rZXkpLmluZGV4T2YoXCJfX3ZsaXN0XCIpJiYocy5wdXNoKGUpLG5bZS5rZXldPWUsKGUuZGF0YXx8KGUuZGF0YT17fSkpLnRyYW5zaXRpb249aSl9aWYobyl7Y29uc3Qgcj1bXSxzPVtdO2ZvcihsZXQgdD0wO3Q8by5sZW5ndGg7dCsrKXtjb25zdCBlPW9bdF07ZS5kYXRhLnRyYW5zaXRpb249aSxlLmRhdGEucG9zPWUuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG5bZS5rZXldP3IucHVzaChlKTpzLnB1c2goZSl9dGhpcy5rZXB0PXQoZSxudWxsLHIpLHRoaXMucmVtb3ZlZD1zfXJldHVybiB0KGUsbnVsbCxzKX0sdXBkYXRlZCgpe2NvbnN0IHQ9dGhpcy5wcmV2Q2hpbGRyZW4sZT10aGlzLm1vdmVDbGFzc3x8KHRoaXMubmFtZXx8XCJ2XCIpK1wiLW1vdmVcIjt0Lmxlbmd0aCYmdGhpcy5oYXNNb3ZlKHRbMF0uZWxtLGUpJiYodC5mb3JFYWNoKHZzKSx0LmZvckVhY2goeXMpLHQuZm9yRWFjaChncyksdGhpcy5fcmVmbG93PWRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0LHQuZm9yRWFjaCgodD0+e2lmKHQuZGF0YS5tb3ZlZCl7Y29uc3Qgbj10LmVsbSxvPW4uc3R5bGU7THIobixlKSxvLnRyYW5zZm9ybT1vLldlYmtpdFRyYW5zZm9ybT1vLnRyYW5zaXRpb25EdXJhdGlvbj1cIlwiLG4uYWRkRXZlbnRMaXN0ZW5lcihJcixuLl9tb3ZlQ2I9ZnVuY3Rpb24gdChvKXtvJiZvLnRhcmdldCE9PW58fG8mJiEvdHJhbnNmb3JtJC8udGVzdChvLnByb3BlcnR5TmFtZSl8fChuLnJlbW92ZUV2ZW50TGlzdGVuZXIoSXIsdCksbi5fbW92ZUNiPW51bGwsRnIobixlKSl9KX19KSkpfSxtZXRob2RzOntoYXNNb3ZlKHQsZSl7aWYoIUVyKXJldHVybiExO2lmKHRoaXMuX2hhc01vdmUpcmV0dXJuIHRoaXMuX2hhc01vdmU7Y29uc3Qgbj10LmNsb25lTm9kZSgpO3QuX3RyYW5zaXRpb25DbGFzc2VzJiZ0Ll90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKCh0PT57anIobix0KX0pKSxTcihuLGUpLG4uc3R5bGUuZGlzcGxheT1cIm5vbmVcIix0aGlzLiRlbC5hcHBlbmRDaGlsZChuKTtjb25zdCBvPVZyKG4pO3JldHVybiB0aGlzLiRlbC5yZW1vdmVDaGlsZChuKSx0aGlzLl9oYXNNb3ZlPW8uaGFzVHJhbnNmb3JtfX19O2Z1bmN0aW9uIHZzKHQpe3QuZWxtLl9tb3ZlQ2ImJnQuZWxtLl9tb3ZlQ2IoKSx0LmVsbS5fZW50ZXJDYiYmdC5lbG0uX2VudGVyQ2IoKX1mdW5jdGlvbiB5cyh0KXt0LmRhdGEubmV3UG9zPXQuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpfWZ1bmN0aW9uIGdzKHQpe2NvbnN0IGU9dC5kYXRhLnBvcyxuPXQuZGF0YS5uZXdQb3Msbz1lLmxlZnQtbi5sZWZ0LHI9ZS50b3Atbi50b3A7aWYob3x8cil7dC5kYXRhLm1vdmVkPSEwO2NvbnN0IGU9dC5lbG0uc3R5bGU7ZS50cmFuc2Zvcm09ZS5XZWJraXRUcmFuc2Zvcm09YHRyYW5zbGF0ZSgke299cHgsJHtyfXB4KWAsZS50cmFuc2l0aW9uRHVyYXRpb249XCIwc1wifX12YXIgYnM9e1RyYW5zaXRpb246aHMsVHJhbnNpdGlvbkdyb3VwOl9zfTtsby5jb25maWcubXVzdFVzZVByb3A9KHQsZSxuKT0+XCJ2YWx1ZVwiPT09biYmZ28odCkmJlwiYnV0dG9uXCIhPT1lfHxcInNlbGVjdGVkXCI9PT1uJiZcIm9wdGlvblwiPT09dHx8XCJjaGVja2VkXCI9PT1uJiZcImlucHV0XCI9PT10fHxcIm11dGVkXCI9PT1uJiZcInZpZGVvXCI9PT10LGxvLmNvbmZpZy5pc1Jlc2VydmVkVGFnPURvLGxvLmNvbmZpZy5pc1Jlc2VydmVkQXR0cj15byxsby5jb25maWcuZ2V0VGFnTmFtZXNwYWNlPWZ1bmN0aW9uKHQpe3JldHVybiBJbyh0KT9cInN2Z1wiOlwibWF0aFwiPT09dD9cIm1hdGhcIjp2b2lkIDB9LGxvLmNvbmZpZy5pc1Vua25vd25FbGVtZW50PWZ1bmN0aW9uKHQpe2lmKCF6KXJldHVybiEwO2lmKERvKHQpKXJldHVybiExO2lmKHQ9dC50b0xvd2VyQ2FzZSgpLG51bGwhPU5vW3RdKXJldHVybiBOb1t0XTtjb25zdCBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodCk7cmV0dXJuIHQuaW5kZXhPZihcIi1cIik+LTE/Tm9bdF09ZS5jb25zdHJ1Y3Rvcj09PXdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnR8fGUuY29uc3RydWN0b3I9PT13aW5kb3cuSFRNTEVsZW1lbnQ6Tm9bdF09L0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlLnRvU3RyaW5nKCkpfSxTKGxvLm9wdGlvbnMuZGlyZWN0aXZlcyxjcyksUyhsby5vcHRpb25zLmNvbXBvbmVudHMsYnMpLGxvLnByb3RvdHlwZS5fX3BhdGNoX189ej9KcjpBLGxvLnByb3RvdHlwZS4kbW91bnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe2xldCBvO3QuJGVsPWUsdC4kb3B0aW9ucy5yZW5kZXJ8fCh0LiRvcHRpb25zLnJlbmRlcj1jdCkseW4odCxcImJlZm9yZU1vdW50XCIpLG89KCk9Pnt0Ll91cGRhdGUodC5fcmVuZGVyKCksbil9LG5ldyBhbih0LG8sQSx7YmVmb3JlKCl7dC5faXNNb3VudGVkJiYhdC5faXNEZXN0cm95ZWQmJnluKHQsXCJiZWZvcmVVcGRhdGVcIil9fSwhMCksbj0hMTtjb25zdCByPXQuX3ByZVdhdGNoZXJzO2lmKHIpZm9yKGxldCB0PTA7dDxyLmxlbmd0aDt0Kyspclt0XS5ydW4oKTtyZXR1cm4gbnVsbD09dC4kdm5vZGUmJih0Ll9pc01vdW50ZWQ9ITAseW4odCxcIm1vdW50ZWRcIikpLHR9KHRoaXMsdD10JiZ6P2Z1bmN0aW9uKHQpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXtyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0KXx8ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKX1yZXR1cm4gdH0odCk6dm9pZCAwLGUpfSx6JiZzZXRUaW1lb3V0KCgoKT0+e0wuZGV2dG9vbHMmJnR0JiZ0dC5lbWl0KFwiaW5pdFwiLGxvKX0pLDApLFMobG8sZW4pLG1vZHVsZS5leHBvcnRzPWxvOyIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGlkPVwiZmlsZXNfY2xhc3NpZmllclwiIGNsYXNzPVwic2VjdGlvblwiPlxuICAgICAgICA8aDIgdi10cmFuc2xhdGU+XG4gICAgICAgICAgICBEb2N1bWVudCBDbGFzc2lmaWNhdGlvbiBhbmQgRmVhdHVyZSBQb2xpY2llc1xuICAgICAgICAgICAgPC9oMj5cbiAgICAgICAgPHAgdi10cmFuc2xhdGU+XG4gICAgICAgICAgICBEZWZpbmUgcnVsZXMgdG8gYXV0b21hdGljYWxseSB0YWcgdXBsb2FkZWQgZG9jdW1lbnRzIHVzaW5nIHRoZWlyIG1ldGFkYXRhIGFuZCBlbmZvcmNlIGZlYXR1cmUgcG9saWNpZXMgYmFzZWQgb24gYXNzaWduZWQgdGFncy5cbiAgICAgICAgPC9wPlxuICAgICAgICA8c2VjdGlvbiBjbGFzcz1cInRhZy1saXN0XCIgOmNsYXNzPVwieyAnaXMtbG9hZGluZycgOiBsb2FkaW5nIH1cIj5cbiAgICAgICAgICAgIDx0YWJsZT5cbiAgICAgICAgICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aCB2LXRyYW5zbGF0ZSBjb2xzcGFuPVwiMlwiPk1ldGFkYXRhPC90aD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aCB2LXRyYW5zbGF0ZSByb3dzcGFuPVwiMlwiPlRhZzwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGggdi10cmFuc2xhdGUgY29sc3Bhbj1cIjNcIj5Qb2xpY2llczwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGggdi10cmFuc2xhdGUgY29sc3Bhbj1cIjJcIj5Mb2dnaW5nPC90aD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoIHYtdHJhbnNsYXRlPlByb3BlcnR5IFhQYXRoPC90aD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aCB2LXRyYW5zbGF0ZT5Qcm9wZXJ0eSBWYWx1ZTwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGggdi10cmFuc2xhdGU+UHJldmVudCB1cGxvYWQ8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoIHYtdHJhbnNsYXRlID5QcmV2ZW50IGxpbmsgc2hhcmluZzwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGggdi10cmFuc2xhdGUgc3R5bGU9XCJtaW4td2lkdGg6MTI1cHhcIj5VbnByb3RlY3RlZCBsaW5rcyBleHBpcmU8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoIHYtdHJhbnNsYXRlIGNvbHNwYW49XCIyXCI+RG9jdW1lbnQgSUQgWFBhdGg8L3RoPlxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgIDwvdGhlYWQ+XG4gICAgICAgICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAgICAgICAgICA8dHIgdi1pZj1cIiFydWxlcy5sZW5ndGhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVwiN1wiIGNsYXNzPVwidGV4dC1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZW0gdi10cmFuc2xhdGU+Tm8gZGF0YSB5ZXQ8L2VtPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICAgPHRyIHYtZm9yPVwiKHJ1bGUsIHJpZCkgaW4gcnVsZXNcIiA6a2V5PVwicmlkXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgdi1tb2RlbC5sYXp5PVwicnVsZS54cGF0aFwiIDpyZWFkb25seT1cImxvYWRpbmdcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgdi1tb2RlbC5sYXp5PVwicnVsZS52YWx1ZVwiIDpyZWFkb25seT1cImxvYWRpbmdcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJ0ZXh0LWJvbGQgdGV4dC1tb25vc3BhY2VcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IHYtbW9kZWw9XCJydWxlLnRhZ0lkXCIgOmRpc2FibGVkPVwibG9hZGluZ1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHYtZm9yPVwiKHRhZywgdGlkKSBpbiB0YWdzXCIgOmtleT1cInRpZFwiIDp2YWx1ZT1cInRhZy5pZFwiIDpkaXNhYmxlZD1cInRhZ0hhc1J1bGVzKHRhZy5pZCkgJiYgcnVsZS50YWdJZCAhPSB0YWcuaWRcIj57eyBnZXRUYWdOYW1lQnlJZCh0YWcuaWQpIH19PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVwiY2hlY2tib3hcIiA6Y2xhc3M9XCJ7J2lzLWNoZWNrZWQnIDogIXJ1bGUuaXNVcGxvYWRBbGxvd2VkIH1cIiBAY2xpY2s9XCJ0b2dnbGVBbGxvd1VwbG9hZChyaWQpXCI+PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cImNoZWNrYm94XCIgOmNsYXNzPVwieydpcy1jaGVja2VkJyA6ICFydWxlLmlzTGlua1NoYXJlQWxsb3dlZCB9XCIgQGNsaWNrPVwidG9nZ2xlQWxsb3dMaW5rU2hhcmUocmlkKVwiPjwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiB2LWlmPVwicnVsZS5pc0xpbmtTaGFyZUFsbG93ZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gdi10cmFuc2xhdGU+YWZ0ZXI8L3NwYW4+IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgdi1tb2RlbC5sYXp5PVwicnVsZS5kYXlzVW50aWxQYXNzd29yZGxlc3NMaW5rU2hhcmVzRXhwaXJlXCIgbWluPVwiMVwiIDpyZWFkb25seT1cImxvYWRpbmdcIiBzdHlsZT1cIndpZHRoOjM4cHg7dGV4dC1hbGlnbjpjZW50ZXI7XCI+IDxzcGFuIHYtdHJhbnNsYXRlPmRheXM8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIHYtbW9kZWwubGF6eT1cInJ1bGUuZG9jdW1lbnRJZFhwYXRoXCIgOnJlYWRvbmx5PVwibG9hZGluZ1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cInRleHQtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24gaWNvbi1kZWxldGUgaW5saW5lYmxvY2tcIiBAY2xpY2s9XCJyZW1vdmVSdWxlKHJpZClcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICA8L3RhYmxlPlxuXG4gICAgICAgICAgICA8c2VjdGlvbiBjbGFzcz1cImZvb3RlclwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb290ZXItbGVmdFwiPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgbmFtZT1cImZvb1wiIGlkPVwiZmlsZXNfY2xhc3NpZmllcl9zZWxlY3RfdGFnc1wiIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvb3Rlci1yaWdodFwiPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHYtaWY9XCJoYXNDaGFuZ2VkXCIgOmRpc2FibGVkPVwibG9hZGluZ1wiIEBjbGljaz1cInJlc3RvcmVGcm9tQmFja3VwXCIgdi10cmFuc2xhdGU+UmV2ZXJ0PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidXR0b24tcHJpbWFyeVwiIDpkaXNhYmxlZD1cIiFoYXNDaGFuZ2VkIHx8IGxvYWRpbmdcIiBAY2xpY2s9XCJzYXZlUnVsZXNcIiB2LXRyYW5zbGF0ZT1cImNvcmVcIj5TYXZlPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L3NlY3Rpb24+XG5cbiAgICAgICAgICAgIDwhLS0gU3Bpbm5lciAtLT5cbiAgICAgICAgICAgIDxkaXYgdi1pZj1cImxvYWRpbmdcIiBjbGFzcz1cImxvYWRpbmdcIj48L2Rpdj5cbiAgICAgICAgPC9zZWN0aW9uPlxuICAgIDwvZGl2PlxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZGF0YSAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2FkaW5nICAgIDogZmFsc2UsXG4gICAgICAgICAgICBmYWlsZWQgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBoYXNDaGFuZ2VkIDogZmFsc2UsXG4gICAgICAgICAgICB0YWdzICAgICAgIDogW10sXG4gICAgICAgICAgICBydWxlcyAgICAgIDogW10sXG4gICAgICAgICAgICBiYWNrdXAgICAgIDogbnVsbFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbXB1dGVkIDoge1xuICAgICAgICBmaWx0ZXJlZFRhZ3MgKCkge1xuICAgICAgICAgICAgcmV0dXJuIF8uZmlsdGVyKCB0aGlzLnRhZ3MsICh0YWcpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMudGFnSGFzUnVsZXModGFnLmlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1vdW50ZWQgKCkge1xuICAgICAgICB0aGlzLmZldGNoVGFncygpO1xuICAgICAgICB0aGlzLmZldGNoUnVsZXMoKTtcblxuICAgICAgICAkKCcjZmlsZXNfY2xhc3NpZmllcl9zZWxlY3RfdGFncycpLnNlbGVjdDIoe1xuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHRoaXMuJGdldHRleHQoJ0FkZCBhIHRhZycpLFxuICAgICAgICAgICAgZm9ybWF0Tm9NYXRjaGVzOiB0aGlzLiRnZXR0ZXh0KCdObyB0YWdzIGZvdW5kJyksXG4gICAgICAgICAgICBpbml0U2VsZWN0aW9uIChlbCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgZm9yIHRoZSByZXNldCB0byB3b3JrXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBxdWVyeTogKHF1ZXJ5KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdHMgPSBfLmZpbHRlcih0aGlzLmZpbHRlcmVkVGFncywgKHRhZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFnLnRleHQudG9VcHBlckNhc2UoKS5pbmRleE9mKHF1ZXJ5LnRlcm0udG9VcHBlckNhc2UoKSkgPj0gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBxdWVyeS5jYWxsYmFjayh7cmVzdWx0c30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5vbignY2hhbmdlJywgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkUnVsZShlLmFkZGVkLmlkKTtcbiAgICAgICAgICAgICQoZS50YXJnZXQpLnNlbGVjdDIoJ3ZhbCcsICcnKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHdhdGNoIDoge1xuICAgICAgICBydWxlcyA6IHtcbiAgICAgICAgICAgIGRlZXAgOiB0cnVlLFxuICAgICAgICAgICAgaGFuZGxlciAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmJhY2t1cCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRldGVjdCBjaGFuZ2VzIGluIHRoZSBmb3JtXG4gICAgICAgICAgICAgICAgdGhpcy5oYXNDaGFuZ2VkID0gSlNPTi5zdHJpbmdpZnkodGhpcy5ydWxlcykgIT09IHRoaXMuYmFja3VwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcblxuICAgICAgICAvLyBzZXR0aW5nIHN0YXRlc1xuXG4gICAgICAgIF9zZXRMb2FkaW5nKCkge1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkICA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zZXRGYWlsZWQgKG1lc3NhZ2UgPSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZhaWxlZCAgPSAobWVzc2FnZSkgPyBtZXNzYWdlIDogdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfc2V0RG9uZSAoKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkICA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHByaXZhdGUgZnVuY3Rpb25zXG5cbiAgICAgICAgX2JhY2t1cFJ1bGVzICgpIHtcbiAgICAgICAgICAgIHRoaXMuYmFja3VwID0gSlNPTi5zdHJpbmdpZnkodGhpcy5ydWxlcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3Jlc3RvcmVSdWxlcyAoKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bGVzID0gSlNPTi5wYXJzZSh0aGlzLmJhY2t1cCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gcHVibGljIGZ1bmN0aW9uc1xuXG4gICAgICAgIGFkZFJ1bGUgKHRhZ0lkKSB7XG4gICAgICAgICAgICBsZXQgbmV3UnVsZSA9IF8uZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICB4cGF0aCA6IG51bGwsXG4gICAgICAgICAgICAgICAgdmFsdWUgOiBudWxsLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50SWRYcGF0aCA6IG51bGwsXG4gICAgICAgICAgICAgICAgZGF5c1VudGlsUGFzc3dvcmRsZXNzTGlua1NoYXJlc0V4cGlyZSA6IG51bGwsXG4gICAgICAgICAgICAgICAgaXNVcGxvYWRBbGxvd2VkIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc0xpbmtTaGFyZUFsbG93ZWQgOiB0cnVlXG4gICAgICAgICAgICB9LCB7IHRhZ0lkIH0pO1xuXG4gICAgICAgICAgICB0aGlzLnJ1bGVzLnB1c2gobmV3UnVsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlUnVsZSAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubG9hZGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMucnVsZXMuc3BsaWNlKGtleSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VGFnTmFtZUJ5SWQgKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5maW5kV2hlcmUodGhpcy50YWdzLCB7IGlkIH0gKS50ZXh0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHRhZ0hhc1J1bGVzIChpZCkge1xuICAgICAgICAgICAgbGV0IGZpbHRlcmVkID0gXy53aGVyZSggdGhpcy5ydWxlcywgeyB0YWdJZCA6IGlkIH0pO1xuICAgICAgICAgICAgcmV0dXJuICEhZmlsdGVyZWQubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3RvcmVGcm9tQmFja3VwICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVSdWxlcygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvZ2dsZUFsbG93VXBsb2FkIChpZCkge1xuICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnJ1bGVzW2lkXTtcbiAgICAgICAgICAgIHJ1bGUuaXNVcGxvYWRBbGxvd2VkID0gIXJ1bGUuaXNVcGxvYWRBbGxvd2VkO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvZ2dsZUFsbG93TGlua1NoYXJlIChpZCkge1xuICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnJ1bGVzW2lkXTtcbiAgICAgICAgICAgIHJ1bGUuaXNMaW5rU2hhcmVBbGxvd2VkID0gIXJ1bGUuaXNMaW5rU2hhcmVBbGxvd2VkO1xuXG4gICAgICAgICAgICBpZiAgKCFydWxlLmlzTGlua1NoYXJlQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgIHJ1bGUuZGF5c1VudGlsUGFzc3dvcmRsZXNzTGlua1NoYXJlc0V4cGlyZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQVBJIGZ1bmN0aW9uc1xuXG4gICAgICAgIGZldGNoVGFncygpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldExvYWRpbmcoKTtcblxuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgIHVybCA6IE9DLmdlbmVyYXRlVXJsKCdhcHBzL2ZpbGVzX2NsYXNzaWZpZXIvdGFncycpXG4gICAgICAgICAgICB9KS5zdWNjZXNzKCh0YWdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWdzID1cbiAgICAgICAgICAgICAgICAgICAgXy5jaGFpbih0YWdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLndoZXJlKHsgaXNVc2VyRWRpdGFibGUgOiBmYWxzZSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgodGFnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGFnLmlzVXNlclZpc2libGUgJiYgdGFnLmlzVXNlckFzc2lnbmFibGUgJiYgdGFnLmlzVXNlckVkaXRhYmxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gc2VsZWN0MiByZWFkeSBtYXBwaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA6IHRhZy5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgOiB0YWcubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudmFsdWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXREb25lKCk7XG4gICAgICAgICAgICB9KS5mYWlsKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRGYWlsZWQoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZldGNoUnVsZXMgKCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0TG9hZGluZygpO1xuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgIHVybCA6IE9DLmdlbmVyYXRlVXJsKCdhcHBzL2ZpbGVzX2NsYXNzaWZpZXIvcnVsZXMnKVxuICAgICAgICAgICAgfSkuc3VjY2VzcygocnVsZXMpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bGVzID0gKHJ1bGVzKSA/IHJ1bGVzIDogW107XG4gICAgICAgICAgICAgICAgdGhpcy5fYmFja3VwUnVsZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXREb25lKCk7XG4gICAgICAgICAgICB9KS5mYWlsKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRGYWlsZWQoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNhdmVSdWxlcyAoKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRMb2FkaW5nKCk7XG4gICAgICAgICAgICBsZXQgcHJlcGFyZWQgPSB0aGlzLnJ1bGVzLm1hcCgocnVsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBleHBpcmUgPSBwYXJzZUludChydWxlLmRheXNVbnRpbFBhc3N3b3JkbGVzc0xpbmtTaGFyZXNFeHBpcmUsIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAoIWV4cGlyZSkge1xuICAgICAgICAgICAgICAgICAgICBleHBpcmUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gXy5leHRlbmQocnVsZSwgeyBkYXlzVW50aWxQYXNzd29yZGxlc3NMaW5rU2hhcmVzRXhwaXJlIDogZXhwaXJlIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1BVVCcsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgIHVybDogT0MuZ2VuZXJhdGVVcmwoJ2FwcHMvZmlsZXNfY2xhc3NpZmllci9ydWxlcycpLFxuICAgICAgICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KHByZXBhcmVkKVxuICAgICAgICAgICAgfSkuc3VjY2VzcygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5mZXRjaFJ1bGVzKCk7XG4gICAgICAgICAgICB9KS5mYWlsKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRGYWlsZWQoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuPC9zY3JpcHQ+XG4iLCIvKipcbiAqXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxOCwgb3duQ2xvdWQgR21iSFxuICogQGxpY2Vuc2UgT0NMXG4gKlxuICogVGhpcyBjb2RlIGlzIGNvdmVyZWQgYnkgdGhlIG93bkNsb3VkIENvbW1lcmNpYWwgTGljZW5zZS5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBvd25DbG91ZCBDb21tZXJjaWFsIExpY2Vuc2VcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly9vd25jbG91ZC5jb20vbGljZW5zZXMvb3duY2xvdWQtY29tbWVyY2lhbC8+LlxuICpcbiAqL1xuXG5cbi8vIEBOT1RFOiBVc2UgdnVlLmpzIChkcm9tIC5taW4uKSBpbiBkZXZlbG9wbWVudCBtb2RlXG4vLyBAVE9ETzogRW1wbG95IE5PREVfRU5WIHNwZWNpZmljIHZlcnNpb24ocylcbmltcG9ydCBWdWUgZnJvbSAndnVlL2Rpc3QvdnVlLm1pbi5qcyc7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi9jb21wb25lbnRzL3NldHRpbmdzLnZ1ZSc7XG5cbmltcG9ydCB7IG1peGluIGFzIHQsIGRpcmVjdGl2ZSB9IGZyb20gJy4vdHJhbnNsYXRlLmpzJztcblxuVnVlLm1peGluKHQpO1xuVnVlLmRpcmVjdGl2ZSgndHJhbnNsYXRlJywgZGlyZWN0aXZlKTtcblxuY29uc3QgZmlsZXNfY2xhc3NpZmllciA9IG5ldyBWdWUoe1xuXHR0ZW1wbGF0ZSA6ICc8U2V0dGluZ3MvPicsXG5cdGNvbXBvbmVudHMgOiB7XG5cdFx0U2V0dGluZ3Ncblx0fVxufSk7XG5cbiQoZG9jdW1lbnQpLnJlYWR5KCgpID0+IHtcblxuXHQvLyBvdXRzb3VyY2VkIGZvciBlc2xpbnQgcHVycG9zZXNcblx0ZmlsZXNfY2xhc3NpZmllci4kbW91bnQoJyNhcHAtZmlsZXNfY2xhc3NpZmllcicpO1xufSk7XG4iLCJjb25zdCBtaXhpbiA9IHtcblx0ZGF0YSAoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGNvcmUgOiAnY29yZSdcblx0XHR9O1xuXHR9LFxuXHRtZXRob2RzIDoge1xuXHRcdHQoc3RyaW5nLCBzY29wZSA9ICdmaWxlc19jbGFzc2lmaWVyJykge1xuXHRcdFx0cmV0dXJuIHQoc2NvcGUsIHN0cmluZyk7XG5cdFx0fSxcblx0XHQkZ2V0dGV4dChzdHJpbmcsIHNjb3BlID0gJ2ZpbGVzX2NsYXNzaWZpZXInKSB7XG5cdFx0XHRyZXR1cm4gdChzY29wZSwgc3RyaW5nKTtcblx0XHR9XG5cblx0fVxufTtcblxuY29uc3QgZGlyZWN0aXZlID0ge1xuXHRiaW5kIChlbCkge1xuXHRcdGVsLmlubmVyVGV4dCA9IHQoJ2ZpbGVzX2NsYXNzaWZpZXInLCBlbC5pbm5lclRleHQudHJpbSgpKTtcblx0fVxufTtcblxuZXhwb3J0IHtcblx0bWl4aW4sXG5cdGRpcmVjdGl2ZVxufTsiXX0=
